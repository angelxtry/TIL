# 4장. 기본 관용구

## Dictionary 초기화

```cs
var dict = new Dictionary<string, string>
{
    { "ko", "한국어" },
    { "en", "영어" },
};
```

* C# 6.0 이후에는 다음과 같이 작성할 수도 있다.

```cs
var dict2 = new Dictionary<string, string>
{
    ["ko"] = "한국어",
    ["en"] = "영어",
};
```

## 수치가 어떤 범위에 있는지 확인

```cs
if (MinValue <= num && num < MaxValue) { }
```

## 체로 걸러 남은 것만을 처리

* 메서드 앞부분에 만족하지 않는 조건을 모아서 작성하고 return 문으로 제외한다.

## bool 값을 판단

```cs
int? num = GetNumber();
if (num.HasValue) {  }
```

* num.HasValue == null 이라고 표현할 필요가 없다.

## 컬렉션에 있는 요소를 모두 꺼내서 처리

* LINQ, foreach, for 의 순서로 작성한다.

## `List<T>`에 있는 모든 요소를 처리

* ForEach 메서드를 사용하면 foreach 문을 사용하지 않아도 된다.

```cs
var nums = new List<int> { 1, 2, 3, 4, 5 };
foreach (var n in nums) WriteLine("[{0}]", n);
nums.ForEach(n => WriteLine("[{0}]", n));
```

* ForEach 메서드의 람다식이 길어진다면 foreach를 사용한다.
* ForEach 메서드에는 break, continue, yield, return을 사용할 수 없다.
* ForEach 메서드를 사용할 때 리스트에 있는 요소를 그대로 메서드의 인수로 전달할 수 있고 반환값이 없는 메서드일 경우 메서드 이름만 지정해도 된다.
* 왜냐하면 ForEach 메서드의 인수는 `Action<T>` 델리게이트이기 때문이다.

```cs
nums.ForEach(WriteLine);
```

## 루프 도중에 처리를 중단

* break 문을 이용한다.

```cs
foreach (var item in items)
{
    if ((line.Length + item.Length) > 40)
        break;
    line += item;
}
```

* 다음과 같이 작성하지 않는다.

```cs
foreach (var item in items)
{
    if ((line.Length + item.Length) <= 40)
        line += item;
}
```

* 루프에서 빠져나오면서 곧바로 호출한 메서드로 돌아가려고 할 경우 루프 안에서 return 문을 사용한다.

## 조건 연산자를 사용 Conditional Operator

```cs
var num = list.Contains(key) ? 1 : 0;
```

* if문 대신 조건 연산자를 사용할 수 있다면 적극적으로 사용한다.

## nullable을 활용

```cs
var message = GetMessage(code) ?? DefaultMessage();
```

## null Conditional Operator

* `?.` 또는 `?[` 형태로 사용된다.

```cs
return sale?.Product;
```

* 위 코드를 풀어쓰면 다음과 같다.

```cs
if (sale == null) return null;
else return sale.Product;
```

* sale 변수가 null이 아닐 때는 Product 속성값을 반환하고 null일 경우에는 null을 반환한다.
* 위 코드를 Conditional Operator를 사용하면 다음과 같다.

```cs
return (sale == null) ? null : sale.Product;
```

* null conditional operator는 배열에도 사용할 수 있다.

```cs
var first = customers?[0];
```

* customers가 null일 경우 first에 null이 대입
* null이 아닐 경우 countomers[0] 값이 대입된다.

* null conditional operator와 nullable을 함께 사용할 수도 있다.

```cs
var product = GetProduct(id);
var name = product?.Name ?? DefaultName;
```

* product가 null이면 DefaultName이 대입
* product가 null이 아니면 product.Name이 대입된다.

## 속성 초기화

* C# 6.0부터 사용할 수 있는 속성 초기화

```cs
public int MinLength { get; set; } = 6;
public string DefaultUrl { get; set; } = GetDefaultUrl();
```

* 메서드를 호출해서 초기화할 수도 있다.

## 읽기 전용 속성

* set accessor의 접근 수준을 private으로 지정

```cs
public string GivenName { get; private set; }
```

* 이렇게 하면 클래스 안에서만 해당 속성을 수정할 수 있고 클래스 밖에서는 해당 속성을 수정할 수 없다.
* 최대한 private으로 설정한다.

* get accessor만 사용한 속성

```cs
public string Name { get { return FName + " " + GName; } }
```

* get accessor만 사용할 경우 해당 클래스 안에서도 수정할 수 없다.
* readonly 키워드가 비슷한 역할을 한다.

* C# 6.0 이후는 읽기 속성을 다음과 같이 설정할 수 있다.

```cs
public string Name => FName + " " GName;
```

## 참조형인 읽기 전용 속성

* 읽기 전용 속성이 참조형인 경우 참조는 수정할 수 없고 속성이 가리키고 있는 객체는 수정할 수 있다.

```cs
class MySample
{
    public List<int> MyList { get; private set; }

    public MySample()
    {
        MyList = new List<int>() { 1, 2, 3, 4, 5 };
    }
}

class Program
{
    static void Main(string[] args)
    {
        var obj = new MySample();
        obj.MyList.Add(1);
        obj.MyList.RemoveAt(0);
        //obj.MyList = new List<int>();

        foreach (var n in obj.MyList) WriteLine(n);
    }
}
```

* 위 코드에서 MyList의 set accessor를 private으로 지정했다.
* MyList에 Add, RemoveAt 메소드를 호출해도 모두 정상적으로 동작한다.
* 하지만 MyList에 `List<T>`를 재할당하려고 하면 컴파일 에러가 발생한다.
* 컬렉션 자체를 수정할 수 없게 하려면 `IReadOnlyList<int>`나 `IEnuberable<int>`로 지정해야 한다.

## 가변 인수 variable number of arguments

* param 키워드를 사용한다.

```cs
private static double Median(params double[] args)
{
    var sorted = args.OrderBy(n => n).ToArray();
    int index = sorted.Length / 2;
    if (sorted.Length % 2 == 0)
        return (sorted[index] + sorted[index - 1]) / 2;
    else
        return sorted[index];
}

static void Main(string[] args)
{
    var median = Median(1.0, 2.0, 3.0, 4.0);
    WriteLine(median);
    var median1 = Median(1.0, 2.0, 3.0, 4.0, 5.0);
    WriteLine(median1);
}
```

* String.Format 처럼 인수를 지정해서 로그를 출력하는 메서드를 정의할 때도 param을 사용한다.

```cs
private static void WriteLog(string format, params object[] args)
{
    var s = String.Format(format, args);
    WriteLine(s);
}

static void Main(string[] args)
{
    var now = DateTime.Now;
    var user = "lee";
    var msg = "Hello World!";

    WriteLog("Time: {0} User: {1} Message: {2}", now, user, msg);
}
```

## 문자열을 숫자값으로 변환

```cs
static void Main(string[] args)
{
    string inputMsg = ReadLine();
    if (int.TryParse(inputMsg, out int height))
        WriteLine(height);
    else WriteLine("Parse Error.");
}
```

* TryParse는 문자열을 지정된 숫자 타입으로 변환한다.
* 성공하면 true, 실패하면 false를 return
* out 키워드로 변환된 숫자를 받을 때 변수를 선언하는 것이 좋다.

## 참조형의 형변환

```cs
var product = Session["MyProduct"] as Product;
if (product == null) { }
else { }
```

* Session이 object 형을 반환하는 속성이라고 할 때 as 연산자를 사용하여 Product 형변환을 확인한다.
* 형변환에 실패할 경우 null을 return
* C# 7.0에서는 is 연산자가 확장되어 다음과 같이 작성한다.

```cs
if(Session["MyProduct"] is Product product)
{
    // 형변환 성공. product에 결과가 저장된다.
}
else
{
    // 형변환 실패.
}
```