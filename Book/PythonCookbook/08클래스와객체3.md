# 08. 클래스와 객체

## 8.9 새로운 클래스나 인스턴스 속성 만들기

* 타입 확인 등과 같이 추가적 기능을 가진 새로운 종류의 인스턴스 속성을 만들려면 그 기능을 디스크립터 클래스 형태로 정의해야 한다.

```py
class Integer:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError('Expected an int')
        instance.__dict__[self.name] = value

    def __delate__(self, instance):
        del instance.__dict__[self.name]
```

* 디스크립터는 세 가지 중요한 속성 접근 명령(get, set, delete)을 특별 메소드 `__get__(), __set__(), __delete__()` 형식으로 구현한 클래스이다.
* 이 메소드는 인스턴스를 입력으로 받는다.
* 그리고 인스턴의 기반 딕셔너리는 속성으로 만들어진다.
* 디스크립터를 사용하려면, 디스크립터의 인스턴스는 클래스 정의에 클래스 변수로 들어가야 한다.

```py
class Point:
    x = Integer('x')
    y = Integer('y')
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

* 이렇게 하면 디스크립터에 대한 모든 접근은 `__get__(), __set__(), __delete__()` 메소드를 사용한다.

```py
p = Point(2, 3)
print(p.x)  # Point.x.__get__(p, Point) 호출
p.y = 5  # Point.x.__set__(p, 5) 호출
print(p.y)
p.x = 2.3  # Point.x.__set__(p, 2.3) 호출
```

```sh
2
5
Traceback (most recent call last):
  File "test.py", line 30, in <module>
    p.x = 2.3  # Point.x.__set__(p, 2.3) 호출
  File "test.py", line 13, in __set__
    raise TypeError('Expected an int')
TypeError: Expected an int
```

* 입력으로 디스크립터의 모든 메소드는 가공 중인 인스턴스를 받는다.
* 요청 받은 작업을 수행하기 위해 인스턴스 dictionary(`__dict__` 속성) 역시 적절히 처리된다.
* 디스크립터의 self.name 속성은 실제 데이터를 인스턴스 dictionary에 저장할 때 사용하는 dictionary 키를 가지고 있다.
* 디스크립터는 파이썬 클래스 기능에 `__slots__, @classmethod, @staticmethod, @property` 같은 도구를 제공한다.
* 디스크립터를 정의하면 get, set, delete와 같은 중요한 인스턴스 연산은 하위 레벨에서 얻고 어떻게 동작할지도 바꿀 수 있다.
* 따라서 라이브러리와 프레임워크를 작성하는 프로그래머에게 매우 중요한 도구가 된다.
* 디스크립터는 인스턴스 기반이 아닌 클래스 레벨에서만 정의가 가능하다.
* 다음과 같은 코드는 동작하지 않는다.

```py
class Point:
    def __init__(self, x, y):
        self.x = Integer('x')
        self.y = Integer('y')
        self.x = x
        self.y = y
```

* `__get__()` 메소드는 다음과 같이 구현한다.

```py
class Integer:
    ...
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]
```

* `__get__()`이 조금 복잡해 보이는 이유는 인스턴스 변수와 클래스 변수를 구분해야 하기 때문이다.
* 디스크립터를 클래스 변수로 접근하면 instance 인자가 None이 된다.
* 이 경우 단순히 디스크립터 자신을 반환하는 것이 일반적이다.
* 다음은 클래스 데코레이터를 사용하는 디스크립터 기반의 고급 코드다.

```py
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError('Expected' + str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]

def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def __repr__(self):
        return 'Stock({0.name!r} {0.shares!r} {0.price!r})'.format(self)

s = Stock('GOOG', 100, 100.123)
print(s)

s = Stock('GOOG', 100.1, 100.123)
```

```sh
Stock('GOOG' 100 100.123)
Traceback (most recent call last):
  File "test.py", line 40, in <module>
    s = Stock('GOOG', 100.1, 100.123)
  File "test.py", line 31, in __init__
    self.shares = shares
  File "test.py", line 14, in __set__
    raise TypeError('Expected' + str(self.expected_type))
TypeError: Expected<class 'int'>
```

* 특정 클래스의 한 속성에 대한 접근을 제어하기 위해 디스크립터를 사용하지 말아야 한다.
* 이런 경우에는 프로퍼티를 사용해야 한다.
* 디스크립터는 코드 재사용이 빈번히 발생하는 상황에 더 유용하다.
