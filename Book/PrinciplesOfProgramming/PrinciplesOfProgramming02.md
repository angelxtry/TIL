# 프로그래밍의 정석

## 3.22 아키텍처 비기능 요구사항

> 비기능 요구사항의 관점에는 다음과 같은 것이 있다.
> 1. 변경 용이성
> 2. 상호 운용성
> 3. 효율성
> 4. 신뢰성
> 5. 테스트 용이성
> 6. 재사용성

> 아키텍처 설계 시점부터 고려되어야 할 관점이다.
> * 요구사항을 정의할 때는 각각의 관점이 어느 정도 필요해 질지를 확인한다.
> * 개발할 때는 아키텍처 설계 시점에 비기능 요구사항을 고려한 구조를 고민한다.
> * 테스트할 때는 비기능 요구사항을 충족하고 있는지를 확인한다.

> 기능 테스트는 무엇을 하는지, 즉 what에 주목한다. 비기능 테스트는 어떻게 동작하는지, 즉 how에 주목한다.

> 비기능 요구사항을 충족하려면 해당 소프트웨어에 최적인 비기능 요구사항 수준을 판별한 후에 비기능 테스트에도 합격 기준을 마련하는 것이 필요하다. 목표가 없으면 요구사항을 충족할 수 없다. 품질 측정 기준을 사용해 구체적으로 설정하기 바란다.

비기능 요구사항에 구체적인 기준을 만들고 점수를 매긴다. 이것을 위해 설계 시점부터 비기능 요구사항을 고려한다.

> 중요한 비기능 요구사항 중 하나로 보안이 있다. 정보 보안이 정식 정의는 정보의 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)을 유지하는 것이다.

> 기밀성: 허가되지 않은 사람이 정보를 사용하지 못하게 만드는 것. 암호화하여 혹시나 정보 유출이 발생하더라도 유출된 정보를 볼 수 없게 만드는 대책도 수행한다.

> 무결성: 자산의 정확함과 완전함. 제3자의 허가되지 않은 정보 조작을 방지. 디지털 서명등을 활용

> 가용성: 인가된 개체가 요구했을 때 접근 및 사용이 가능한 특성. 장애나 바이러스에 대처하기 위해, 시스템이나 정보를 이중화하거나 백신 프로그램을 활용

## 3.23 변경 용이성
> 해당 소프트웨어를 얼마나 쉽게 개선할 수 있는가

> 수정, 확장, 재조직, 다른 플랫폼으로 이식이 용이한가
> * 보수성, 확장성, 재구축, 이식성

> 보수성: 변경을 국소화해서 다른 모듈에 부작용이 미치는 것을 최소화

> 확장성: 신규 기능 추가, 신규 버전으로 모듈 교체, 불필요한 기능이나 모듈의 제거 등과 같은 작업의 용이함. 모듈간의 결합도가 약해야 한다.

> 재구축: 모듈 간 관계의 재조직화. 모듈의 구현에는 영향을 미치지 않고, 모듈을 유연하게 배치할 수 있는 구조로 작성

> 이식성: 다양한 하드웨어 플랫폼, 사용자 인터페이스, 운영체제, 프로그래밍 언어, 컴파일러 등에 적합하게 작성. 시스템 라이브러리나 사용자 인터페이스 라이브러리 등 플랫폼 고유의 기능을 다루는 부분을 전용 모듈로 독립될 수 있도록 작성

> 좋은 아키텍처 설계의 핵심은 어느 부분이 변경에 대해 높은 유연성을 지녀야 하는지, 변경이 발생하지 않는 부분은 어디인지를 파악하는 것

> 유연성을 지녀야 할 부분은 변경을 고려한 설계를 지원하는 패턴을 사용

> 유연성에만 치우치지 말고 단순함과의 균형을 고려해야 한다.

> 소프트웨어 에이징: 소프트웨어 노후화. 시간이 지날수록 자연스럽게 성능이 떨어진다는 의미
> * 설계가 유연성이 없으므로 변경 때문에 아키텍처가 파괴된다.
> * 설계가 좋다고 해도 설계를 이해하지 못하는 사람이 변경해서 아키텍처가 파괴된다.
> * 아키텍처를 이해하기가 어렵다는 이유로 무질서하게 변경이 이루어져 아키텍처가 파괴된다.
> * 업데이트가 이루어지지 않거나 시대에 뒤쳐져 진부해진다.

> 소프트웨어 에이징은 막을 수없다. 속도를 늦출 수는 있다.

## 3.24 상호 운용성(Interoperability)
> 다른 소프트웨어와 정보를 주고받을 수 있는 능력. 재활용을 통해 신규 개발이 줄어들고, 개발 기간 단축, 비용 삭감 등의 효과

> 프로토콜이나 데이터 형식을 선정할 때는 업계의 표준 규격을 선택하도록 하자.

## 3.25 효율성(Efficiency)
> 리소스를 효율적으로 사용하여 적절한 성능을 내는 것
> * 시간 효율성
>   * 처리율(throughput): 일정 시간 내에 처리를 몇 건 끝낼 수 있는가
>   * 응답 시간(response time): 사용자의 입력 조작부터 응답까지 걸리는 시간
>   * 소요 시간(turnaround time): 사용자의 작업 개시로부터 요구받은 정보의 출력을 끝내기까지 걸리는 시간
> * 자원 효율성
>   * CPU 사용 시간, 메모리 사용량, 스토리지 소비량, 네트워크 전송량 등으로 측정

자원 효율성까지는 고려하지 못하더라도 시간 효율성은 지표로 만들어서 꼭 고려하자.

> 모듈 간의 직접 결합을 피하려고 모듈들 사이에 매개 모듈을 도입 - 간접화
> * 간접화를 이용해 느슨한 결합성을 유지하고 높은 보수성과 확장성, 재사용성을 확보할 수 있다.
> * 대부분의 설계 패턴에서는 기본적인 개념으로 간접화를 도입한다.
> * 간접화를 도입할 때는 효율성과의 균형을 고려해야 한다.
> * 간접화를 도입하면 처리 자체는 장황해지므로 효율성은 떨어진다.

## 3.26 신뢰성(Reliability)
> 예외적인 상황 혹은 예기치 못한 방법이나 부정한 방법으로 사용된 상황에서도 기능을 유지하는 능력
> * 결합 허용력(fault tolerance), 견고성(robustness)

> 결합 허용력
> * 정상적인 동작을 계속 유지하는 능력
> * 예외 발생에 대해 올바른 행위를 보증하고 내부적으로는 복구를 실시한다.

> 견고성
> * 부정한 사용 방법이나 입력 실수로부터 소프트웨어를 보호

> 중복(redundancy): 이중화

> 장애 완화(fail soft): 장애 발생 시 제공하는 기능을 한정하고 중요한 기능만을 제공해서 처리의 지속성을 수선시

> 장애 시 안전(fail safe): 장애 발생 시 해당 부분을 분리

> fool proof: 사용자가 잘못된 조작을 해도 안전하게 가능할 수 있도록 설계

## 3.27 테스트 용이성
> 효율적인 테스트
> * 테스트가 깊이 있고 질이 높다.
> * 적은 비용으로 빠르게 품질을 검증할 수 있다.

> 아키텍처 확정 시점부터 검증 방법에 대한 관점을 포함하여 설계

> 테스트를 쉽게 하기 위한 구조가 메인 코드가 되어도 좋다는 정도로 관점의 전환이 필요

> 모듈 간 종속 관계를 제거하는 것이 핵심이다.

## 3.28 재사용성
> 재사용하는 소프트웨어 개발
> * 프로젝트 내의 기존 모듈, 예전 프로젝트의 모듈, 각종 라이브러리 등을 이용하는 것

> 재사용을 위한 소프트웨어 개발
> * 다른 소프트웨어에서 재사용하기 위한 소프트웨어를 개발

> 난이도 3배의 법칙
> * 재사용 가능한 모듈을 만드는 작업은 단일 소프트웨어에서 사용할 모듈을 개발할 때보다 3배 어렵다는 법칙
> * 모듈 자체를 일반화해야 하고 모듈의 테스트도 일반적인 케이스로 실시해야 한다.

> 테스트 3종류의 법칙
> * 재사용 가능한 모듈은 공유하기 전에 3가지의 다른 소프트웨어로 테스트할 필요가 있다는 법칙

> 같은 문제 영역에서 몇 가지 소프트웨어를 구현하다 보면 설계가 능숙해지고, 난관을 돌파한 경험을 통해 해당 문제 영역에 특화된 프레임워크를 설계할 수 있다.

> 프레임워크는 인터페이스가 정해져 있는 허브 같은 것으로서, 프레임워크에 문제 영역의 가변적인 부분을 컴포넌트로 탈착할 수 있다. - 플러그인 설계

## 3.29 7가지 설계 원리
> 결함을 만들어 내지 않기 위해 고려해야 할, 코드 구조상의 7가지 핵심 관점

> 품질 좋은 코드를 만들기 위한 경험, 패턴.

> 코드 리뷰를 할 때 점검할 관점으로 사용한다.

> 7가지 관점이 있다.
> 1. 단순 원리
> 2. 동형 원리
> 3. 대칭 원리
> 4. 계층 원리
> 5. 선형 원리
> 6. 명증 원리
> 7. 안전 원리

> 코드 리뷰를 할 때 일정한 가치관이나 관점이 없으면 지적이 산만해진다. 참여 구성원이나 상황에 따라 관점에 누락이 생기거나 오차가 있다면 지적에 일관성이 없어지며 리뷰 자체의 품질도 안정되지 않는다. 따라서 7가지 설계 원리처럼 일관되고 핵심적인 점검 관점이 필요하다.

## 3.30 7가지 설계 원리 - 1. 단순 원리(Simplicity Principle)
> 단숨함을 중시한다.

> 복잡하고 전체적인 관련성을 중시하는 것이 아니라 국소적이고 완전성을 중시한다.

## 3.31 7가지 설계 원리 - 2. 동형 원리(Isomorphism Principle)
> 형태를 중시한다. 똑같은 것은 똑같이 다루도록 신경 쓴다.

> 어떤 모둘에서 다루는 숫자의 단위, 공개 함수의 파라미터 수, 사용 순서 등이 통일되도록 한다.

> 똑같은 것이 똑같이 표현되어 있으면 다른 것이 돋보인다. 다른 것이란 버그의 원인이 되기 쉬운 부분이다.

> 통일감 있는 코드는 가독성이 높다.

## 3.32 7가지 설계 원리 - 3. 대칭 원리(Symmetry Principle)
> 대칭성을 중시한다. 어떤 처리에 관해 대응되는 것도 함께 생각해야 한다.

> 예를 들어 어떤 플래그가 참일 때의 처리가 있다면 거짓일 때의 처리도 있어야 한다.

> 조건 분기는 오류가 생기기 쉬운 부분인데 대칭성이 사고의 프레임워크가 되어 조건 누락을 막아준다.

> 예외적인 상황을 생각해 보고 이런 상황을 최대한 제거하자. 예외적 상황은 특수한 경우이기 때문에 대칭성을 무너뜨리고 오류가 발생하기 쉬운 부분이 된다. 특수한 경우가 너무 많다면 애초에 요구사항이 제대로 정리되지 않았을 가능성이 있다.

> 명명의 대칭성도 고려한다.

## 3.33 7가지 설계 원리 - 4. 계층 원리(Hierachy Principle)
> 구조의 계층성을 중시한다.

> 계층마다 수행할 처리를 정해서 같은 종류의 처리가 다른 계층들 사이를 넘나들지 않는 것이 중요하다.

> 예를 들어 리소스를 할당했다면 같은 계층에서 리소스를 해제해야 한다.

> 하나의 계층은 추상화 수준이 같은 요소만으로 구성한다.

> 상위에서 봤을 때 하위 수준은 외부에서 바라보는 듯한 관점으로 기술한다. 상위 수준이 하위 수준을 호출하는 코드여야 이해하기 쉽다.

## 3.34 7가지 설계 원리 - 5. 선형 원리(Linerity Principle)
> 처리의 직선적 흐름을 중시한다.

> 하나의 기능은 여러 가지 다른 기능의 묶음에 의해 실현되는 선형 결합적인 것이 단순하고 좋은 구조다.

> switch 문으로 코드를 제어하거나 상태값을 무턱대고 늘리면 코드를 이해하기 어려워진다.

> 계층의 상위에서 하위를 향해 한 방향으로 흘러가는 처리의 흐름을 의식해서, 반복을 피하고 한 줄로 연결된 법한 시퀀스로 만들면 가독성이 매우 향상되고 기능 추가 등의 개선도 쉬워진다.

> 처리의 분기를 적게 만들고 처리의 흐름을 직선적으로 읽을 수 있는 코드를 작성한다.

> 그렇게 하려면 특별한 동작을 주 처리에 섞어 작성하지 않도록 해야 한다.

## 3.35 7가지 설계 원리 - 6. 명증 원리(Clarity Principle)
> 로직의 명증성을 중시한다.

> 한눈에 봐도 분명하게 옳다고 말할 수 있는 코드를 작성해야 한다. 조금이라도 불명료한 곳이 있으면 명증해 둔다.

> 명증하는 데 수단을 가리지 않는다. 주석, 도표, 별도 문서 등 모든 방법을 동원한다.

## 3.36 7가지 설계 원리 - 7. 안전 원리(Safety Principle)
> 안정성을 중시한다.

> 있을 수 없는 조건을 굳이 고려해서 코드를 작성한다. (case-default, NULL check)

> 코드의 구현에 대해 요구사항이나 기능의 설명서는 필요조건에 불과하다. 문제가 발생했을 때 어디까지 동작해야 충분한지는 적혀 있지 않다.

처리 도중 에러가 발생했을 때 처리 된 항목과 처리되지 않은 항목을 어떻게 보여 줄 것인지를 설계시에 명확히 설정하자.

## 3.37 UNIX 사상
> 17개의 원칙

## 3.38 UNIX 사상 - 1. 모듈화의 원칙
> 코드 중에 관계성이 높은 요소를 모아 모듈을 작성한다. 나아가 모듈의 인터페이스는 불필요한 것을 제거하고 단순하게 만든다.

> 이렇게 하면 어떤 기능에 관한 변경이 해당 모듈 안으로 한정된다.

## 3.39 UNIX 사상 - 2. 명확성의 원칙
> 코드를 읽을 때 이해하기 어려운 코드에 대해 해독을 3회 이상 반복해서는 안된다. 첫 번째만 예외일 수 있다. 두 번째에 똑같은 코드를 해독하게 되었다면 대책을 강구해야 한다.

## 3.40 UNIX 사상 - 3. 구성의 원칙(Rule of Composition)
> 소프트웨어는 다른 소프트웨어와 조합할 수 있도록 가능한 한 단순하게 필터로 만든다.

> 필터란 입력으로 테이터 스트림을 받아들여 가공한 다음 다른 데이터 스트림으로 출력하는 소프트웨어를 말한다. 이때 데이터 스트림의 형식은 텍스트 형식으로 해야 좋은 설계다.

> 텍스트 스트림 인터페이스는 단순하므로 소프트웨어를 강제적으로 정보 은닉 상태로 만들어 준다.

## 3.41 UNIX 사상 - 4. 분리의 원칙(Rule of Separation)
> 메커니즘에서 정책을 분리한다.

> 정책
> * 해당 소프트웨어의 전제에 종속되는 부분
> * 코드 중에서 비교적 불안정하다.
> * 비즈니스 로직이나 사용자 인터페이스

> 메커니즘
> * 소프트웨어의 전제에 종속되지 않는 독립된 부분
> * 코드 중에서 비교적 안정적이다.

> 정책과 메커니즘이 연결되어 있으면
> * 정책이 경직되면서 사용자의 요구에 맞춰 정책을 변경하기 어려워진다.
> * 정책을 변경하려고 하면 안정된 메커니즘까지 변경해야 한다.

> 서비스계 애플리케이션
> * 프로트엔드와 백엔드로 모듈을 분할한다.
> * 통신 프로토콜을 이해하고 클라이언트의 요구사항을 받아들이는 프론트엔드가 정책
> * 실제 서비스를 수행하는 백엔드가 메커니즘

> 편집 애플리케이션
> * 편집 기능을 확장하는 모듈을 설정 파일로 구동할 수 있게 한다.
> * 확장 가능한 사용자 인터페이스가 정책
> * 편집 엔진이 메커니즘
> * 내부의 모듈 분할이 명확해지고 사용자가 자유롭게 확장할 수 있는 기능을 제공할 수 있다.

내부 프로그램은 주로 화면과 로직이 결합되어 있는 경우가 많다. 화면과 로직을 최대한 분리도록 작성하자.

## 3.42 UNIX 사상 - 5. 단순성의 원칙
> 코드가 단순해지도록 설계

> 코드가 팽창하여 복잡해지는 상태를 거부한다. 반대로 단순한 해결 방법을 높게 평가한다.

> 다수의 기능으로 소프트웨어를 화려하게 꾸미려는 압력에 저항한다. 반대로 서로 연동하는 작은 부품으로 분할하는 방법을 찾는다.

## 3.43 UNIX 사상 - 6. 절약의 원칙(Rule of Parsimony)
> 큰 코드는 작성하지 않도록 한다. 코드의 분량이 큰 것과 코드 내부의 복잡도가 큰 것 양쪽을 모두 의미한다.

## 3.44 UNIX 사상 - 7. 투명성의 원칙(Rule of Transparency)
> 투명성
> * 소프트웨어의 동작에 관해 한눈에 봐도 무엇을 어떻게 하고 있는지를 이해할 수 있을 것

> 개시성
> * 소프트웨어 내부 상태에 관해 감시할 수 있거나 보여줄 수 있을 것

> 소프웨어의 동작을 시각화하면 디버깅이나 오류 확인이 간단해진다.

> 설계 초기 단에부터 모듈 내 변수 내용을 서식 문자열로 출력하는 메서드를 넣어 두거나 로그를 충분하게 포함시키자.

## 3.45 UNIX 사상 - 8. 안정성의 원칙(Rule of Robustness)
> 예상외의 조건에서도 적절하게 동작하는 것

> 투명성
> * 코드를 예측할 수 있어서 무엇이 일어나고 있는지를 금방 이해할 수 있는 것

> 단순성
> * 동작이 복잡하지 않아서 모든 분기 조건을 어려움 없이 설명할 수 있는 것

> 투명하고 단순한 코드를 유지하기 위해 다음 작업을 수행한다.

> 코드리뷰
> * 코드를 작성한 프로그래머가 코드의 내부 구조에 관해 올바르게 설명할 수 있어야한다.

> 특이한 입력이나 극단적으로 큰 입력에 견딜 수 있음을 검증
> * 다른 소프트웨어를 이용하여 테스트 하자.

## 3.46 UNIX 사상 - 9. 표현성의 원칙(Rule of Representation)
> 코드에서 정보를 표현할 때는 로직이 아닌 데이터에 모아 작성하는 방식으로 한다.
> * 정보를 데이터에 고정시킴으로써 로직은 읽기 쉬워지고 안정된다.
> * 자료구조를 활용하면 매우 복잡한 것이라도 간단히 모델링할 수 있다.

> 사람 입장에서 절차적인 로직은 쉽게 이해하기 힘들다. 반면에 자료구조는 복잡하 것이라도 비교적 쉽게 이해할 수 있다. 데이터는 로직보다 다루기 쉽다.

> 표현력이나 정보량을 비교하더라도 자료구조의 우위는 명확하다.

> 코드상에서 피할 수 없는 복잡한 부분이 있다면 데이터에 모으도록 한다.

## 3.47 UNIX 사상 - 10. 충격 최소의 원칙(Rule of Least Surprise)
> 사용하는 사람이 의외라고 느끼는 기분이 최소가 되도록 설계한다.

> 유사한 점이 많은 소프트웨어의 인터페이스를 모델로 삼는다.

> 예상 사용자의 특징을 고려한다.

> 언뜻 보면 비슷하지만 미묘하게 다른 상황을 피한다.
> * 소프트웨어의 인터페이스뿐만 아니라 프로그래밍의 인터페이스에도 해당한다.

## 3.48 UNIX 사상 - 11. 침묵의 원칙(Rule of Silence)
> 표시를 최소한으로 줄이고 과묵하게 작업을 수행하게 한다.

> 중요한 정보만 출력하고 출력에 내부 동작과 관련된 정보가 혼재되지 않도록 만들자.

> 실제로 발생한 오류만을 표준 오류 출력으로 표시하고 그 밖에 요구되지 않은 데이터는 일체 출력하지 않도록 한다.

> 디버깅 목적으로 진행 상황에 관해 메시지를 표시하고 싶다면 장황하게 switch문을 만들고, 일반적인 상황에서는 사용되지 않게 비활성화 한다.

## 3.49 UNIX 사상 - 12. 복구의 원칙(Rule of Repair)
> 소프트웨어 동작 중 오류 복구에 실패했다면 처리를 계속해서는 안된다.

> 오류가 발생했을 때는 가능하면 조기에 요란하게 통지하자.

> 소프트웨어의 입력과 출력에 관해 '받아들일 때는 자유주의로, 내보낼 때는 보수주의로'라는 사고방식이 있다.
> * 입력에 관해서는 잘못된 혀식이라도 가능한 한 적절한 의미를 끄집어내서 관용적으로 받아들여야 하고
> * 출력에 관해서는 엄밀히 따져 명료하고도 정확한 데이터를 송출해야 한다는 의미다.

> 관용적이어야 할 것은 '동작의 사양'이지 '사양의 해석'이 아니다.

무슨 소린지 잘 모르겠다.

## 3.50 UNIX 사상 - 13. 경제성의 원칙
> 프로그래머의 시간을 소중히

## 3.51 UNIX 사상 - 14. 생성의 원칙(Rule of Generation)
> 코드를 작성하기 위한 코드를 작성한다. 무리하지 않는 범위에서 적재적소에 부분적으로나마 코드를 생성하도록 한다.

> 반복이 많고 정형적인 코드는 코드 생성기를 활용한다.

## 3.52 UNIX 사상 - 15. 최적화의 원칙
> 코드를 최적화하기 전에 바르게 동작하는 코드를 작성한다.

> 바르게 만든 다음에 빠르게 만든다.

> 일단 동작하는 프로토타입을 만드는 것은 최적화라는 관점에서도 효과적이다. 프로토타입을 사용하면 코드를 작성하지 않아도 되는 기능이 파악된다.

## 3.53 UNIX 사상 - 16. 다양성의 원칙
> 선택의 다양성을 수용하고, 더 좋은 방식을 계속 찾는다.

> 열려 있고 확장성이 넓은 소프트웨어로 만들어서 상호 운용성을 높이거나 곳곳에 커스터마이즈할 수 있는 옵션 혹은 훅(hook)을 제공하는 유연한 소프트웨어를 설계하자.

## 3.54 UNIX 사상 - 17. 확장성의 원칙
> 확장성의 원칙은 데이터 형식(데이터 레이아웃, 데이터 포멧)에도 적용된다.

> 데이터 형식을 자기 완결적이면서 자기 설명적인 구문으로 구성하는 것이 좋은 방식이다.

## 3.55 UNIX 철학

## 3.56 UNIX 철학 - 1. 작은 것이 아름답다.

## 3.57 UNIX 철학 - 2. 한 번에 하나의 작업
> 하나의 작업을 제대로 하는 소프트웨어를 만들 수 없다면 문제를 아직 완전하게 이해하지 못했다는 뜻이다.

## 3.58 UNIX 철학 - 3. 즉시 프로토타입 진행
> 프로토타입 작성이 빠르면 빠를수록 제품의 배포는 빨라진다.

> 프로토타입을 작성하면 전제의 착오가 조기에 발견되어 작은 피해에 머무른다. 프로토타입으로 얻는 피드백을 통해 요구사항 불충분에 따른 재작업을 줄일 수 있다. 요구사항이 잘못되지 않았다는 점을 확신할 수도 있다.

## 3.59 UNIX 철학 - 4. 효율성보다 이식성(Choose portability over efficiency)
> 이식성이란 다른 플랫폼에 맞춰서 코드를 바꿔 작성할 때 비용이 적게 끝나는 소프트웨어 능력이다.

> 이식성을 위해 하드웨어에 종속되는 부분과 종속되지 않는 부분을 분리하여 설계한다. 하드웨어에 종속되지 않는 부분은 재사용하기 쉬운 단위로 모듈화해두자.

## 3.60 UNIX 철학 - 5. 데이터는 텍스트로(Store numerical data in flat ASCII files)
> 숫자 데이터는 ASCII 플랫 파일에 저장한다.

> 코드의 이식성뿐만 아니라 데이터의 이식성도 중시해야 한다. 데이터 이식성에 대한 해답이 바로 텍스트 파일이다.

## 3.61 UNIX 철학 - 6. 레버리지 소프트웨어
> 지렛대 효과를 얻는 방법은 기존 소프트웨어를 재사용하면서 소프트웨어와 소프트웨어를 조합하는 것이다.

## 3.62 UNIX 철학 - 7. 셸 스크립트 활용

## 3.63 UNIX 철학 - 8. 대화형 인터페이스 회피
> 지나친 대화형 인터페이스를 피한다.

> 초보자를 대상으로 대화형 인터페이스를 제공하면 효과적일 때도 있다. 그런 경우라도 익숙해지면 장황해지므로 초보자 대상과 숙련자 대상 양쪽의 인터페이스를 준비하자.

## 3.64 UNIX 철학 - 9. 필터화
> 모든 소프트웨어를 필터로 설계한다.

> 필터란 입력 스트림을 데이터로 받아들여 어떤 형태로든 가공한 다음 가공된 데이터를 출력 스트림으로 송출하는 것이다.

> 소프트웨어의 본질은 데이터를 '처리'하는 것이지 '생성'하는 것은 아니다. 소프트웨어의 능력을 최대한으로 발휘시키기 위해 소프트웨어를 '필터'로 설계한다.

> 그래픽 사용자 인터페이스(GUI)를 같는 소프트웨어 역시 필터다. GUI는 마우스나 키를 이벤트로 처리한다. 이벤트는 윈도우 시스템 제어하에 있는 소프트웨어 입력으로 보내지는데 이것이 입력 스트림이다. 소프트웨어가 이벤트에 반응해서 디스플레이의 표시를 갱신하는데 이것이 출력 스트림이다.

> 데이터의 입력에는 표준 입력을 사용하고, 데이터의 출력에는 표준 출력을 사용하자. 오류 정보에는 표준 오류 출력을 사용하자.

## UNIX 철학과 작은 정리
> 환경 커스터마이즈
> * 사용자가 취향에 따라 직접 환경을 조정할 수 있도록 한다.

> 작고 가벼운 커널
> * 애플리케이션을 커널에 집어넣으면 실행 중인 애플리케이션의 컨텍스트 스위칭을 줄이고 성능을 높일 수 있기 때문이다.
> * 애플리케이션이 커널에 들어가 버리면 일반 프로그래머가 손을 쓸 수 없다.
> * 애플리케이션에 오류가 생겼을 때 커널이 영향을 받을 가능성이 있다.

> 소문자 사용
> * 명명에는 소문자를 쓰되 길이는 짧게 한다.

> 자연 보호
> * 종이를 아껴 자연을 보호한다.
> * 종이에 있는 데이터는 조작할 수 없기 때문이다.

> 침묵은 금
> * 침묵을 지키면 화면상에 의미 있는 데이터만 표시될 뿐 무의미한 정보는 나열되지 않는다.
> * 침묵을 지키면 다른 소프트웨어와 조합하기도 쉬워진다.

> 병렬사고
> * 작은 부분들은 동시에 실행해서 작업의 처리량을 늘리도록 한다.

> 90%의 해
> * 90%를 잘 해낼 수 있게 만드는 쪽이 훨씬 효율적이며 비용 대비 효과가 높아진다.

> 열등해야 뛰어나다.
> * UNIX는 최대공약수적인 시스템이 살아남는다고 믿는다.
> * 고품질이면서 고가인 것보다는 최고품질은 아니지만 효율적인 것이 단연 사용자에게 먹혀든다고 여긴다.

> 계층 지향

## 4.1 응집도(Cohesion)
> * 모듈에 포함된 기능의 순수함을 나타내는 척도, 모듈의 강도를 측정하는 단위
> * 7단계, 단계가 높을수록 순수하고 강하며 좋은 모듈이다.

> 1단계: 암합적 강도
> * 모듈 내 요소 간 특별한 관계가 없다.
> * 암합이란 우연히 요소가 일치한다는 의미
> * 자기 모듈 내 다른 요소와의 관련성은 약하면서도 다른 모듈 내 요소와는 강한 관련을 갖는다.
> * 다른 모듈에서 변경이 이루어지면 크게 영향을 받아 보수하기가 어렵다.

> 2단계: 논리적 강도
> * 어떤 기능을 추상적으로 파악해서 모은 것
> * 예를 들어 모든 입출력 조작을 모아서 모듈화하거나 여러 가지 데이터를 편집하기 위한 모듈을 작성한 경우
> * 모듈 내의 논리는 조건에 따라 실행 경로가 달라진다.
> * 즉, 관련 있는 몇 가지 기능을 포함하면서 그중 하나만이 호출 모듈에 의해 식별되어, 실행되는 모듈
> * 내포된 명령들의 관련성이 약하고 모듈 강도는 약해진다.
> * 입출력 파라미터가 다른 여러 개의 기능과 같은 것이 사용되므로 파라미터를 취급하는 프로그래머가 실수하기 쉽게 만든다.
> * 기능적으로 다수의 공통부분을 포함하고 있으므로 일부의 논리는 공유할 수 있다.
> * 특정 데이터의 처리를 하나의 모듈로 국소화하는 효과도 있다. -> 정보 은닉 가능

> 3단계: 시간적 강도
> * 특정 시점에 연속해서 실행되는 여러 개의 기능을 하나의 모듈로 모은 것
> * 기능 사이에는 그다지 강한 관련성은 없다.
> * 예를 들어 초기 처리 모듈

> 4단계: 순서적 강도
> * 문제를 처리하기 위해 관계된 여러 개의 기능 중 몇 가지를 실행한다. 여러 개의 기능은 순서대로 실행된다.
> * 기본적으로 시간적 강도의 특성을 갖는다. 기능 사이에 순서적인 관련성이 있는 만큼 시간적 강도보다는 강도가 강하다.
> * 여러 개의 기능 중 하나만 필요할 때 사용할 수 없다. 사용하려면 기능 선택이 필요하다. 그렇게 하면 논리적 강도가 되므로 강도가 떨어진다.

> 5단계: 연락적 강도
> * 기본적으로는 순서적 강도의 특성을 갖는다.
> * 순서적 강도와의 차이점은 모듈 내 기능 사이에서 데이터를 교환(연락)하거나 같은 데이터를 참조한다는 점이다.
> * 모듈 내 기능이 데이터에 대해 이어져 있는 만큼 순서적 강도보다는 응집도가 높다.

> 6단계: 정보적 강도
> * 특정 자료구조를 다루는 여러 개의 기능을 하나의 모듈로 모은 것
> * 같은 자료구조(정보)는 가능한 한 특정 모듈에서만 접근하도록 하겠다는 발상
> * 데이터 수정 시 영향을 모듈 내로 한정할 수 있어 정보 은닉도 good
> * 논리적 강도 모듈과의 차이점은 진입점의 개수
> * 논리적 강도 모듈은 진입점을 하나만 가지며 실행할 기능은 파라미터에 의해 선택된다.
> * 정보적 강도 모듈은 진입점을 여러 개 가지며 각 진입점은 단일한 고유 기능을 실행한다.
> * 파리미터를 다루기 어려웠던 논리적 강도 모듈의 단점을 해소할 수 있다.

> 7단계: 기능적 강도
> * 모듈 내의 모든 명령이 하나의 역할(기능)을 실행하기 위해 서로 관련된 모듈, 응집도가 가장 높은 모듈
> * 단일 기능을 수행하기 위해 모든 명령이 서로 관련된다.
> * 기능적 강도를 갖는 모듈의 변경은 해당 모듈만으로 처리할 수 있다.

> 코드는 모듈로 분할함으로써 통제가 가능해진다.

> 분할된 모듈은 독립성이 중요하다. 독립성을 높이려면 각각의 모듈 '내부'에서의 관련성이 최대가 되게, 그리고 모듈 '사이'의 관련성은 최소가 되게 하는 것이 중요하다.

## 4.2 결합도(Coupling)
> 모듈끼리 갖는 관계의 밀접함을 나타내는 척도

> 1단계: 내용 결합
> * 한 모듈과 다른 모듈이 일부를 공유하는 모듈 결합 방식
> * 다른 모듈 내의 외부에 선언되지 않은 데이터를 직접 참조하거나 명령의 일부를 공유하는 경우

> 2단계: 공통 결합
> * 공통 영역에 정의된 데이터를 몇 개 모듈이 공동으로 사용하는 모듈 결합
> * 결합도가 높고 단점이 많다.
> * 공통 영역 데이터는 모듈 간의 인터페이스상에 나타나지 않으므로 코드 해독을 매우 어렵게 만든다.
> * 공통 영역 데이터는 원래 해당 데이터와 관계가 없는 모듈에서도 마음만 먹으먼 사용할 수 있으므로 코드의 안정성이 낮아진다.
> * 공통 결합된 모듈은 공통 영역 데이터를 통해 여러 가지 모듈과 이어져 있으므로 재사용성이 저해된다.
> * 교환하는 파라미터의 수가 많은 것은 적절하지 않음 모듈화가 원인

> 3단계: 외부 결합
> * 외부에 선언된 데이터를 공유하는 모듈 결합 방식
> * 외부에 선언된 데이터 - public으로 선언된 변수
> * 필요한 데이터만 외부에 선언하기 때문에 공통 결합 보다는 결합도가 약하다.

> 4단계: 제어 결합
> * 호출하는 모듈 쪽에서 호출받는 모듈의 제어를 지시하는 데이터를 파라미터로 넘겨주는 모듈 결합 방식
> * 호출하는 쪽은 호출받는 모듈의 논리를 알아야 할 필요가 있고 상대를 불랙박스처럼 다룰 수 없어 결합도가 강해진다.
> * 호출받는 모듈의 응집도가 논리적 강도가 되어 버린다는 결점도 있다.
> * 데이터를 공유하지는 않으므로 공통 결합이나 외부 결합보다는 결합도가 약하다.

> 5단계: 스탬프 결합
> * 공통 영역에 없는 자료구조를 2개의 모듈에서 교환하는 모듈 결합 방식
> * 자료구조의 교환은 파라미터로

> 6단계: 데이터 결합
> * 모듈 간의 인터페이스로 스칼라형 데이터 요소만을 파라미터로 교환하는 모듈 결합 방식
> * 상대 모듈을 불랙박스화할 수 있으므로 결합도는 가장 약하다.
> * 모듈 A는 모듈 B의 입력으로 X를 넘겨주면 출력으로 Y를 받는다는 것만 알고 있다.
> * 스탬프 결합은 넘겨주는 자료구조 중에 일부 데이터만을 사용한다.
> * 자료구조의 모든 데이터를 처리한다면 데이터 결합으로 간주할 수 있다.

> 모듈의 독립성을 높이려면 모듈 간의 인터페이스는 가능한 한 낮은 단계의 결합도를 지향하자.
> * 데이터는 가능한 한 파라미터로 넘겨준다.
> * 데이터는 가능한 한 전역 변수로 두지 않는다. 특정 시점에만 플요한 데이터라면 지역 변수로 두도록 한다.
> * 넘겨주는 값에 따라 동직아 바뀌는 코드를 작성하지 않는다. 예를 들어 파라미터로 건네받는 플래그의 내용이 A라면 추가, D라면 삭제하는 식의 함수는 결합도가 높아진다.

> 멱등성
> * 어떤 조작을 반복해서 수행해도 결과가 같은 것

> 안전성
> * 조작 대상의 상태를 변화시키지 않는 것

> 예를 들어 HTTP의 GET 요청은 멱등성과 안전성이 요구된다. 이 조건을 충족할 경우 GET 요청을 보내고 응답이 돌아오지 않는다면 한 번 더 요청을 보내면 된다.



소프트웨어 에이징
* SQL 쿼리 최적화
* win32와 win64을 래핑한 universial
* 아키텍쳐나 프로토콜이 안정되어 있지 않으면 사람에 의존할 수 바껭 없ㄷ.
    * ex TCP/IP

상호운용성
* 프리머티브성
* 반복의 최소화
* 웹브라우저
    * HTML은 텍스트 객체다.
* 표준 프로토콜을 구현하는가
    * 표준 XML, 표준 JSON
* 사내 문서를 만든다면 API의 인터페이스가 구현되어 있는가
    * 내부 parser를 만들어구현
    * validation이 복잡해진다.
        * validation을 구현하지 않으려면 프로토콜 단위에서 일단 쳐낸다.
    * 디자인 가이드 문서 처럼 문서를 만든다.
* 효율성

* 로직과 데이터를 분리해야 하는가? 합쳐야 한느가
    * Rx, Akka 등등?
    * 로직과 데이터를 

* mapreduce
    * domain language를 언어에 적극적으로 반영하는 것이 맞는가?

* 데이터와 로직의 OCP
    * 데이터가 변경되면 class가 변경된다.
    * 데이터와 로직이 변경되어야 데이터의 변경을 반영할 수 있다.
    * oath 변경이 있을 경우에는?

UNIX 사상은 UNIX를 만들어보면 금방이해한다?

* 구성의 원칙
    * 완결된 데이터가 너무 ㅋ다.
    * 스트림이 필요하다.
    * 계속 스트림을 이용하려면 텍스트가 유리하다.
    * 동영상 편집기는 어떻게 만들것인가!
    