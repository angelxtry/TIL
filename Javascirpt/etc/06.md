#

Array 링크드리스트

length 계산을 자동으로 하는 오브젝트

3.1 이전 버전에 존재

ArrayBuffer 배열

ES2015 이후

----

배열

번호만 부여해서 몰개성하게 가자.

----

왜 예전에는 Array를 구현하지 않았을까? 왜 링크드리스트를 썼을까?

----

object는 hashmap의 성격을 갖고 있다.

hash : 어떤 문자를 숫자로 바꾼것? 숫자는 고유값만 나온다. 즉, 문자와 숫자는 1:1 매칭된다.

map : key와 value로 이루어진 쌍

key를 hash 함수에 넘겨서 나오는 숫자를 Array의 index로 사용한다.

----

숫자, 문자열, 불린, null, undefined를 제외하고 모두 object다.

function도 object다.

----

hashmap의 특성

1. 문자열 키에 대응하는 값

2. 자유롭게 추가 삭제가 가능하다.

----

object를 표현하는 최소의 리터럴 

var a = {}

var b = {
    "a" : "aaa",
    "b" : "zzz"
}

b["a"] == "aaa" <- 이 표현을 사용해라.

b.a == "aaa"

----

var c = {"0": 3, "1": 5, "2": 6}

c["0"] == c[0]

c["1"] == c[1]

c[0]은 0을 문자열로 바꿔서 c["0"]과 동일하게 동작한다.

c["0"] 이 c[0]보다 속도가 더 빠르다.

----

hashmap의 키 중 숫자처럼 생긴 키중에 가장 큰 값 +1을 length로 한다.

즉, js의 array는 연속된 메모리 공간을 차지하지 않는다.

그리고 length가 메모리 공간의 크기를 의미하지도 않는다.

js의 배열은 성긴 배열이라고 부른다.

----

변수의 로직적 수명을 최대한 짧게 가져가자.

 