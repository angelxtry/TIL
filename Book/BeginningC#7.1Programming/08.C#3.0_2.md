# 08. C# 3.0

## 8.8 람다식

* C#의 람다 식은 다음과 같이 사용된다.
* 1 코드로서의 람다 식: 익명 메서드의 간편 표기 용도로 사용된다.
* 2 데이터로서의 람다 식: 람다 식 자체가 데이터가 되어 구문 분석의 대상이된다. 이 람다 식은 별도로 컴파일 할 수 있으며, 메서드로도 실행할 수 있다.

### 8.8.1 코드로서의 람다 식

```cs
Thread thread = new Thread(
    delegate(object obj)
    {
        Console.WriteLine("ThreadFunc in anonymous method called!");
    }
);
```

* C# 컴파일러는 Thread 타입의 생성자가 `void (object obj)` 형식의 델리케이드 인자를 하나 받는다는 것을 알고 있다.
* 익명 메서드의 구문을 더 단순화시키면 다음과 같다.

```cs
Thread thread = new Thread(
    (obj) =>
    {
        Console.WriteLine("ThreadFunc in anonymous method called!");
    }
);
```

* delegate 예약어를 생략하고 인자의 타입을 명시하지 않아도 된다.

```cs
namespace ConsoleApp1
{
    class Program
    {
        delegate int? MyDivide(int a, int b);

        static void Main(string[] args)
        {
            MyDivide myFunc = delegate (int a, int b)
            {
                if (b == 0) { return null; }
                return a / b;
            };

            Console.WriteLine("10 / 2 == " + myFunc(10, 2));
            Console.WriteLine("10 / 0 == " + myFunc(10, 0));
        }
    }
}
```

```cs
namespace ConsoleApp1
{
    delegate int? MyDivide(int a, int b);

    class Program
    {
        static void Main(string[] args)
        {
            MyDivide myFunc = (a, b) =>
            {
                if (b == 0) return null;
                return a / b;
            };

            Console.WriteLine("10 / 2 == " + myFunc(10, 2));
            Console.WriteLine("10 / 0 == " + myFunc(10, 0));
        }
    }
}
```

* 위의 두 코드를 보면 delegate를 선언한 후 실제 사용때는 delegate를 생략하고 인자의 타입도 생략했다.
* 이렇게 람다 식이 사용된 코드를 C# 컴파일러는 내부적으로 익명 메서드와 완전히 동일하게 확장해서 컴파일한다.
* 람다 식은 약식 표현을 하나 더 제공한다.
* 기본적으로 값이 반환된다는 가정하에 return 문을 생략할 수 있다.
* 이 경우 `=>` 기호 다음에 오는 중괄호까지 생략한다.

```cs
namespace ConsoleApp1
{
    delegate int MyAdd(int a, int b);

    class Program
    {
        static void Main(string[] args)
        {
            MyAdd myFunc = (a, b) => a + b;
            Console.WriteLine("10 / 2 == " + myFunc(10, 2));
        }
    }
}
```

#### 8.8.1.1 람다 식을 위한 전용 델리게이트

* 람다 식은 델리게이트에 대응된다.
* 람다 식은 기존의 메서드와는 달리 일회성으로 사용되는 간단한 코드를 표현할 때 사용되는데, 델리게이트를 일일이 정의해야 한다는 불편함이 생긴다.
* 이러한 불편을 해소하기 위해 자주 사용되는 델리게이트 형식을 제네릭으로 일반화해서 BCL에 Action과 Func로 포함시켰다.

```cs
public delegate void Action<T>(Tobj);
// 반환값이 없는 델리게이트. T 형식 매개변수는 입력될 인자 1개의 타입을 지정

public delegate TResult Func<TResult>();
// 반환값이 있는 델리게이트, TResult 형식 매개변수는 반환될 타입을 지정
```

```cs
class Program
{
    static void Main(string[] args)
    {
        Action<string> logOut =
            (txt) =>
            {
                Console.WriteLine(DateTime.Now + ": " + txt);
            };
        logOut("This is my world!");

        Func<double> pi = () => 3.14;
        Console.WriteLine(pi());
    }

}
```

* 비주얼 스튜디오에서는 logOut은 local function으로 변경하는 것을 추천한다.

```cs
double pi() => 3.14;
```

* 비주얼 스튜디오에서는 pi는 위와 같은 형식으로 변경하는 것을 추천한다.
* Func도 생략이 가능한 것 같다.
* 마이크로소프트는 인자를 16개까지 받을 수 있는 Action과 Func를 미리 정의해뒀다.

```cs
Func<int, int, int> myFunc = (a, b) => a + b;
Console.WriteLine(myFunc(1, 2));
```

```cs
int myFunc(int a, int b) => a + b;
```

* 비주얼 스튜디오는 아래 코드를 추천한다.

#### 8.8.1.2 컬렉션과 람다 식

```cs
List<int> list = new List<int> { 3, 1, 4, 5, 2 };
```

* 기본적인 순회는 다음과 같다.

```cs
foreach (var item in list) { Console.WriteLine(item * 2); }
```

* Array 또는 `List<T>`의 컬렉션에 추가된 ForEach 메서드를 이용하면 다음과 같다.

```cs
// List<T>의 ForEach
list.ForEach((item) => { Console.WriteLine(item * 2); });

// Array의 ForEach
Array.ForEach(list.ToArray(),
    (item) => { Console.WriteLine(item * 2); });

// 익명 메서드
list.ForEach(delegate (int item)
    {
        Console.WriteLine(item * 2);
    });
```

* ForEach 메서드는 `Action<T>` 델리게이트를 인자로 받아 컬렉션의 모든 요소를 열람하면서 하나씩 `Action<T>`의 인자로 요소 값을 전달한다.
* 컬렉션에 포함된 요소 중 특정 조건을 만족하는 요소만 처리하는 작업은 FindAll 메서드를 이용한다.

```cs
class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int> { 3, 1, 4, 5, 2 };

        List<int> evenList = list.FindAll((item) => item % 2 == 0);
        evenList.ForEach((item) => { Console.Write(item + ","); });
    }
}
```

* 기존의 컬렉션 크기만을 단순하게 반환하는 Count 속성은 Enumerable 타입의 확장 메서드를 통해 특정 조건을 만족하는 요소의 개수를 반환할 수 있다.

```cs
class Program
    {
        static void Main(string[] args)
        {
            List<int> list = new List<int> { 3, 1, 4, 5, 2 };

            int count = list.Count((item) => item > 3);
            Console.WriteLine("3보다 큰 수는 " + count + "개");
        }
    }
}
```

* Enumerable 타입에 추가된 Where 확장 메서드가 있다.
* FindAll 메서드와 유사한데, FindAll 메서드의 반환값은 `List<T>`였지만, Where는 `IEnumerable<T>`로 열겨형을 반환한다.

```cs
class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int> { 3, 1, 4, 5, 2 };

        IEnumerable<int> enumList = list.Where((item) => item % 2 == 0);
        Array.ForEach(enumList.ToArray(), (item) => { Console.WriteLine(item); });
    }
}
```

* Where 메서드의 반환값이 `IEnumerable<T>` 이기 때문에 yield를 사용한 코드와 유사하다.

```cs
namespace ConsoleApp1
{
    static class ExtensionMethodWhereFunc
    {
        public static IEnumerable<int> WhereFunc(this IEnumerable<int> inst)
        {
            foreach (var item in inst)
            {
                if (item % 2 == 0) yield return item;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            List<int> list = new List<int> { 3, 1, 4, 5, 2 };

            IEnumerable<int> enumList = list.WhereFunc();
            Array.ForEach(enumList.ToArray(),
                (item) => { Console.WriteLine(item); });
        }
    }
}
```

* FindAll의 경우 메서드 실행이 완료되는 순간 람다 식이 컬렉션의 모든 요소를 