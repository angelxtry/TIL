<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="../lib/functional.js"></script>
  <script>
    const { 
      log,
      // valuesIterObj, reverseIter,
      // reduce,
      // go
    } = Functional;
  </script>
</head>

<body>
<script>
  //// reduce 만드는 과정
const collIter = coll =>
  coll.constructor === Object ?
    valuesIter(coll) : coll[Symbol.iterator]();

function reduce(f, coll, acc) {
  const iter = collIter(coll);
  acc = acc === undefined ? iter.next().value : acc;
  for (const v of iter) {
    acc = f(acc, v);
  }
  return acc;
}

function *valuesIter(obj) {
  for (const k in obj) yield obj[k];
}

function *entriesIter(obj) {
  for (const k in obj) yield [k, obj[k]];
}

const incSel = (obj, k) => {
  obj[k] ? obj[k]++ : obj[k] = 1;
  return obj;
}

const countBy = (f, coll) =>
  reduce((counts, a) => incSel(counts, f(a)), coll, {});

const identity = a => a;

const count = coll => countBy(identity, coll);

const pushSel = (obj, k, v) => {
  (obj[k] || (obj[k] = [])).push(v);
  return obj;
}

const groupBy = (f, coll) =>
  reduce((group, a) => pushSel(group, f(a), a), coll, {});

const group = coll => groupBy(identity, coll);

  // log(reduce((acc, a) => acc + a, [1, 2, 3]));

  // log(reduce((acc, a) => acc + a, new Set([1, 2, 3]), 0));

  // // log(reduce((acc, a) => acc + a, valuesIter({ a: 1, b: 2, c: 3 })));
  // log(reduce((acc, a) => acc + a, { a: 1, b: 2, c: 3 }));

  // log(reduce((acc, [k, a]) => acc + a,
  //   entriesIter({ a: 1, b: 2, c: 3 }), 0));

// const posts = [
//   { id: 1, body: '내용1', comment: [{}, {}] },
//   { id: 2, body: '내용2', comment: [{}] },
//   { id: 3, body: '내용3', comment: [{}, {}, {}] },
//   { id: 4, body: '내용3', comment: [{}, {}, {}] },
// ];

// const users = [
//   { id: 1, name: 'name1', age: 30 },
//   { id: 2, name: 'name2', age: 31 },
//   { id: 3, name: 'name3', age: 32 },
//   { id: 4, name: 'name4', age: 31 },
//   { id: 5, name: 'name5', age: 32 },
//   { id: 6, name: 'name6', age: 32 },
// ];

// log(
//   reduce((count, p) => count + p.comment.length, posts, 0)
// );

// log(
//   reduce((counts, u) => {
//     counts[u.age] ? counts[u.age]++ : counts[u.age] = 1;
//     return counts;
//   }, users, {})
// );

// log(
//   reduce((counts, u) => incSel(counts, u.age), users, {})
// );

// log( countBy(u => u.age, users) );

// log(count([1, 2, 1, 2, 3, 3, 3, 3,]))

// log( groupBy(u => u.age, users) );

// log( group([1, 2, 1, 2, 3, 3, 3, 3,]));

async function reduce(f, coll, acc) {
  const iter = collIter(await coll);
  acc = acc === undefined ? iter.next().value : acc;
  for (const v of iter) {
    acc = f(acc, v);
  }
  return acc;
}

// log(reduce((acc, a) => acc + a, [1, 2, 3] ));
// log(reduce((acc, a) => acc + a, Promise.resolve([1, 2, 3])) );

// reduce((acc, a) => acc + a, [1, 2, 3] ).then(log);
// reduce((acc, a) => acc + a, Promise.resolve([1, 2, 3])).then(log);

const then2 = (f, a) => a instanceof Promise ? a.then(f) : f(a);

function reduce(f, coll, acc) {
  return then2(function (coll) {
    const iter = collIter(coll);
    acc = acc === undefined ? iter.next().value : acc;
    for (const v of iter) {
      acc = f(acc, v);
    }
    return acc;
  }, coll);
}

log(reduce((acc, a) => acc + a, [1, 2, 3] ));
reduce((acc, a) => acc + a, Promise.resolve([1, 2, 3])).then(log);

</script>
</body>

</html>