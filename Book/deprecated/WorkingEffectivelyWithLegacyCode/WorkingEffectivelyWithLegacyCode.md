# 레거시 코드 활용 전략

이 책의 주제는 어떻게 테스트를 잘 할 것인가이다.

조금만 더 풀어서 설명하면 다음과 같다.

프로그램은 결국 변경된다. 프로그램을 변경하려면 의도하지 않은 부작용을 없애야 한다. 어떻게? 테스트를 이용해서. 테스트하기 쉽지 않다. 테스트를 쉽게 하려면 의존관계를 분리하자.

원서를 못봤지만, 번역이 매우 깔끔하다. 번역체라고 느껴지는 부자연스러운 문장이 없었다. 소주제에 대한 코드 예시도 쉬운 편이다. 각 챕터에서 전달하고자 하는 내용이 잘 이해된다. (물론 이해와 활용은 별개다.)

책이 무겁다. 단지 페이지 수가 많다는 의미도 아니고 무게가 무겁다는 의미도 아니다. 좋은 내용인걸 알겠고, 써먹어 보고 싶은 부분도 보인다. 그래서 천천히 읽게 되고 페이지 수에 비해 읽는 진도가 느렸다. 데드라인을 정해놓고 읽어서 한번 다 보기는 했지만 다 읽고 난 뒤에 어느 정도 기억하고 있을지, 체득한 부분이 있을지는 모르겠다.

또 봐야지 뭐.

120p에 보면 다음과 같은 문구가 나온다.
> 기존 메소드에 동작을 추가하는 것은 간단한 일이지만, 이것이 옳지 않은 접근법일 때가 자주 있다. 처음 메소드가 작성될 때의 의도는 하나의 동작만을 제공하기 위한 것이 대부분이다. 따라서 나중에 추가되는 코드들은 어떤 의미에서는 의심스러운 것들이다. 개발자가 그런 코드를 추가하는 이유가 단지 추가 코드가 기존 코드와 동시에 실행되기 때문일 때가 있는데, 이는 과거에 일시적 결합(temporal coupling)이라 불리던 현상으로서 과도하게 사용되면 코드의 품질을 저하시킨다. 단지 동시에 실행된다는 이유로 동일 메소드 내에 들어있는 코드 간의 관계는 그다지 강하지 않다.

포장 메소드라는 방법의 필요성을 설명하기 위한 내용이다. 내가 코드를 작성하거나 수정할 때 이렇게 세심하게 고민한 적이 있었나 반성하게 된다.

누군가 작성해 놓은 코드를 수정해야 할 때, 특히 전반적인 설계를 건드려야 할 때 항상 고민하게 된다. 내 방식이 좋은 접근법일까? best practice는 무엇일까? 이 책을 보면 그 갈증이 조금이나마 해소되는 느낌이다. bast practice라고 할 수는 없겠지만 이런 방식으로 접근하면 되겠다라는 생각이 든다.

코드를 수정하면서 우연히 한 번쯤은 해봤던 방식들이 이 책에는 하나의 기법으로 정리되어 있다. 그리고 해당 기법의 장단점도 나온다. 코드를 수정할 때 우연히 생각난 좋은 방식으로 수정하는 것보다 이 상황에서는 어떤 방식이 어울리고, 이 방식의 장단점이 무엇인지 알고 하는 것이 당연히 더 좋을 것이다.

## 1. 코드 변경의 메커니즘

### ch1. 소프트웨어 변경

37p
> 코드를 변경하는 네 가지 이유
> - new feature
> - bug
> - 설계 개선
> - 자원이용의 최적화

43p
> 변경 대상 코드에만 집중하면 안 된다. 어떻게 기존의 동작에 영향을 미치지 않고 유지할 수 있을지 고민해야 하는 것이다. 불행히도, 기존의 동작을 그대로 유지한다는 것은 단순히 코드를 그대로 두는 것 이상의 의미를 갖는다.
> 기존 동작의 유지는 소프트웨어 개발에서 가장 어려운 문제에 속한다.

### ch2. 피드백 활용

45p
> 시스템을 변경하는 방법은 크게 두 가지
> 편집 후 기도하기 edit and pray
> 보호 후 수정하기 cover and modify
> 유감스럽게도 편집 후 기도하기 방식이 업계 표준에 가깝다.

49p
> 단위 테스트의 기본 개념은 독립된 개별 소프트웨어 컴포넌트를 테스트하는 것이다. 단위 테스트에서 얘기하는 컴포넌트는 시스템의 가장 원자적인 동작 단위를 의미한다. 절차적 프로그래밍에서 단위는 보통 함수를 의미하며, 객체 지향 프로그래밍에서는 클래스를 의미한다.
> 테스트 하네스(test harness)는 소프트웨어의 일부 코드를 실행하기 위해 작성되는 테스트용 코드를 의미하는 포괄적인 용어로서 이 책에서 사용된다.

54p
> 대부분의 레거시 코드 작업은 코드를 좀 더 쉽게 변경할 수 있도록 의존 관계를 제거하는 작업을 포함한다.

55p
> 레거시 코드의 딜레마
> 코드 변경을 하려면 테스트 코드를 배치해야 한다. 그런데 테스트 코드를 배치하려면 코드 변경이 필요할 때가 많다.

56p
> 레거시 코드를 변경하는 순서
> 1. 변경 지점을 식별한다.
> 2. 테스트 루틴을 작성할 위치를 찾는다.
> 3. 의존 관계를 제거한다.
> 4. 테스트 루틴을 작성한다.
> 5. 변경 및 리펙토링을 수행한다.

### ch3. 감지와 분리

62p
> 일반적으로 테스트 루틴을 배치할 때 의존 관계를 제거하는 이유는 다음의 두 가지다.
> 1. 감지: 코드 내에서 계산된 값에 접근할 수 없을 때, 이를 감지하기 위해 의존 관계를 제거한다.
> 2. 분리: 코드를 테스트 하네스 내에 넣어서 실행할 수 없을 때, 코드를 분리하기 위해 의존 관계를 제거한다.

### ch4. 봉합 모델

seam

enabling point

### ch6. 고칠 것은 많고 시간은 없고

기존 클래스를 테스트 루틴 안에 넣지 않으면서 변경을 수행하기 위해 몇가지 기법

발아 메소드
발아 클래스
포장 메소드
포장 클래스

발아 메소드

- 새로운 메소드로서 이 기능을 구현한 후 이 메소드를 필요한 위치에서 호출하는 방법
- 독립된 한 개의 기능으로서 코드를 추가하는 경우나 메소드의 테스트 루틴이 아직 준비되지 않은 경우 발아 메소드 사용을 권장

발아 클래스

- 어떤 클래스에 완전히 새로운 역할을 추가하고 싶을 경우
- 기존 클래스에 약간의 기능을 추가하고 싶지만 그 클래스를 테스트 하네스 내에서 테스트할 수 없는 경우

포장 메소드

120p
> 기존 메소드에 동작을 추가하는 것은 간단한 일이지만, 이것이 옳지 않은 접근법일 때가 자주 있다. 처음 메소드가 작성될 때의 의도는 하나의 동작만을 제공하기 위한 것이 대부분이다. 따라서 나중에 추가되는 코드들은 어떤 의미에서는 의심스러운 것들이다. 개발자가 그런 코드를 추가하는 이유가 단지 추가 코드가 기존 코드와 동시에 실행되기 때문일 때가 있는데, 이는 과거에 일시적 결합(temporal coupling)이라 불리던 현상으로서 과도하게 사용되면 코드의 품질을 저하시킨다. 단지 동시에 실행된다는 이유로 동일 메소드 내에 들어있는 코드 간의 관계는 그다지 강하지 않다.

- 장점: 새로운 기능을 추가하면서 봉합부를 도입할 수 있다.
- 단점
  - 새로 추가하려는 기능의 로직이 기존 기능의 로직과 통합될 수 없다.
  - 기존 메소드 내의 코드를 위해 새로운 이름을 고안해야 한다.

포장 클래스

기존 클래스를 상속받는 새로운 클래스를 생성하고 새로운 클래스에서 기존 클래스의 인스턴스를 매개변수로 받아 기존 메소드를 그대로 실행하고 일부 메소드를 추가한다.

상속받는 것이 필수는 아니다. 상속받지 않고도 다른 방식으로 해당 기능을 구현할 수 있다.

128p
> 포장 클래스의 핵심은 신규 동작을 기존 클래스에 추가하지 않으면서 시스템에 추가할 수 있다는 점이다. 포장 대상 코드에 대한 기존 호출이 많은 경우 데코레이터 패턴이 효과적이다. 데코레이터 패턴을 사용하면 다수의 기존 호출에 대해 새로운 기능을 투명하게 추가할 수 있다.
> 반면에 신규 동작이 사용되는 위치가 많지 않을 경우 데코레이터 패턴이 아닌 포장 클래스가 효과적이다. 단, 포장 클래스의 책임에 지속적으로 주의를 기울이고 이 포장 클래스를 시스템의 상위 수준 개념으로 만들 수 있는지 확인할 필요가 있다.

## ch7. 코드 하나 바꾸는 데 왜 이리 오래 걸리지

134p
> 코드 변경 작업은 지연 시간이라는 매우 흔한 이유로 인해 오랜 시간이 걸릴 때가 많다. 지연 시간은 변경을 수행한 시점과 그 변경에 대한 실질적인 피드백을 받을 때까지의 시간을 말한다.

135p
> 어떤 코드든 간에 대부분의 주요 프로그래밍 언어에서 재컴파일과 테스트를 10초 이내에 실행해 의존 관계를 제거할 수 있다.
> 이렇게 하기 위한 조건은 시스템 내의 모든 클래스 및 모듈을 다른 클래스 및 모듈과는 독립적으로 별도의 테스트 하네스에서 컴파일할 수 있어야 한다는 것이다. 이것이 가능하면 매우 빠르게 피드백을 얻을 수 있기 때문에 개발 속도가 크게 향상된다.
> 사람의 심리는 재미있는 특징이 있다. 짧은 업무(5~10초 정도 걸리는)를 수행해야 하는데 1분에 한 단계만 진행할 수 있다면, 대부분의 경우 한 단계를 수행한 후 쉰다. 다음 단계에서 무엇을 할지 판단해야 한다면 계획을 시작하거, 계획이 끝나면 다음 단계의 시작이 가능할 때까지 그냥 딴 생각을 할 것이다.
> 하지만 다음 단계를 시작하기까지의 시간이 1분에서 몇 초 정도로 줄어든다면 접근법이 달라진다. 피드백을 활용해서 다양한 방법을 시험할 수 있고, 마냥 기다리고만 있을 필요가 없어지므로 집중력이 크게 향상된다. 무엇보다 잘못된 점을 발견하고 그것을 수정하는 데 드는 시간이 훨씬 줄어든다는 점이 중요하다.

141p
> 의존 관계를 제거하고, 클래스를 다수의 패키지로 분산시킴으로써 빌드 시간을 줄일 수 있다. 이는 매우 큰 의미가 있다. 테스트 루틴의 재빌드 및 실행 속도를 높이면 개발과정에서 더 많은 피드백을 얻을 수 있기 때문이다. 이는 곧 더 적은 오류와 장애를 의미한다. 그러나 공짜는 아니다. 인터페이스와 패키지 개수가 늘어나므로 개념적으로 부담이 늘기 때문이다. 그럼에도 이런 기법들을 시도할 가치가 있을까? 패키지와 인터페이스 개수가 늘어나서 코드를 조사하는 시간이 늘어날 수도 있지만, 변경 작업은 훨씬 쉬워질 것이다.
