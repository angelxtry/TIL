# 1. 타입과 값

## 7가지 내장 타입으로 바라보기

* 자바스크립트에는 7가지 내장 타입이 있습니다.

1. null
2. undefined
3. boolean
4. number
5. string
6. object
7. symbol

* 위 타입은 다시 크게 두 가지로 나눌 수 있습니다.
* 객체와 객체가 아닌 것입니다.
* 위 7가지 타입에서 객체를 제외한 모든 값은 원시 값이며
* 원시 값의 경우 인자로 전달하거나 할당할 때 항 상 값 복사가 이루어지고
* 객체의 경우는 항상 레퍼런스 사본을 만듭니다.

```js
const log = console.log;
var a = 10;
var b = a;
a = 20;
console.log(b);

var o1 = { a: { b: 10 } };
var o2 = o1;
o2.a = 20;
console.log(o1);
```

* 원시타입과 객체의 전달/할당이 위와 같이 이루어지는 것을 잘 인지하고 다루는 것이 중요합니다.
* 이는 자바스크립트로 함수형 프로그래밍을 할 때 중요하며, 특히 불변성을 다루는 기초가 됩니다.

## 자바스크립트에서의 객체

* 자바스크립트에서의 Array, Map, WeakMap, Set, WeakSet, Promise 등은 모두 object의 하위 타입입니다.

```js
log(typeof {});
log(typeof []);
log(typeof new Map);
log(typeof new Set);
log(typeof new Promise(a => a));
```

## JSON 데이터 타입

* [JSON 데이터 타입](https://www.json.org/json-ko.html)은 다음과 같습니다.

* string
* number
* object
* array
* true, false, null

* JSON은 경량의 DATA 교환 형식이면서, 현대 프로그래밍에서 가장 많이 사용되는 DATA 교환 언어입니다.
* 위 값에 해당하지 않는 모든 값은 JSON으로 직렬화가 불가능합니다.
* 예들 들면 undefined도 JSON으로 직렬화할 수 없습니다.

```js
JSON.stringify(undefined);
// undefined <- JSON String이 된 것이 아니라 함수가 실패하여 undefined가 리턴 된 것

JSON.stringify({ a: undefined });
// "{}"

JSON.stringify([undefined]);
// [null]
```

* Map이나 Set 역시 JSON으로 직렬화할 수 없습니다.

```js
JSON.stringify(new Set([1, 2, 3]));
// {}

JSON.stringify(new Map[['a', 1]]);
// {}
```

* 이처럼 자바스크립트에서는 JSON으로 직렬화할 수 있는 값과 그렇지 않은 값으로 나누어 데이터를 바라볼 수 있습니다.

## Iterable, Iterator

* ES6에는 Iterable/Iterator에 대한 프로토콜이 있고, 그것은 ES6에서 매우 중요합니다.
* 자바스크립터에서 Iterable, Iterator, Symbol.iterator, Generator 둥은 자바스크립트의 `for...of` 문이나 전개 연산자 등과 사용됩니다.
* 이것들은 ES6에서 함수형 프로그래밍을 하는 것에 있어서도 아주 중요한 역할을 합니다.
* ES6의 String, Array, Map, Set 등은 아래와 같이 사용하도록 Symbol.iterator 프로퍼티를 가진 객체입니다.

```js
for (const v of [1, 2, 3]) console.log(v);
console.log([...[1], ...[2, 3]);

for (const v of 'ABC') console.log(v);
```

## Symbol.iterator

### ES6의 Iterable/Iterator 프로토콜 맞추기, 그리고 Generator

* 자바스크립트에서 `for...of`나 전개 연산자(`...`)와 잘 동작하려면 `Symbol.iterator`를 잘 사용해야 합니다.

1. iterable은 `iterable[Symbol.iterator]();` 메서드를 가져야하고, 결과는 iterator 여야 합니다.
2. iterator는 `iterator.next()` 메서드를 가져야하고, 결과는 `{ value: something, done: true/false }` 여야 합니다.

```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      cur: 0,
      next: function() {
        if(this.cur > 5) return { value: undefined, done: true }
        return {
          value: ++this.cur,
          done: false
        }
      },
      [Symbol.iterator]: function() {
        return this;
      }
    }
  }
};

function *reverseIter(arr) {
  var l = arr.length;
  while (l--) yield arr[l];
}

const iter1 = reverseIter([1, 2, 3]);
const.log( iter1[Symbol.iterator]() == iter1 );
const.log( iter1[Symbol.iterator]() == iter1 );
const.log( iter1[Symbol.iterator]() == iter1 );
for (const v of iter1) console.log(v);

const iter2 = obj[Symbol.iterator]();
