# 7장 성능

227p

> 최적화의 첫 번째 법칙은 '하지 않는다'이다.

228p

> 가장 좋은 전략은 과제에 맞는 가장 단순하면서도 가장 분명한 알고리즘과 데이터 구조를 사용하는 것이다.
> 성능 개선은 테스트와 통하는 부분이 많다. 자동화, 철저한 기록 유지, 변경 이후에도 정확한 동작을 하며 과거에 개선한 내용에 영향을 주진 않는지 보기 위한 회귀 테스트 등 똑같은 테크닉을 사용할 수 있다.

231p

프로파일링을 했겠지만 strstr 같은 함수나 strncmp 같은 함수에서 가장 시간이 많이 걸린다고 측정이됐을 때 나는 어떻게 반응했을까? 어쩔 수 없는 상황이라고 판단하고 손을 놨을 것 같다. 더 개선해보려고 시도조차 안했을 것 같다.

235p

Unix의 time 명령어
real, user, sys 세 가지 숫자가 나온다. 모두 초 단위.
real은 프로그램이 완료되기까지의 경과 시간.
user는 그 사용자의 프로그램이 실행되는데 소비된 CPU 기준 시간.
sys는 그 프로그램을 위해 운영체제 내에서 소비된 CPU 시간.

경과 시간(elapsed time)
시계 시간(wall clock time)이라고도 하며, CPU 시간에 프로세스를 올리고 내리는 시간, 동기화, 입출력, 통신 등에 소비되는 시간을 모두 포함한, 사용자가 시계로 잴 수 있는 시간.

CPU 시간(CPU time)
CPU가 그 프로그램을 실제로 실행한 시간.

237p

> 도널드 커누스 "보통, 프로그램의 4퍼센트 이하 부분이 프로그램 실행시간의 반 이상을 차지한다."

239p

> 함수 하나가 이렇게 압도적으로 병목이 될 때 택할 길은 두 가지밖에 없다. 더 나은 알고리즘을 사용해서 그 함수를 개선하거나, 주변 프로그램을 완전히 다시 써서 그 함수를 없애버리는 것이다.

## 7.3 속도를 위한 전략

더 나은 알고리즘이나 데이터 구조를 사용하라.
컴파일러의 최적화 기능을 켜라.
코드를 미세조정하라.
중요하지 않은 것을 최적화하지 말라.

## 7.4 코드 미세조정

공통된 부분 표현식을 하나로 모으라.
비싼 연산을 싼 연산으로 대체하라.
루프를 펼치거나 제거하라.
빈번히 사용되는 값을 캐싱하라.
특수한 메모리 할당 함수를 작성하라. ->  memory pool
입력과 출력을 버퍼링하라.
특수한 경우를 따로 처리하라.
결과를 사전계산하라.
근사값을 사용하라.
저수준 언어로 재작성하라.
