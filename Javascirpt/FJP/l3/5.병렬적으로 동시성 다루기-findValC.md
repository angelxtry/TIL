# 4. 병렬적으로 동시성 다루기

- 웹서버는 코어를 1개만 쓰기로했다면 컴파일 언어로 된 서버가 가장 빠를 것이다.
- 한 유저에게 매우 빠른 응답속도를 제공하는 것보다 여러 유저에게 납득할만한 응답속도를 제공하는 것이 목표다.

## findValC

- findC가 의미가 있으려면 limit가 필수다.
- map 처럼 모든 항목을 다 순회하면 안된다.

```js
function time(a) {
  return new Promise(resolve => {
    setTimeout(function() {
      resolve(a);
    }, 1000);
  })
}

go([1, 2, 3, 4, 5],
  findVal(a => time(a > 3 ? '중간에 나옴' : undefined)),
  log);
```

- time 함수가 있다. 이 함수는 1초 후에 받았던 인자를 그대로 return 한다.
- mapC에서 테스트했던 코드다. 현재 3초 후에 '중간에 나옴'이 출력된다.
- 동시에 실행되도록 findValC를 만들어보자.

```js
const findValC = curry((f, coll, limit = Infinity) => {

});
```

- 여기서 부터 시작한다. limit는 초기값을 Infinity로 설정한다.

```js
const findValC = curry((f, coll, limit = Infinity) => {
  const iter = collIter(coll);
  return function recur() {
    for (const a of iter) {
      f(a);
    }
  } ();
});
```

- 여기까지는 고민할 필요없이 진행한다.

```js
const findValC = curry((f, coll, limit = Infinity) => {
  const iter = collIter(coll);
  return new Promise(function(resolve) {
    for (const a of iter) {
      go(a, f, b => b === undefined ? void 0 : resolve(b));
    }
  });
});
```

- Promise는 중간에 resolve가 발생하면 바로 리턴한다(?)
- 여기까지 작성한 후 테스트 코드를 실행해보자.

```js
go([1, 2, 3, 4, 5, 6],
  findValC(a => time(a > 3 ? '중간에 나옴' : undefined)),
  log);
```

- findValC를 조금 수정해서 결과를 확인해보자.

```js
const findValC = curry((f, coll, limit = Infinity) => {
  const iter = collIter(coll);
  return new Promise(function(resolve) {
    for (const a of iter) {
      go(a, f, b => {
        console.log(b);
        b === undefined ? undefined : resolve(b);
      });
    }
  });
});

go([1, 2, 3, 4, 5, 6],
  findValC(a => time(a > 3 ? a : undefined)),
  a => log(`결과 ${a}`));
```

- 정상적으로 결과가 나오지만 6까지 모든 요소를 순회했음을 알 수 있다.

- time 함수를 다음과 같이 수정해보자.

```js
function time(a) {
  return new Promise(resolve => {
    setTimeout(function() {
      resolve(a);
    }, (a * 1000) || 1000);
  })
}
```

- undefined는 모두 1초만에 출력된다.
- 처음 resolve되는 a 값이 4이기 때문에 4초 후에 결과가 출력되고 5, 6은 각각 1초 후에 한 개씩 출력된다.

```js
go([1, 2, 3, 5, 6, 4],
  findValC(a => time(a > 3 ? a : undefined)),
  a => log(`결과 ${a}`));
```

- 위 처럼 입력 데이터의 순서를 바꿔서 전달해도 결과는 동일하다.
