# Functional Thinking

* 어렵다. 한글을 읽고 있는데 이해가 안된다.

* 수학책 보는 것 느낌.

* 재밌다.

* 얉게 읽었다. 통독하는 느낌으로.

* 소개되는 여러 언어들을 몰라도 된다고 했지만... 모르니 잘 이해 안되더라.

* 함수형 프로그램의 전반적인 개론같으면서도 각 언어의 세부사항이 등장하여 어렵게 느껴진다.

* 스칼라, 클로저, 하스켈 모두 배워보고 싶은 언어.

## 요약

### chapter1. 왜
* chapter1의 소제목들이 '왜'의 좋은 설명이 될 듯하다.
    * 1.1 패러다임 전환
    * 1.2 언어 트렌드에 발맞추기
    * 1.3 언어/런타임에 제어를 양도하기
    * 1.4 간결함

> 잠시 당신이 나무꾼이라고 가정해보자. 당신은 숲에서 가장 좋은 도끼를 가지고 있고, 그래서 가장 일 잘하는 나무꾼이다. 그런데 어느 날 누가 나타나서 나무를 자르는 새로운 패러다임인 전기톱을 알리고 다닌다. 이 사람이 무척 설득력이 있어서 당신은 사용하는 방법도 모르면서 전기톱을 사게 된다. 당신은 여태껏 했던 방식대로 시동을 걸지도 않고 전기톱으로 나무를 마구 두들겨댄다. 곧 당신은 이 새로운 전기톱은 일시적인 유행일 뿐이라고 단정하고 다시 도끼를 쓰기 시작한다. 그때, 누군가 나타나서 전기톱의 시동 거는 법을 가르쳐준다.

> 전혀 새로운 프로그래밍 패러다임의 문제점은 새로운 언어를 배우는 것이 아니다. 어려운 점은 바로 다른 방식으로 사고하는 법을 배우는 것이다.

> 컴플렉트(complect). 이 단어는 서로 꼬아서 연결하다, 또는 섞어 짜다 정도의 의미이다. 명령형 프로그래밍을 하다 보면 효율을 높이기 위해 여러 작업을 한 루프에 넣음으로써, 작업들을 복잡하게 하는 경우가 종종 있다. 함수형 프로그래밍에서는 map()이나 filter() 같은  고계함수를 통해 추상화의 단계를 높여서 문제를 더욱 명료하게 볼 수 있다.

공감된다. 이런 경우 정말 많았는데... 루프를 한번만 돌리고 그 안에서 최대한 여러가지 연산을 처리하는 것이 루프를 반복해서 돌리는 것보다 효율적이라고 생각했다.

> 마침내 자바8에 람다 블록이 도입되었듯, 자바조차도 함수형 기능이 추가되기 시작했다. 그리고 가장 보편화된 언어라고 할 수 있는 자바스크립트에는 이미 많은 함수형 기능이 들어 있다. 오래된 언어인 C++조차도 2011년 표준에서 람다 블록을 더했고, Boost.Phoenix 같은 흥미로운 라이브러리를 추가하면서 함수형 프로그램밍에 관심을 보이고 있다.

람다. 한 줄짜리 함수. 아직 람다의 장점이나 효율을 설명하라고 하면 막연하다. 내가 충분히 이해하지 못했다는 증거다. 람다를 어떻게 잘 설명할 수 있을까?

> 시간이 갈수록 개발자는 지루한 일들을 언어나 런타임에 점점 더 맡기게 된다. 애플리케이션을 만들면서 직접 메모리를 제어하지 않는다는 것을 조금도 후회하지 않는다. 그런 일에 무관심해졌기 때문에 좀 더 중요한 문제들에 집중할 수 있다. 자바가 메모리 관리 작업을 쉽게 해줬다면, 함수형 프로그래밍 언어는 다른 빌딩블록들을 고수준 추상적 개념으로 대체해준다.

한 때 가비지 컬렉션이 없는 언어에서 메모리를 직접 관리한다는 것이 자부심이었던 때도 있었는데... 참 많이 변했다.

> 객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다. - 마이클 페더스(레거시 코드 활용 전략의 저자)

> 객체지향 프로그래밍(OOP) 구조에 대해 생각해보라. 캡슐화, 스코핑, 가시성 등의 메커니즘은 상태(state) 변화를 누가 볼 수 있는지에 대한 세밀한 제어를 위해 존재한다. ... 함수형 언어는 이런 가변(mutable) 상태를 제어하는 메커니즘을 구축하기보다, 그런 움직이는 부분을 아예 제거하는 데 주력한다.

> 객체지향 명령형 프로그래밍 언어에서, 재사용의 단위는 클래스와 그 클래스들이 주고받는 통신 메시지이고, 이는 클래스 다이어그램으로 포착할 수 있다. ... OOP의 세계에서는 고유한 자료구조를 작성하는 것을 권장한다. 그 자료구조에 특정 동작을 메서드의 형태로 부착해서 말이다. 함수형 프로그래밍 언어는 같은 방식으로 재사용을 달성하려 하지 않고, 최적화된 동작으로 몇몇 자료구조(list, set, map)를 이용하는 방식의 재사용을 선호한다.

## chapter2. 전환
> 주어진 조건에 맞는 컬렉션의 부분집합을 구하려면 filter를 사용하라.

> 컬렉션을 그 자리에서 변형하려면 map 함수를 사용하라.

> 컬렉션의 요소를 하나씩 다른 함수로 처리할 때는 reduce나 fold를 사용하라.

## chapter3. 양도하라
> 가비지 컬렉션 같은 저수준 세부사항의 조작을 런타임에 양도함으로써 찾아야 할 수많은 오류를 방지해주는 능력이야말로 함수형 사고의 가치라고 하겠다. 대다수의 개발자들은 메모리와 같은 기본 추상적 개념을 문제없이 무시하는 데 익숙하겠지만, 더 높은 단계에서 나타나는 추상화는 낯설어한다. 하지만 이런 고수준 추상 개념들도 기계장치의 지루한 일들을 처리해줌으로써 개발자가 자신의 문제에 고유한 측면을 연구할 시간을 제공한다는 측면에서 똑같은 역할을 수행한다.

> 함수형 언어를 사용하는 개발자가 언어나 런타임에 제어를 양도하는 다섯 가지 방식
1. 반복 처리에서 고계함수로
2. 클로저(closure)
3. 커링과 부분 적용
4. 재귀
5. 스트림과 작업 재정렬

>


1. 반복 처리에서 고계함수로
> 반복처리 대신에 map과 같은 함수를 사용하여 제어를 포기할 수 있다. ... 고계함수 내에서 어떤 연산을 할 것인지를 표현하기만 하면, 언어가 그것을 능률적으로 처리할 것이다. 게다가 modifier를 덧붙이기만 하면 분산처리까지 해준다.

> 개발자가 저수준 추상 단계에서 코드가 어떻게 동작하는지 이해하는 것까지 전부 떠넘겨도 된다는 것은 아니다. 많은 경우에 개발자는 Stream 같은 추상 개념을 사용할 때 거기에 함축된 의미를 반드시 알아야 한다. 일례로 많은 개발자들은 자바 8의 Stream API를 사용할 때조차. 그 안에서 작동하는 포크/조인 라이브러리의 세부사항을 이해해야 좋은 성능을 낼 수 있다. 하지만 일단 이해만 하면 간단하게 사용할 수 있다.

내가 아는 언어의 간단한 분산처리 라이브러리는 python의 multiprocessing인데 이것 또한 그 의미를 이해하지 못한 채 사용하고 있다. 좀 더 공부해보자.

2. 클로저
> 모든 함수형 언어는 클로저를 포함한다. ... 클로저(closure)란 그 내부에서 참조되는 모든 인수에 대한 묵시적 바인딩을 지닌 함수를 칭한다. 다시 말하면 이 함수(또는 메서드)는 자신이 참조하는 것들의 문맥(context)을 포함한다.

> 클로저(closure)란 단어의 어원이 문맥을 포괄함(enclosing context) ... 이 지역 인수는 함수 내부에서 정의되었지만, 코드 블록이 이 인수에 바인딩되어 있고, 따라서 코드 블록이 존재하는 동안에 이 인수 값은 유지되어야 한다.

> 구현 과점에서 보면, 클로저 인스턴스는 생성될 때 스코프 내에 있던 모든 것을 캡슐화하여 유지한다. 클로저 인스턴스가 가비지 컬렉션으로 사자리면 참조되었던 것들 모두가 같이 없어진다.

> 클로저 바인딩의 내부 원리를 설명하기 위해서 그 내부 상태를 외부에서 조작했지만, 단지 그러기 위해서 클로저를 만드는 것은 좋은 생각이 아니다. 상수와 같이 변하지 않는 값을 바인딩하는 것이 보편적이다.

> 클로저를 사용하지 않아도 비슷하게 구현이 가능하지만, 어떤 경우에나 개발자가 직접 내부 상태를 관리해야 한다. 왜 클로저의 사용이 함수적 사고를 예시하는지가 여기에서 분명해진다. 런타임에 내부 상태의 관리를 맡겨버리는 것이다. 직접 필드를 생성하고 그 상태를 관리하기보다는(멀티스레드 환경에서는 훨씬 더 끔직할 것이다) 언어나 프레임워크가 보이지 않게 그 상태를 관리할 수 있도록 놔두라.

> 클로저는 지연 실행(deferred execution)의 좋은 예이다. 클로저 블록에 코드를 바인딩함으로써 그 블록의 실행을 나중으로 연길할 수 있다. 예를 들어 클로저 블록을 정의할 때는 필요한 값이나 함수가 스코프에 없지만, 나중에 실행 시에는 있을 수가 있다. 실행 문맥을 클로저 내에 포장하면 적절한 때까지 기다렸다가 실행할 수 있게 된다.

> 명령형 언어는 상태로 프로그래밍 모델을 만든다. 그 좋은 예가 매개변수를 주고받는 것이다. 클로저는 코드와 문맥을 한 구조로 캡슐화해서 행위의 모델을 만들 수 있게 해준다. 이렇게 만들어진 클로저는 마치 전통적인 자료구조처럼 주고받을 수도 있고, 적잘한 시간과 장소에서 실행할 수도 있다.

3. 커링과 부분 적용
> 커링(currying)은 다인수(multiargument) 함수를 일인수(single-argument) 함수들의 체인으로 바꿔주는 방법이다. 이것은 그 변형 과정이지 변형된 함수를 실행하는 것을 지칭하는 것은 아니다. 함수의 호출자가 몇 개의 인수를 고정할지를 결정하며 적은 수의 인수를 가지는 함수를 유도해낸다.

> 부분 적용(partial application)은 주어진 다인수 함수를 생략될 인수의 값을 미리 정해서 더 적은 수의 인수를 받는 하나의 함수로 변형하는 방법이다. 이 방법은 이름이 의미하듯이 몇몇 인수에 값을 미리 적용하고 나머지 인수만 받는 함수를 리턴한다.

> 커링이나 부분 적용 모두 몇몇 인수의 값만 주면 인수가 몇 개 빠져도 호출할 수 있는 함수를 리턴해준다. 다만 커링은 체인의 다음 함수를 리턴하는 반면에, 부분 적용은 주어진 값을 인수에 바인딩시켜서 인수가 더 적은 하나의 함수를 만들어준다.

> process(x, y, z)의 완전히 커링된 버전은 process(x)(y)(z)이다. 여기에서 process(x)와 process(x)(y)는 인수가 하나인 함수이다. 첫 인수만 커링을 하면 process(x)의 리턴 값은 인수가 하나인 또 하나의 함수이다. 이 함수의 리턴 값은 또 하나의 일인수 함수인다. 반면에 부분 적용을 사용하여 변환하면 인수 숫자가 적음 함수가 남는다. process(x, y, z)의 인수 하나를 부분 적용하면 인수 두 개짜리의 process(y, z)가 된다. 이 두 가지 방법은 종종 같은 결과를 낳는다.

4. 재귀
> 많은 함수형 언어들은 리스트를 다른 각도에서 바라본다. ... 리스트를 색인된 위치의 컬렉션으로 여기는 대신에, 첫 요소(머리)와 나머지(꼬리)의 조합으로 생각할 수 있다.

> 누가 상태를 관리하는가? 란 중요한 질문을 조명한다. 명령형 버전에서는 개발자가 관리한다. 이름이 new_list인 새 인수를 생성하고, 계속 추가해야 한다. 끝나면 그것을 리턴해야 한다. 재귀 버전에서는 언어가 메서드 호출 시마다 리턴 값을 스택에서 쌓아가면서 관리한다. 개발자는 new_list에 대한 책임을 양도하고 언어 자체가 그것을 관리해준다.

* 꼬리 호출 최적화
> 스택 증가는 재귀가 좀 더 보편화되지 못하는 주된 이유 중 하나이다. 재귀는 보통 중간 값을 스택에 보관하게끔 구현되는데, 재귀에 최적화되지 않은 언어에서는 스택 오버플로를 유발하게 된다. 스칼라나 클로저 같은 언어들은 이 제약을 몇 가지 방법으로 우회한다. 개발자가 런타임이 이 문제를 처리하는 데 도움을 줄 수 있는 방법 중 하나는 꼬리 호출 최적화(tail call optimization)이다. 재귀 호출이 하뭇에서 마지막 단계이면, 런타임이 스택을 증가시키지 않고 스택에 놓여 있는 결과를 교체할 수 있다.

> 많은 함수형 언어는 스택 증가 없이 재귀를 구현한다. 장기 실행 얼랭 프로세스는 다른 프로세스로부터 메시지를 받아서 메시지에 들어 있는 내용대로 대신 일을 처리하는 애플리케이션의 마이크로서비스와 같은 역할을 한다. 이런 프로세스를 구현하는 데 꼬리 재귀 방식이 사용된다. 메시지를 받고 수행하는 꼬리 재귀 루프는 마이크로서비스의 상태를 내부적으로 관리할 수 있게 해준다. 불변 내부 상태에 대한 어떠한 영향도 새로운 상태 변소를 다음 재귀 단계로 넘겨줌으로써 반영되기 때문이다. 얼랜의 뛰어난 결함내구성 덕분에, 수년간 계속 돌고 있는 꼬리 재귀 루프도 어딘가 존재할지 모른다.

5. 스트림과 작업 재정렬
> 명령형 사고로는 당연히 필터 작업이 맵 작업보다 먼저 와야 한다. 그래야 맵 작업의 양이 줄어든다. 하지만 함수형 언어(자바8이나 함수형 자바 프레임워크를 포함)에는 Stream이란 추상 개념이 정의되어 있다. Stream은 여러모로 컬렉션과 흡사하지만 바탕 값(backing value)이 없다. 대신 원천에서 목적지까지 값들이 흐르게끔 한다.

> map()과 filter()는 게으른 함수이다. 다시 말하자면 이들은 실행을 가능하면 미룬다. 이들은 목적지에서 요구하지 않으면 결과를 내려고 시도하지도 않는다.

> 영리한 런타임은 게으른 작업들을 재정렬할 수 있다.

## chapter4. 열심히보다는 현명하게

* 함수형 언어에서 보편적인 두 가지 기능
    * 메모이제이션
    * 게으름

1. 메모이제이션
> 연속해서 사용되는 연산 값을 함수 레벨에서 캐시하는 것을 지칭

> 캐싱 코드를 작성하는 개발자는 정확함과 함께 실행 조건도 신경써야 한다. 이것이 움직이는 부분의 적잘한 예이다. 코드 내의 상태와 그 의미를 개발자가 항상 관리해야만 한다. 수많은 언어가 이미 메모이제이션과 같은 메커니즘을 사용하여 이러한 제약을 극복해냈다.

2. 게으름
> 게으른 컬렉션은 그 요소들을 한꺼번에 미리 연산하는 것이 아니라, 필요에 따라 하나씩 전달해준다. 이렇게하면 몇 가지 이점이 있다. 우선 시간이 많이 걸리는 연산을 반드시 필요할 때까지 미룰 수 있게 된다. 둘째로, 요청이 계속되는 한 요소를 계속 절달하는 무한 컬렉션을 만들 수 있다. 셋째로, 맵이나 필터 같은 함수형 개념을 게으르게 사용하면 효율이 높은 코드를 만들 수 있다.

* 게으름의 이점
> 첫째, 무한수열을 만들 수 있다.

> 둘째, 저장 시 크기가 줄어든다. 컬렉션 전부를 유지하지 않고 순차적으로 다음 값을 유도할 수 있으니 저장소와 실행 속도를 맞바꿀 수 있다. 게으른 목록을 사용하고 말고의 결정은 값을 젖아하는 것과 새 값을 계산하는 것 사잉의 트레이드오프이다.

> 셋째, 런타임이 좀 더 효율적인 코드를 만들 수 있다.

## chapter5. 진화하라
> 100개의 함수를 하나의 자료구좋에 적용하는 것이 10개의 함수를 10개의 자료구조에 적용하는 것보다 나삳. - 앤런 펄리스

> 대부분의 개발자들은 복잡한 비즈니스 문제를 자바와 같은 언어로 번역하는 것ㅇ이 그들의 할 일이라는 착각 속에서 일을 한다. 자바가 언어로서 유연하지 못하기 때문에, 아이디어를 기존의 고정된 구조에 맞게 주물러야 하기 때문이다. 그런 개발자가 유연한 언어를 접하면 문제을 언어에 맞게 구부리는(바꾸는) 대신 언어를 문제에 어울리게 구부릴 수 있다는 것을 깨닫게 된다.

> 가단성(malleability)은 금속 가공에서 나온 개념으로, 고체가 외부에서 작용하는 힘에 의해 외형이 변하는 성질을 의미한다. 가단성이 큰 물질은 외부의 힘에 의해 부러지지 않는다. 예를 들어 구리는 철보다 가단성이 높다. 소프트웨어에서는 언어나 프레임워크가 사용하는 코드에 의해 용도나 반응이 변하는 성질을 의미한다. 가단성이 큰 언어나 프레임워크는 상황에 따라 다양하게 사용될 수 있다.

> 디스패치란 넓은 의미로 언어가 작동 방식을 동적으로 선택하는 것을 말한다.

디스패치가 뭔지 전혀 모르겠다. ㅠ_ㅠ

> 대부분의 함수형 언어들은 예외 패러다임을 지원하지 않기 때문에 개발자는 다른 방법으로 오류 조건을 표현해야 한다.

> 예외는 많은 함수형 언어가 준수하는 전제 몇 가지를 깨뜨린다. 첫째, 함수형 언어는 부수효과가 없는 순수함수를 선호한다. 그런데 예외를 발생시키는 것은 예외적인 프로그램 흐름을 야기하는 부수효과다. 함수형 언어들은 주로 값을 처리하기 때문에 프로그램의 흐름을 막기보다는 오류를 나타내는 리턴 값에 반응하는 것을 선호한다.

> 함수형 프로그램이 선호하는 또 하나의 특성은 참조 투명성이다. 호출하는 입장에서는 단순한 값 하나를 사용하든, 하나의 값을 리턴하는 함수를 사용하든 다른 바가 없어야 한다. 만약 호출된 함수에서 예외가 발생할 수 있다면, 호출하는 입장에서는 안전하게 값을 함수로 대체할 수 없을 것이다.

> 자바에서 예외를 사용하지 않고 오류를 처리하기 위해 해결해야 할 근본적인 문제는 메서드가 하나의 값만 리턴할 수 있다는 제약이다. ... 물론 Map을 사용하여 다수의 리턴 값을 지원하게 할 수 있다. ... 이 접근 방법에는 문제점이 있다. 첫째, Map에 들어가는 값은 타입 세이프하지 않기 때문에 컴파일러가 오류를 잡아낼 수 없다. 열거형을 키로 사용하면 조금 좋아지기는 하겠지만, 근본적인 해결책은 아니다. 둘째, 메서드 호출자는 리턴 값을 가능한 결과들과 비교해보기 전에는 성패를 알 수 없다. 셋째, 두 가지 결과가 모두 리턴 Map에 존재할 수가 있으므로, 그 경우에는 결과가 모호해진다.

> 필요한 것은 타입 세이프하게 둘 또는 더 많은 값을 리턴할 수 있게 해주는 메커니즘이다. ex: Either

## chpater6. 전진하라
> 함수형 언어계의 어떤 이들은 디자인 패턴이 개념 자체에 결함이 있개 때문에 함수형 프로그래밍에서는 필요가 없다고 주장한다. 패턴의 좁은 정의만 볼 때에는 일리가 있는 말이다. 하지만 그런 주장은 패턴의 사용보다는 의미론에 국한된 것이다. 디자인 패턴(흔한 문제들을 푸는 방법으로서 분류되고 이름이 붙은 해법들)의 개념은 아직도 건재하다. 하지만 다른 패러다임에서 패턴들은 다른 형태로 나타난다. 함수형에서는 빌딩블록과 문제의 접근 방법이 다르기 때문에, 전통작인 GoF 패턴들 중의 일부는 사라지고, 나머지는 근본적으로 다른 방법으로 같은 문제를 풀게 된다.

> 함수형 프로그래밍에서는 전통적인 디자인 패턴들이 다음과 같은 세 가지로 나타난다.

1. 패턴이 언어에 흡수된다.
2. 패턴 해법이 함수형 패러다임에도 존재하지만, 구체적인 구현 방식은 다르다.
3. 해법이 다른 언어나 패러다음에 없는 기능으로 구현된다.

## chapter7. 실용적 사고
> 함수형 아키텍처는 불변성이 그 중심에 있고, 이를 최대한 사용하려 시도한다. 함수형 프로그래머처럼 사고하려면 불변성을 받아들이는 것이 중요하다. 자바에서 불변형 객체를 만들려면 좀 복잡한 선행 작업이 필요하지만, 추상화로 얻게 되는 이점들이 이를 충분히 보상해준다.

> 불변 클래스는 자바에서 주로 적정해야 하는 것들을 많이 없애준다. 함수형 사고로의 전환의 이점은 코드에서 생기는 변화가 제대로 이루어졌는지 확인할 테스트가 있다는 사실을 인지하게 되는 것이다. 다시 말해 테스트의 진정한 목적은 변이(mutation)를 확인하는 것이고, 변이가 많을수록 테스트가 많이 필요하게 된다.

> 자바 클래스를 불변형으로 만들려면 반드시 다음과 같이 해야한다.

> * 모든 필드를 final로 선언한다.

> 자바에서 final로 선언된 필드들은 선언 시나 생성자 내부에서 초기화해야 한다. IDE가 선언시에 초기화하지 않았다고 불평해도 걱정하지 말라. 나중에 생성자 안에 필요한 코드를 넣으면 된다.

> * 클래스를 final로 선언해서 오버라이드를 방지하라

> 클래스가 오버라이드되면 그 메서드들도 오버라이드 될 수 있다. 가장 안전한 방법은 하위 클래스를 금지하는 것이다. 자바의 String 클래스가 이 방법을 사용한다.

> * 인수가 없는 생성자를 제공하지 말라.

> 불변형 객체의 모든 상태는 생성자가 정해야 한다. 상태가 없다면 객5체가 필요하긴 할까? 상태가 없는 클래스의 정적 메서드로 충분할 때도 있다. 따라서 불변 클래스에는 인수가 없는 생성자가 있어서는 안 된다. 어떤 이유로 프레임워크가 인수 없는 생성자를 요구한다면, 인수가 없는 (리플렉션이 가능한) 비공개 생성자를 제공해도 되는지를 알아보라.

> * 적어도 하나의 생성자를 제공하라.

> 인수가 없는 생성자가 없으므로 객체에 상태를 더할 수 있는 마지막 기회를 제공해야 한다.

> * 생성자 외에는 변이 메서드를 제공하지 말라.

> 자바빈스식 setxxx 메서드를 제공하지 않아야 하는 것은 물론이고, 가변 객체의 참조를 리턴하지 않게 조심해야 한다. 객체 참고자 final이라고 해서 그 참조가 지정하는 것이 변이되지 말라는 보장은 없다. 따라서 getxxx 메서드가 리턴할 때는 반드시 객체 참조의 복제본을 리턴해야 한다.

### CQRS

> CQRS는 그레그 영이 개념을 도입했고, 마틴 파울러가 영향력 있게 그 개념을 기술했다. 여기에는 함수형 측면이 포함된다.

> 전통적인 애플리케니션 아키텍처는 ... 개발자가 읽기와 쓰기의 혼합된 의미를 모델 전역에서 관리해야 한다. 이것이 시스템을 복잡하게 한다.

> CQRS는 읽기와 명령 부분을 분리함으로써 하키텍처의 일부를 단순화한다.

> 최종 일관성(eventual consistency) 분산 컴퓨팅 모델은 모델을 업데이트하는 데 정해진 시간 제한을 요구하지 않는다. 대신 새로운 업데이트가 없는 한, 최종적으로는 모델이 일관성을 갖추기만 하면 된다.

> 트랜젝션 모델이 ACID(원자성(atomic), 일관성(consistent), 고립성(isolated), 지속성(durable))에 의존하는 반면, 최종 일관성 모델은 BASE(기본 가용성(basically available), 부드러운 상태(soft state), 최종 일관성(eventual consistency))를 중요하게 여긴다.

> 아키텍처는 항상 트레이드 오프를 염두에 두어야 한다. CQRS로 인해 한 부분은 쉬워지지만 다른 부분은 복잡해진다. 예를 들어 한 덩어리인 데이터베이스를 사용하면 트랜젝션이 쉽다. CQRS를 사용하면 트랜젝션형보다는 최종 일관성 모델로 전환해야 할 것이다.

> 트랜젝션 모델을 포기하는 경우는 주로 애플리케이션을 확장해야 하기 때문이다. CQRS는 모든 애플리게킹션의 상태 변화를 이벤트 스트림으로 보존해야 하는 이벤트 소싱(event sourcing)과 같은 아키텍처 패턴에 아주 적합하다. 읽기를 변이로부터 분리하면 논리적으로 단순해진다. 일기 쪽에서는 모든 것을 붏변형으로 처리할 수 있다.

### 웹 프레임워크

### 데이터베이스

## chapter8. 폴리글랏과 폴리패러다임

> 직교는 수학과 컴퓨터 과학을 포함한 여러 과목에 걸쳐서 정의된다. 수학에서는 직각으로 교차하는 두 벡터가 서로 직교한다고 말한다. 컴퓨터 과학에서는 직교하는 컴포넌트들은 서로 영향을 주지 않는다는 뜻이다. 예들 들어 함수형 프로그래밍과 메타프로그래밍은 그루비에서 서로 간섭하지 않기 때문에 직교한다고 할 수 있다. 메타프로그래밍을 사용해도 함수형 구조물에 아무런 영향이 없고, 반대의 경우도 마찬가지이다. 서로 직교한다고 공존할 수 없다는 것은 아니다. 단지 서로 간섭하지 않는다는 것 뿐이다.

> 정적 타이핑은 변수나 함수의 자료형을 사용 전에 확정해야 함을 의미하고, 동적 아티핑은 이것을 미룰 수 있게 함을 의미한다. 강한 타입 변수는 자신의 타입을 알고 있기 때문에 리플렉션이나 인스턴스 검사가 가능하며, 이런 성질이 유지된다. 약한 타이핑 언어는 이런 의식이 덜하다. 예들들어 C는 정적 약한 타이핑 언어이다. C의 변수는 여러 방법으로 해석이 가능한 비트의 컬렉션에 불과하다. 이것이 C 개발자들에게는 즐거움이자 공포의 원인이다(때로는 이 두 가지를 동시에 느낄 수도 있다).

>나는 모두가 원하는 신뢰성이 정적 타이핑에서 오는 것이 아니라 함수형 개념을 바닥 계층에서 받아들임에서 비록쇧다고 믿는다. 중요한 일(데이터 겁근, 통합)을 하는 주용 API들이 불변성을 전제로 하면 그 모든 코드가 아주 간단해진다. 몰론 데베이스나 다른 인프라스트럭처를 만드는 방법이 바뀌어야 한다. 하지만 최종 결과는 중심부의 안정도가 보장되는 것이다.

> 함수형 중심 위에 명령형 언어를 사용하여 워크플로, 비즈니스 규칙, 사용자 인터페이스와 같이 개발자 생삱성이 최우선인 부분들을 만든다. 원래 피라미드와 같이, DSL이 가장 꼭대기에 같으 목적으로 놓인다. 하지만 나는 DSL이 모든 계층을 꿰뚫는다고 믿는다. 이는 스칼라(함수형, 정적 강한 타이핑)나 클로저(함수형, 동적 강한 타이핑)를 사용하여 주요 개념을 간결하게 포착하여 DSL을 쉽게 만들 수 있다는 것으로 예증된다.
