# 2. 함수형 기능 소개

> 우리는 다음과 같은 함수형 프로그래밍 주제를 다룰 것이다.

* 일급 계층 함수와 고차 함수는 순수 함수라고도 알려져 있다.
* 변경 불가능한 데이터
* 엄격한 평가(strict evaluation)와 엄격하지 않은 평가를 각각 미리(eager) 계산과 지연(lazy) 계산이라 부르기도 한다.
* 명시적인 루프 상태를 대신하는 재귀
* 함수형 타입 시스템

## 일급 계층 함수
> 함수형 프로그래밍은 간결하고 표현력이 높은 경우가 많다. 이를 달성하는 방법은 함수를 인자로 제공하고, 다른 함수가 사용할 수 있도록 함수를 반환하는 것이다.

> 이러한 사용이 가능하려면 함수가 실행 시점의 환경에서 일급 계층이어야만 한다. C와 같은 프로그래밍 언어에서는 함수가 실행 시점의 객체가 아니다. 하지만 파이썬에서 함수는 (보통) def문에 의해 생성되는 객체이며, 다른 파이썬 함수에서 이를 조작할 수 있다. 또한 함수를 호출 가능(callable) 객체로 정의하거나 lambda를 변수에 대입하여 만들 수 있다.

```py
def example(a, b, **kw):
    return a * b

type(example)
# <class 'function'>

example.__code__.co_varnames
# ('a', 'b', 'kw')

example.__code__.co_argcount
# 2
```

> 우리는 function() 클래스에 속하는 example이라는 객체를 만들었다. ... `__code__` 객체는 함수 객체 자신을 애트리뷰트와 연관시켜준다.

> 즉, 함수는 일급 계층 객체이고, 다른 일반적인 객체와 마찬가지로 조작이 가능하다.

## 순수 함수
> 함수형 프로그래밍 설계에서 사용하는 함수는 부수 효과로 인해 발생할 수 있는 혼동이 없어야 한다. 순수 함수를 사용하면 평가 순서를 바꿔 최적화할 수 있는 여지가 생긴다. 하지만 가장 큰 이익은 순수 함수가 개념적으로 훨씬 단순하며, 테스트하기 쉽다는 점으로부터 얻을 수 있다.

> 순수 함수를 파이썬으로 작성하려면 지역 상태만을 사용하는 코드를 작성해야 한다. 이는 global문을 피해야 한다는 것을 의미한다. nonlocal을 사용하는 부분은 주의깊게 살펴봐야 한다. nonlocal은 다른 영역에서는 부수 효과처럼 보이자만, 내포시킨 함수 정의 안으로 제한되는 상태이기 때문이다.

난 아직 global과 nonlocal의 사용법을 잘 모른다. 찾아서 공부하자.

> 우리가 정말 순수 함수 규칙을 따르고 있는지를 자신할 수 없는 상황이라면, dis 모듈을 사용해 주어진 함수를 컴파일한 코드인 `__code__.co_code` 부분에 전역 참조가 있는지 살펴보아야 한다. dis 모듈은 내부 클로저(closure)의 사용을 보고할 수 있다. 튜플을 반환하는 `__code__.co_freevars` 메서드도 이와 마찬가지다.

dis 모듈이 어떻게 생겨먹었는지 1도 모르겠다. 이것도 찾아보자.

> 파이썬 lambda는 순수 함수다. 람다를 사용해 함수를 정의하는 것을 권장하지 않지만, lambda값을 사용해 순수 함수를 만드는 것은 가능하다.

## 고차 함수
> 함수를 인자로 제공하면 max()가 작동하는 방식을 바꿀 수 있다.

> max()함수에 튜플로 구성된 시퀀스를 인자로 전달할 경우, 기본 동작은 시퀀스에 있는 각 튜플을 비교하는 것이다. 그 결과 튜플의 0번째 위치에 가장 큰 값이 있는 것을 반환한다.

> max() 함수가 고차 함수이기 때문에 그 함수의 인자로 다른 함수를 넘길 수 있다.

```py
max(year_cheese, key=lambda yc: yc[1])
```

key라는 named argument로 function을 전달할 수 있다는 의미인가?

> max() 함수는 인자로 받은 lambda를 사용하여 튜플의 1번째 위치에 가장 큰 값이 있는 것을 반환한다.

## 변경 불가능한 데이터
> 함수형 프로그래밍에서는 단지 상태가 있는 객체가 필요하지 않아서 객체를 사용하지 않을 뿐이다.

> 튜플의 리스트는 매우 자주 쓰이는 데이터 구조다. 튜플의 리스트를 처리할 때는 보통 다음 두 가지 방법 중 하나를 선택한다.
> 1. 고차 함수 사용: lambda를 max()의 인자로 넘겨 max(year_cheese, key=lambda yc: yc[1]) 처럼 사용했다.
> 2. 감싸고-처리하고-풀기 패턴 사용: 함수적인 맥락에서 볼 때 이를 풀기(처리하기(감싸기(구조))) 패턴이라 불러야 할 것이다.

```py
max(map(lambda yc: (yc[1], yc), year_cheese))
_[1]
```

튜플로 구성된 리스트인 year_cheese의 요소를 하나씩 lambda 함수에 적용하여 새로운 시퀀스 객체를 생성하고 이것을 max() 함수에 전달했다.

_(underscore)는 REPL에서 바로 앞의 값을 받는다.

> 첫째, 우리는 map(lambda yc: (yc[1], yc), year_cheese)를 사용해 리스트를 감싼다. 이 호출은 각 원소를 키와 원래의 원소가 들어있는 2-튜플로 변환한다.

2-튜플의 정확한 뜻은 무엇일까? -> 책을 읽다보니 element가 2개인 튜플을 2-튜플이라고 부른다는 걸 알게됐다.

> 둘째, max() 함수를 사용해 변환한 리스트를 처리했다. 데이터의 각 부분을 비교에 사용할 값이 0번째 위치에 들어간 튜플로 만들었기 때문에 실제로 max() 함수의 고차 함수 기능을 활용할 필요는 없다.

> 셋째, [1]이라는 첨자르 사용해 튜플을 풀었다. 이 첨자 연산은 max() 함수가 선택한 2-튜플의 두 번째 원소를 가져온다.

> 이처럼 감싸고 푸는 작업은 매우 흔한 일이며, 일부 언어에서는 [0]이나 [1]과 같은 접두사식 첨자를 사용하지 않고, fst()나 snd()와 같이 함수 표현을 사용할 수 있도록 지원하기도 한다.

```py
snd = lambda x: x[1]
snd( max( map(lambda x: (yc[1], yc), year_cheese)))
```

fst, snd 같은 설탕도 잘 알아두자.

## 엄격한 평가와 엄격하지 않은 평가
> 함수형 프로그래밍은 부분적으로 어떤 계산을 그 결과가 정말 필요할 때까지 유예하는 방식을 활용하는 것으로 인해 효율성을 얻는다.

> 파이썬에서 논리 연산자인 and, or나 if-then-else는 모두 엄격하지 않다. 이러한 연산자를 때로는 지름길(short circuit) 연산자라 부른다. 왜냐하면 결과값을 계산하기 위해 항상 모든 인자를 평가하지는 않기 때문이다.

```py
0 and print('right')
# 0
True and print('right')
# right
```

> 좌항이 True인 경우에만 우항을 계산한다.

> 파이썬의 다른 부분은 엄격하다. 논리 연산자를 제외하면 모든 식은 순서대로 왼쪽에서 오늘쪽으로 계산된다. 문장의 시퀀스 또한 순서대로 처리된다. 리터럴 리스트나 튜플에도 엄격한 계산이 이뤄진다.

> 메서드 함수는 클래스를 정의할 때 엄격하게 순서대로 정의된다. 클래스 정의의 경우 메서드 함수들은 (기본적으로) 딕셔너리에 수집되며, 생성된 다음에는 순서를 유지하지 않는다. 이름이 같은 메서드를 두 가지 정의하면, 엄격한 정의 순서에 따라 두 번째 메서드만 살아남는다.

## 명시적 루프 상태 대신 재귀 사용
> 함수형 프로그램은 루프에 의존하지 않으며, 루프의 상태를 추적하는 데 따른 부가 비용도 없다. 그 대신, 함수형 프로그램은 좀 더 간단한 접근 방식인 재귀함수를 사용한다. 일부 언어에서는 재귀를 사용해 프로그램을 작성하더라도 컴파일러가 제공하는 꼬리재취호출 최적화(Tail Call Optimization, TCO)가 재귀를 루프로 변경해준다.

> 서로소(coprime)라는 용어는 두 수의 공약수가 1뿐인 경우를 말한다. 어떤 수 n이 소수인지 판별하려면 n이 p^2 < n인 모든 소수 p에 대해 서로소인가? 이를 단순화하려 2 <= p^2 < n인 모든 정수 p에 대해 서로소인지를 검사하는 것으로 변경할 수 있다.

```py
not any(n%p==0 for p in range(2, int(math.sqrt(n))+1))
```

not any의 분명한 의미를 찾아보자.

all도 잘 모르겠다. 꼭 찾아보자.

> 수학 공식을 파이썬으로 직접 변환하면 all(n%p != 0 ...)과 같은 코드를 사용할 수 있다. 하지만 이는 p의 모든 값을 엄격하게 계산해야 한다는 단점이 있다. not any를 사용한 버전은 True 값을 발견한 경우에 계산을 빨리 마칠 수 있다.

> 이 간단한 식의 내부에는 for 루프가 들어 있다. 따라서 이는 상태가 없는 함수형 프로그램의 예가 아니다. 이를 값의 컬렉션에 대해 동작하는 함수로 재작성 할 수 있다. 우리는 어떤 수 n이 [2, 1+루트n)이라는 범위 안에 있는 모든 수에 대해 coprime인지 물어볼 수 있다. 여기서 [...)라는 기호는 반만 열린 구간(half-open interval)을 의미한다. 즉, 최솟값은 포함하되 최댓값은 포함하지 않는 구간이다. 이는 파이썬의 range() 함수의 전형적인 동작과 일치한다.

```py
def isprimer(n):
    def isprime(k, coprime):
        if k < coprime*coprime:
            return True
        if k % coprime == 0:
            return False
        return isprime(k, coprime+2)
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    return isprime(n, 3)
```

> 재귀가 함수의 맨 끝에 위치하기 때문에 이 함수는 꼬리재귀함수다. 끝이라고 말한 것은 물리적인 위치가 아니라 논리적인 실행 순서에서 맨 마지막이라는 뜻이다. 꼬리재귀호출 판정에 있어서 대상 재귀호출의 위치는 중요하지 않다. 다만, 재귀호출에서 반환 받은 값을 바로 return해야 한다는 점이 중요하다.

> 다음 정의는 비록 재귀호출이 맨 마지막에 위치하지만, 꼬리재귀가 아니다.

```py
def factorial(n):
    if n == 1 or n == 2:
        return n
    return n * factorial(n-1)
```

> * 파이썬에서는 기본적인 경우를 잘못 정의한 재귀함수를 감지하기 위해 재귀 깊이에 한계가 정해져 있다.
> * 파이썬에는 꼬리재귀 최적화를 수행하는 컴파일러가 존재하지 않는다.

> 재귀 깊이의 한계는 기본적으로 1,000이다. 대부분의 알고리즘에서는 이 정도면 충분하다. 이를 sys.setrecursionlimit() 함수를 통해 바꿀 수 있다.

> 일부 함수형 프로그래밍 언어는 우리가 만든 isprime()와 같은 단순한 재귀함수를 최적화할 수 있다. 최적화 컴파일러는 재귀호출을 부가 비용이 적게 드는 루프로 최적화해준다. 이러한 최적화를 수행하면 여러 재귀호출 스택이 뭉개지기 때무에 최적화한 프로그램을 디버깅하기 힘들어진다 파이썬은 이러한 최적화를 수행하지 않는다. 단순함과 명확성을 위해 성능과 메모리를 희생시킨다.

> 파이썬에서 재귀함수 대신 제네레이터 식을 사용하는 경우, 근본적으로 꼬리재귀 최적화를 직접 해주는 것과 같다. 우리는 일부 함수형 프로그래밍 언어와 달리 이러한 최적화를 컴파일러에 의존하지 않는다.

## 함수형 타입 시스템
> 하스켈이나 스칼라와 같은 일부 함수형 프로그래밍 언어는 정적으로 컴파일되고, 함수나 함수 인자에 대해 선언된 타입에 의존한다. 파이썬이 이미 제공하고 있는 유연성을 제공하기 위해 이러한 언어에서는 여러 다양한 관련 타입에도 작동할 수 있는 제네릭(generic) 함수를 작성할 수 있도록 하기 위한 복잡한 타입 부합 규칙(type matching rule)을 사용한다.

> 객체지향 파이썬에서는 복잡한 함수 타입의 규칙을 사용하기보다 클래스 상속 계층 구조를 사용한다. 파이썬은 간단한 이름 부합 규칙을 사용해 연산자를 적절한 메서드로 디스패치(dispatch)해준다.

> 파이썬은 이미 우리가 원하는 유연성을 제공하기 있기 때문에 컴파일 언어에 필요한 타입 부합 규칙은 중요하지 않다. 실제로 우리는 복잡한 타입의 부합규칙은 정적인 컴파일을 사용함에 따라 발생하는 경직성을 피하기 위한 우회로 라고 주장할 수 있다. 파이썬은 동적 언어이기 때문에 이러한 식으로 돌아갈 필요가 없다.

## 낯익은 영역
> 어떤 클래스의 메서드가 모두 self()를 반환하게 만든다면, 다음과 같이 그 클래스를 활용할 수 있다.

```py
some_object.foo().bar().yet_more()
```

```py
yet_more(bar(foo(some_object)))
```

> 단지 구문을 전형적인 객체지향 후위 연산자 형태에서 더 함수형인 전위 연산자 형태로 바꿨을 뿐이다. 파이썬은 두 호출 방식을 자유롭게 활용할 수 있으며, 때로는 특별한 메서드 이름의 전위 연산자 버전을 제공하기도 한다. 예를 들어, len() 함수는 보통 `class.__len__()` 특수 메서드를 사용해 구현된다.