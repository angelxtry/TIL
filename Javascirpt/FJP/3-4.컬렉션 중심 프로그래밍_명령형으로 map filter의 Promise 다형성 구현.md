# 3. 컬렉션 중심 프로그래밍

## 3-4 명령형으로 map, filter의 Promise 다형성 구현, Promise의 규칙

- 원래 목표는 map을 reduce로 만드는 것
- 일단 map을 명령형으로 만들어보자.
- 자료구조는 일단 배열만 생각한다.

```js
function map(f, coll) {
  let res = [];
  for (const v of coll)
    res.push(f(v));
  return res;
}

console.log( map(a => a + 10, [1, 2, 3]) );
```

- 이것이 가장 간단한 map이다.

- 다음으로 해결할 것은 입력받는 데이터가 Promise.

```js
console.log( map(a => a + 10, Promise.resolve([1, 2, 3])) );
```

- Promise와 연관이 있는 부분을 함수로 변경한다.

```js
function map(f, coll) {
  let res = [];
  return then2(function () {

  });
}
```

- 그리고 Promise로 전달되는 데이터를 풀어야 하므로 then2에 coll를 전달한다.

```js
function map(f, coll) {
  let res = [];
  return then2(function (coll) {

  }, coll);
}
```

- 마지막으로 map의 기본 로직을 추가한다.

```js
function map(f, coll) {
  let res = [];
  return then2(function (coll) {
    for (const v of coll)
      res.push(f(v));
    return res;
  }, coll);
}
```

- 다시 처음의 map으로 돌아가서 다음의 코드를 실행할 수 있는 map을 만들어보자.

```js
function map(f, coll) {
  const res = [];
  for (const v of coll)
    res.push(f(v));
  return res;
}
console.log( map(a => Promise.resolve(a + 10), [1, 2, 3]) );
// [Promise, Promise, Promise]
```

- 결과는 Promise의 배열이다.

```js
function map(f, coll) {
  const res = [];
  const iter = coll[Symbol.iterator]();
  return function recur() {
    for (const v of iter) {
      const a = f(v);
      if (a instanceof Promise) {
        return a.then(function(a) {
          res.push(a);
          return recur();
        });
      } else {
        res.push(a);
      }
    }
    return res;
  } ();
}
```

- res는 결과로 만들 빈 배열이다.
- coll은 자유변수로 만들기 위해 iter로 만든다.
- 그리고 함수를 즉시 실행한다.
- 함수에서 for...of로 첫 번째 요소를 꺼낸다.
- 첫 번째 요소가 Promise가 아니라면 res에 push
- 만약 Promise라면 then으로 풀어서 res에 push 하고 recur()를 호출하면서 return한다.
- if (a instanceof Promise) 때문에 then2를 쓰지 않아도 된다.(이건 이해가 잘 안된다.)

```js
function filter(f, coll) {
  const res = [];
  const iter = coll[Symbol.iterator]();
  for (const v of iter) {
    const a = f(v);
    if (a) res.push(v);
  }
  return res;
}

console.log( filter(a => a < 10, [1, 2, 30]) );
```

- 가장 간단한 filter다.