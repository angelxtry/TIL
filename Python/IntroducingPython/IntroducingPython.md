# Introducing Python

## ● 파이썬의 특징

파이썬은 **동적 언어**다.

정적 언어에서 변수는 자신의 타입을 변경할 수 없기 때문에 정적이다.

동적 언어는 변수 타입을 선언하도록 강요하지 않는다.

파이썬에서는 모든 것(부울, 정수, 실수, 문자열, 데이터 구조, 함수, 프로그램)이 객체로 구현되어 있다.

타입은 객체에 포함된 데이터 값을 변경할 수 있는 변수(mutable)인지 혹은 변경할 수 없는 상수(immutable)인지 판단할 수 있다.

가변 객체는 열려 있는 상자와 같다. 값을 볼 수 있을 뿐만 아니라 바꿀 수도 있다. 하지만 타입은 변경 할 수 없다.

파이썬은 객체의 타입을 바꿀 수 없는 **강타입**이다.

----

## ● 나누기 연산

`/`는 부동소수점을 포함한 결과가 출력된다. 
* 정수를 정수로 나누더라도 `/`로 나누면 부동소수점 결과가 나온다.

`//`는 부동소수점을 제외한 결과, 즉 정수가 출력된다.

0으로 나우면 `ZeroDivisionError` 예외가 발생한다.

`divmod(9, 5) => (1, 4)`

* 소수점을 제외한 몫과 나머지를 동시에 얻을 수 있다.

----

## ● 2진수, 8진수, 16진수

파이썬에서는 10진수 외에도 세 가지 리터럴 정수를 표현할 수 있다.

1. 2진수 0b or 0B

2. 8진수 0o or 0O

3. 16진수 0x or 0X

* 16진수는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f 로 센다.

----

## ● int의 크기

파이썬 2에서 int의 크기는 32bit, long은 64bit

파이썬 3에서는 long이 사라지고, int가 64bit 보다 더 큰 공간을 가질 수 있다.

(`googol = 10**100`, `googol*googol` 모두 가능하다.)

----

## ● 문자열

다른 언어와 달리 파이썬에서는 문자열이 `immutable`이다.

`+` 연산자를 사용하여 리터럴 문자열 또는 문자열 변수를 결합할 수 있다.

`*` 연산자를 이용하여 문자열을 복제할 수 있다.

---

### 1. 오프셋

문자열에서 한 문자를 얻기 위해서는 문자열 이름 뒤에 대괄호([])와 오프셋을 지정한다.

가장 왼쪽의 오프셋은 0, 가장 오른쪽의 오프셋은 -1

-1 다음의 오프셋은 -2, -3, ...

문자열은 불변하기 때문에 특정 인덱스에 문자를 삽입하거나 변경할 수 없다.

### 2. 슬라이스 slice
`[:]` 처음부터 끝까지 전체 시퀀스를 추출한다.

`[start:]` start 오프셋부터 끝까지 시퀀스를 추출한다.

`[:end]` 처음부터 end-1 오프셋까지 시퀀스를 추출한다.

`[start:end]` start 오프셋부터 end-1 오프셋까지 시퀀스를 추출한다.

`[start:end:step]` step만큼 문자를 건너뛰면서, start 오프셋부터 end-1 오프셋까지 시퀀스를 추출한다.

파이썬은 마지막 오프셋은 포함하지 않는다.

### 3. 문자열 관련 함수

`split()`

`문자열.split(구분자)`

* 구분자를 기준으로 하나의 문자열을 작은 문자열의 리스트로 나눈다.

* 구분자를 지정하지 않으면 문자열에 등장하는 공백 문자(줄바꿈, 스페이스, 탭)를 사용한다.

`join()`

* 문자열 리스트를 하나의 문자열로 결합한다.

* 문자열 리스트를 각각 줄바꿈하여 하나의 문자열로 결합하기 위해서는 `'\n'.join(문자열 리스트)`

`len()` : 스페이스와 줄바꿈을 포함한 문자열의 길이

`문자열.startswith(단어)`

`문자열.endswith(단어)`

`문자열.find(단어)`

* 문자열에서 단어가 첫 번째로 나오는 오프셋

----

## ● 리스트

`list()` : 다른 데이터 타입을 리스트로 변환한다.

* `list('cat') => ['c', 'a', 't']`

slice를 이용하여 리스트를 반전시킬 수 있다.

* `리스트명[::-1]`

`append()` : 리스트의 끝에 항목을 추가한다.

`insert()` : 리스트의 원하는 위치에 항목을 추가한다.

* `리스트명.insert(오프셋, ITEM)`

* 리스트의 끝을 넘는 오프셋은 append()와 동일하다(예외가 발생하지 않는다).

`del` : 오프셋으로 항목 삭제

* `del`은 객체로부터 이름을 분리하고, (이 이름이 객체의 마지막 참조일 경우) 객체의 메모리를 비워준다.

`remove()` : 값으로 항목 삭제

`pop()` : 오프셋으로 항목을 얻은 후 삭제

`index()` : 값으로 항목 오프셋 찾기

`sort()` : 리스트 자체를 내부적으로 정렬

`sorted()` : 리스트의 정렬된 복사본을 반환

* 리스트의 항목이 숫자인 경우 기본적으로 오름차순으로 정렬

* 문자열인 경우 알파벳순으로 정렬

* 내림차순으로 정렬하고 싶다면 `LIST_NAME.sort(reverse=True)`

참조 vs 복사
* 리스트를 `=`로 대입할 경우 참조가 발생한다.

* 리스트를 새로운 리스트에 복사하려면 다음과 같이 처리한다.
 1. copy() 함수 `b = a.copy()`
 2. list() 변환 함수 `b = list(a)`
 3. 슬라이스 [:] `b = a[:]`

## ● 튜플

튜플은 immutable 하다.

요소가 한 개인 튜플을 만들려면 콤마`(,)`를 붙인다.
 
* `TUPLE_NAME = 'ELEMENT',`

두 개 이상의 요소가 있을 경우 마지막 요소에는 콤마를 붙이지 않는다.

* `TUPLE_NAME = 'ONE', 'TWO'`

값들을 괄호로 묶어서 튜플을 정의하는 것이 더 구분하기 좋다.

튜플은 한 번여 여러 변수를 할당할 수 있다. 이것을 tuple unpacking이라고 한다.

* `a, b = TUPLE_NAME`

한 line에서 튜플을 사용해 swap을 할 수 있다.

```
a = 'abc'
b = 'def'
a, b = b, a
```

`tuple()`은 다른 객체를 튜플로 만든다.

* `tuple(LIST_NAME)`

왜 튜플을 사용할까

1. 튜플은 리스트보다 더 적은 공간을 사용한다.
2. 데이터가 손상될 염려가 없다.
3. 튜플을 딕셔너리 키로 사용할 수 있다.
4. `named tuple`은 객체의 단순한 대안이 될 수 있다.
5. 함수의 인자들은 튜플로 전달된다.

## ● 딕셔너리

딕셔너리의 키들은 반드시 유일해야 한다. 

만약 같은 키를 두 번 이상 사용하면 마지막 값이 저장된다.

`update()` : 딕셔너리 결합

* `DICTIONARY_NAME.update(OTHER_DIC)`

`del` : 딕셔너리 키로 항목을 삭제

* `del DICTIONARY_NAME[DIC_KEY]`

모든 항목 삭제하기

* `DICTIONARY_NAME.clear()`

* `DICTIONARY_NAME = {}`

`in` : 키 멤버십 확인-> `return True or False`

* `KEY_NAME in DICTIONARY_NAME`

* 딕셔너리에 키가 존재하지 않으면 `KeyError` 예외가 발생한다.

`get()` : `KeyError` 방지

* 키가 존재하면 값을 반환한다.
* 키가 존재하지 않으면 옵션 값을 지정하여 출력한다.
    * `DICTIONARY_NAME.get(DIC_KEY, 'Not Exist')`
* 옵션값을 지정하지 않으면 `None`이 반환된다.

`keys()` : 모든 키 얻기

* 파이썬 2의 `keys()`는 리스트를 반환한다.
* 파이썬 3의 `keys()`는 iterable한 `dict_keys()`를 반환한다.
* 사용되지 않을 리스트를 생성하고 저장하기 위한 메모리와 시간을 소비하지 않기 때문에 아주 큰 딕셔너리에 유용하다.
* 리스트로 만들려면 `list(DICTION_NAME.keys())`를 이용한다.

`values()` : 모든 값 얻기

`items()` : 모든 쌍의 키-값 얻기

* 각 키와 값은 튜플로 반환된다.

* = : 참조 vs copy() : 복사

## ● set

키만 남은 딕셔너리

`EMPTY_SET = set()`

`SET_NAME = {1, 2, 3, 4, 5}`

`set()` : 데이터 타입 변환

* 문자열, 리스트, 튜플, 딕셔너리를 중복된 값을 버린 셋으로 만들 수 있다.

* 딕셔너리에 `set()`을 사용하면 키만으로 이루어진 셋이 생성된다.

`&` : 셋 인터섹션 연산자(set intersection operator)

* ex) `SET_NAME & {ELEMENT1, ELEMENT2}`

* ex) `if ELEMENT1 in SET and not SET & {ELEMENT2, ELEMENT3}:`

* `True` : ELEMENT1, ELEMENT2가 포함된 SET

* `False` : 빈 셋

* `&` 연산자와 `intersection()` 함수를 사용하여 intersecion(교집합)을 구할 수 있다.

    ```
    SET_A & SET_B

    SET_A.intersection(SET_B)
    ```

* `|` 연산자와 `union()` 함수를 사용하여 union(합집함)을 구할 수 있다.

* `-` 연산자와 `difference()` 함수를 사용하여 difference(차집함)을 구할 수 있다.

* `^` 연산자와 `symmetric_difference()` 함수 -> exclusive(대칭 차집합:한쪽 셋에는 있지만 양쪽 모두에 있지 않은 멤버)

* `<=` 연산자와 `issubset()` 함수 -> 첫 번째 셋이 두 번째 셋의 subset(부분집합)
    * `return True or Fasle`

* `<` 연산자 : 첫 번째 셋이 두 번째 셋의 proper subset(진부분집합:두 번째 셋에 첫 번째 셋의 모든 멤버를 포함한 그 이상의 멤버가 있다.)

* `>=` 연산자 : superset(상위집합:subset의 반대말)