# 3. 벡터

## 3.1 벡터란 무엇인가

- 운반하다라는 뜻의 라틴어
- 어떤 것을 한 장소에서 다른 곳으로 이동하는 벡터의 방향성에서 비롯
- 파이썬의 리스트를 사용하여 벡터를 나타내기도 한다.

- Definition 3.1.1: 4개의 실수를 원소로 가지는 벡터를 $R$상의 4-벡터라고 한다.

- 한 벡터의 모든 원소는 **하나의 필드**에서 나와야 한다.

- Definition 3.1.2 필드 $F$와 양의 정수 $n$에 대해, $F$에 속하는 $n$개 원소를 가지는 벡터를 $F$상의 $n$-벡터라고 한다. $F$상의 $n$-벡터들의 집합은 $F^n$으로 나타낸다.
- 예들 들어 $R$상의 4-벡터들의 집합을 $R^4$라고 쓴다.

- 벡터는 사실상 함수다.

```math
0 -> 123
1 -> 234
3 -> -123
4 -> -234
```

## 3.2 벡터는 함수다

- 벡터를 함수라고 정의할 수 있으면 많은 분야로 응용할 수 있다.

- Example 3.2.1 벡터로 나타낸 문서
  - 정보 검색은 문서들에 대한 word-bag 모델
  - 문서는 단순히 단어들로 구성된 멀티셋 또는 bag으로 간주한다.
  - 멀티셋은 집합과 같지만, 동일 원소를 여러 번 포함할 수 있다.
  - 동일 원소가 나타나는 횟수는 그 원소의 중복도(multiplicity)라고 한다.
  - 단어들의 bag은 함수 f에 의해 나타낼 수 있다.
  - f의 정의역은 단어들의 집합, 치역은 실수들의 집합
  - 어떤 단어의 상은 그 단어의 중복도이다.
  - WORDS를 단어들의 집합이라고 하자.
  - 그러면 f는 WORDS에서 $R$로 매핑된다는 것을 나타내가 위해 다음과 같이 쓴다.
  - $f:WORDS -> R$
  - 이러한 함수는 벡터를 나타내는 것으로 해석될 수 있으며, 실수 $R$ 상의 WORDS-벡터라고 부른다.

- Definition 3.2.2 유한 집합 $D$와 필드 $F$에 대해, $F$상의 $D$-벡터는 $D$에서 $F$로의 함수이다.

- 정의역 $D$는 유한해야 한다.

- $F^D$는 정의역 $D$와 공변역 $F$를 가지는 함수들의 집합이다. 즉, $F$상의 모든 $D$-벡터들의 집합이다.

- Example 3.2.3
  - $R^{WORDS}$: $R$상의 모든 $WORDS$-벡터들의 집합
  - $GF(2)^{\{0, 1, ..., n-1\}}: GF(2)$상의 모든 $n$-벡터들의 집합

### 3.2.1 파이썬의 딕셔너리를 이용한 벡터 표현

- 값이 0인 키-값 쌍을 생략하는 방식
- 이것을 스파스(sparse) 표현이라고 한다.

### 3.2.2 Sparsity

- 대부분의 원소값이 0인 벡터를 스파스(sparse) 벡터라고 한다.
- 0이 아닌 원소의 수가 최대 k개인 벡터는 k-스파스라고 한다.
- k-스파스 벡터는 k에 비례하는 공간을 사용하여 표현될 수 있다.
- 물리적 센서(ex: 이미지, 소리)를 통해 얻은 데이터를 나타내는 벡터는 스파스하지 않을 가능성이 높다.

- 행렬은 보통 스파스하므로, 저장 공간과 계산 시간을 줄이기 위해 원소값이 0인것은 표현하지 않는 딕셔너리를 사용하여 표현한다.

## 3.3 벡터로 무엇을 표현할 수 있는가

- 이진 문자열.
  - GF(2)상의 n-벡터로 표현할 수 있다.

- 속성.
  - 속성 이름과 속성값의 컬렉션으로 표현되는 데이터 집합
  - 속성 이름을 값에 매핑하는 함수로 표현할 수 있다.
  - `ABC = {'age':5, 'length': 120}`

- 시스템의 상태.
  - 진화하는 시스템의 다른 상태를 나타낼 때
  - 동일한 수준의 값을 나열할 때
    - 예를 들어 인구가 가장 많은 5개 국가의 인구를 명시

- 확률 분포.
  - 유한한 확률 분포는 유한한 정의역에서 실수로의 함수이다.
  - `{1:1/6, 2:1/6, ... , 6:1/6}`
  - 확률 분포는 벡터로 간주할 수 있다.

- 이미지.

- 공간상의 점.

- Task 3.3.2

```py
from plotting import plot
L = [[2, 2], [3, 2], [1.75, 1],]
plot(L, 4)
```

- plot은 사분면에 L의 점들을 나타내는 윈도우를 생성한다.
- plot의 첫 번째 인수는 벡터들의 집합.
- 두 번째 인수는 그림의 크기를 설정한다.

- 복소수와는 다르게 벡터들은 더 높은 차원의 공간상의 점들을 표현할 수 있다.

## 3.4 벡터 덧셈

### 3.4.1 평행이동과 벡터 덧셈

- 복소평면에서의 평행이동은 복소수 $z_0$를 입력 복소수에 더하는 함수 $f(z) = z_0 + z$에 의해 이루어진다.
- 마찬가지로 어떤 벡터를 입력 벡터에 더하는 함수 $f(v) = v_0 + v$에 의해 평행이동을 할 수 있다.

- Definition 3.4.1 n-벡터들의 덧셈은 대응하는 원소들의 덧셈으로 정의된다.

- 파이썬에서 2-원소 리스트들로 나타낸 2-벡터들에 대해 덧셈 프로시저는 다음과 같다.

```py
def add2(v, w):
  return [v[0]+w[0], v[1]+W[1]]
```

- Quiz 3.4.2 동쪽으로 1마일, 북쪽으로 2마일 이동하라를 2-벡터에서 2-벡터로의 함수로 나타내는 평행이동을 작성해보자. 그 다음이 이 함수를 벡터 [4, 4], [-4, -4]에 적용한 결과를 보여주자.

- $f(v) = [1, 2] + v$
  - $f([4, 4]) = [1, 2] + [4, 4] = [5, 6]$
  - $f([-4, -4]) = [-3, -2]$

- [4, 4] 에서 [5, 6] 으로 무엇인가를 운반하는 것으로 생각할 수 있다.

- Task 3.4.3 Task 3.3.2에서 정의된 리스트 L
  - 2-벡터 덧셈을 정의하는 프로시저를 작성.
  - 컴프리헨션을 사용하여 [1, 2]를 각각에 더하여 얻어진 점들을 그래프로 그려보자.

```py
import plotting from plot

v = [1, 2]
L = [[2, 2], [3, 2], [1.75, 1],]
plot([[w[0] + v[0], w[1] + w[1]] for w in L])
```

```py
plat([add2(v, [1, 2]) for v in L], 4)
```

- Quiz 3.4.4 n-벡터들을 n-원소 리스트들로 나태난다고 가정해보자. 어렇게 나타낸 두 개의 벡터들의 합을 계산하는 프로시저, addn을 작성해보자.

```py
def addn(v, w):
  return [x + y for (x, y) in zip(v, w)]
```

```py
def addn(v, w):
  return [v[i] + w[i] for i in range(len(v))]
```

- 모든 필드 F는 0을 원소로 가진다.
- 따라서 F상의 D-벡터들로 구성된 집합 $F^D$는 필연적으로 영벡터를 가진다.
- 영백테는 모든 원소의 값이 0인 벡터
- $0_D$ 또는 $D$를 명시할 필요가 없을 때는 단순히 $0$으로 나타낸다.
- 함수 $f(v) = v + 0$에 의한 평행이동은 그 결과가 입력과 동일한 평행이동이다.

### 3.4.2 벡터 덧셈의 결합성과 교환성

- 필드에서 덧셈의 두 가지 성질을 결합성과 교환성이다.
- 덧셈의 결합성은 $(x + y) + z = x + (y + z)$
- 벡터의 덧셈도 결합법치과 교환법칙이 성립한다.

### 3.4.3 벡터를 화살표로 표현하기

- 2-벡터 [3, 1.5]는 꼬리가 원점에 있고 머리가 (3, 1.5)에 있는 화살표로 나타낼 수 있다.
- 꼬리는 (-2, -1)에 있고 머리는 (1, 0.5)에 있는 화살표로도 나타낼 수 있다.
- 벡터 $u$에 대응하는 평행이동과 $v$에 대응하는 평행이동이 합쳐져 $u + v$에 대응하는 평행이동을 얻는다.

## 3.5 스칼라-벡터 곱셈

- 스케일링은 복소평면에서 입력된 복소수를 양의 실수 $r$과 곱하는 함수 $f(z) = rz$로 표현된다.
- 음의 실수를 곱하면 동일하지만 180도 회전된 스케일링을 얻는다.

- Definition 3.5.1 벡터 $v$와 스칼라 $\alpha$의 곱셈은 $v$의 원소 각각을 $\alpha$와 곱하는 것으로 정의된다.

- Quiz 3.5.3 n-벡터들을 n-원소 리스트들로 나타낸다고 해 보자. 벡터 v를 스칼라 alpha와 곱하는 프로시저 scalar_vector_mult(alpha, v)를 작성해보자.

```py
def scalar_vector_mult(alpha, v):
  return [el * alpha for el in v]
```

### 3.5.1 화살표 스케일링하기

- $R$상의 벡터를 양의 실수로 스케일링하는 것은 벡터의 방향을 바꾸지 않고 대응하는 화살표의 길이를 변경한다.
- 음의 실수로 곱하는 것은 그 벡터의 모든 원소값의 부호를 바꾸는 것이다.
- 이것은 화살표의 방향을 반대로 하는 것이다.

### 3.5.2 스칼라-벡터 곱셈의 결합성

- Proposition 3.5.5 $a(bv) = (ab)v$

### 3.5.3 원점을 지나는 선분

- 다음의 프로시저는 스칼라 각각에 $v$를 곱하여 얻을 점들

```py
plot([scalar_vector_mult(i/10, v) for i in range(11)], 5)
```

- $v$에 곱하는 스칼라를 0과 1 사이의 모든 실수를 포함하면?
- 다음 점들의 집합은 원점과 $v$ 사이의 선분을 형성한다.

- $\{av : a\in R, 0\leq a \leq 1 \}$

- 모든 점을 다 그릴수는 없지만 충분히 빽빽하게 샘플하면 선분처럼 그릴 수 있다.

```py
plot([scalar_vector_mult(i/100, v) for i in range(101)], 5)
```

### 3.5.4 원점을 지나는 직선

- 점 $\{ av: a \in R\}$은 원점과 $v$를 지나는 직선을 형성한다.

## 3.6 백터 덧셈과 스칼라 곱셈 결합하기

### 3.6.1 원점을 지나지 않는 선분과 직선

- $\{a[3, 2] + [0.5, 1]: a\in R, 0\leq a \leq 1 \}$

- [3, 2]를 [0.5, 1]만큼 평행이동

```py
plot([add2(scalar_vector_mult(i/100, [3, 2]), [0.5, 1]) for i in range(101)], 4)
```

### 3.6.2 스칼라-벡터 곱셈과 벡터 덧셈의 분배 법칙

### 3.6.3 볼록결합(Convex combination) 들여다 보기

- [0.5, 1]과 [3.5, 3]을 잇는 선분을 이루는 점들의 집합에 대한 표현식은
- $\{a[3,2] + [0.5, 1] : a \in R, 0 \leq a \leq 1 \}$
- 이 표현식의 형태가 선분의 한 끝점은 포함하는 데 다른 끝점은 포함하지 않는다는 것이 이상하다. 이러한 비대칭은 부적절하다.

- [0.5, 1]과 [3.5, 3]을 잇는 선분에 대한 표현식을 다음과 같이 고쳐 쓸 수 있다.
- $b = 1 - a$
- $\{a[3,2] + b[0.5, 1] : a, b \in R, a, b \geq 0, a + b = 1 \}$
- 이 식은 양 끝점에 대해 대칭이다.

- $au + bv$ 형태의 표현식은 $u$와 $v$의 볼록결합이라고 한다.

- 임의의 $R$ 상의 n-벡터들의 쌍 $u, v$에 대해 다음과 같이 말할 수 있다.
- Proposition 3.6.7: $u-v$ 선분은 $u$와 $v$의 볼록결합들의 집합으로 구성된다.

### 3.6.4 아핀결합(Affine combination) 들여다 보기

- Hypothesis 3.6.11: $u-v$를 지나는 직선은 $u$와 $v$의 아핀결합들의 집합으로 구성된다.

## 3.7 딕셔너리에 기반을 둔 벡터 표현

- 벡터는 어떤 정의역 D에서 필드로의 함수.
- 이러한 함수를 파이썬의 딕셔너리를 사용하여 나타낼 수 있다.
- 파이썬의 클래스 Vec를 정의하여 하나의 인스턴스가 두 개의 필드를 가지게 하면 편리하다.
  - f, 파이썬의 딕셔너리에 의해 표현되는 함수.
  - D, 파이썬의 집합에 의해 표현되는 함수의 정의역

```py
class Vec:
  def __init__(self, labels, fucntion):
    self.D = labels
    self.f = function
```

- 다음과 같이 Vec의 인스턴스를 생성할 수 있다.

```py
v = Vec({'A'. 'B', 'C'}, {'A': 1})

for d in v.D:
  if d in v.f:
    print(v.f[D])
```

### 3.7.1 Setter와 Getter

```py
def setitem(v, d, val):
  v.f[d] = val

def getitem(v, d):
  return v.f[d] if d in v.f else 0
```

### 3.7.2 스칼라-벡터 곱셈

```py
def scalar_mul(v, alpha):
  return Vec(v.D, {d: alpha * getitem(v, d) for d in v.D})
```

- 위의 프로시저는 sparsity를 유지하지 않는다.
- sparsity를 유지하기 위해서는 다음과 같이 작성한다.

```py
def scalar_mul(v, alpha):
  return Vec(v.D, {d: alpha * value for d, value in v.f.items()}
```

...

## 3.8 GF(2)상의 벡터

### 3.8.1 완벽한 비밀 유지 - 다시 보기

- 엘리스와 밥은 10-벡터 K를 랜덤하게 선택한다.
- 엘리스는 다음 식에 따라 암호문 c를 계산한다.
- $c = p + k$

...

### 3.8.2 GF(2)를 사용한 전부가 아니면 아무것도 공유하지 않는 비밀 공유

### 3.8.3 Lights Out

- 5 * 5
- 버튼을 누르면 그 버튼의 현재 상태가 반대로 바뀌고 동시에 눌러진 버튼 주변 4개 버튼의 상태도 반대로 바뀐다.
- 모든 버튼의 불을 꺼지게 하는 것이 목표.
- Question 3.8.5 가능한 모든 시작 상태에 대해 이 퍼즐을 풀 수 있는 방법이 있는가?

```py
{
  (0, 0): one, (0, 1): 0,   (0, 2): one, (0, 3): one, (0, 4): one,
  (1, 0): 0,   (1, 1): 0,   (1, 2): one, (1, 3): one, (1, 4): one,
  (2, 0): one, (2, 1): one, (2, 2): 0,   (2, 3): one, (2, 4): one,
  (3, 0): 0,   (3, 1): 0,   (3, 2): one, (3, 3): one, (3, 4): one,
  (4, 0): 0,   (4, 1): 0,   (4, 2): one, (4, 3): one, (4, 4): one,
}
```

- 위 벡터를 s라고 하자.

- (0, 0)을 누르면 (0)