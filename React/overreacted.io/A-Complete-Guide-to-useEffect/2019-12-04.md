# useEffect 완벽 가이드 발췌

읽으면서 나에게 의미있었거나 곰곰히 생각을 하게 해준 문구들을 발췌해본다.

> 제가 useEffect 훅을 클래스 컴포넌트의 라이프사이클이라는 익숙한 프리즘을 통해 바라보는 것을 그만두자 모든 것이 명백하게 다가왔습니다.

나도 componentDidMount와 동일한 행위를 하는 것이 useEffect 기능의 일부라고 알고 있었는데... 생각해보니 useEffect 전체를 이해하는 것이 아니라 단면만을 이해한 것 같다.

useEffect를 뭐라고 정의할 수 있을까?

특정 state의 변화를 관찰하고 있다가 변화가 생기면 액션을 취하는 훅? 이게 맞을까?

> 질문: useEffect 로 componentDidMount 동작을 흉내내려면 어떻게 하지?
>
> 완전히 같진 않지만 `useEffect(fn, [])` 으로 가능합니다. componentDidMount 와 달리 prop과 state를 잡아둘 것입니다. 그래서 콜백 안에서도 초기 prop과 state를 확인할 수 있습니다.

componentDidMount와 달리 prop과 state를 잡아둘 것이다? 이게 무슨 말일까?

> `[]` 는 이펙트에 리액트 데이터 흐름에 관여하는 어떠한 값도 사용하지 않겠다는 뜻입니다. 그래서 한 번 적용되어도 안전하다는 뜻이기도 합니다.

명쾌한 설명이다. 기억해두자.

> 질문: 이펙트를 일으키는 의존성 배열에 함수를 명시해도 되는걸까?
>
> 추천하는 방법은 prop이나 state를 반드시 요구하지 않는 함수는 컴포넌트 바깥에 선언해서 호이스팅하고, 이펙트 안에서만 사용되는 함수는 이펙트 함수 내부에 선언하는 겁니다. 그러고 나서 만약에 랜더 범위 안에 있는 함수를 이펙트가 사용하고 있다면 (prop으로 내려오는 함수 포함해서), 구현부를 useCallback 으로 감싸세요. 왜 이런걸 신경써야 할까요? 함수는 prop과 state로부터 값을 “볼 수” 있습니다. 그러므로 리액트의 데이터 플로우와 연관이 있지요.

결국 함수를 의존성 배열에 명시할 필요가 없다는 얘기로 들린다. 명심하자.

> 질문: 왜 가끔씩 데이터 페칭이 무한루프에 빠지는걸까?
>
> 이펙트 안에서 데이터 페칭을 할 때 두 번째 인자로 의존성 배열을 전달하지 않았을 때 생길 수 있는 문제입니다. 이게 없으면 이펙트는 매 랜더마다 실행됩니다. 그리고 state를 설정하는 일은 또 다시 이펙트를 실행하죠.
> 의존성 배열에 항상 바뀌는 값을 지정해 두는 경우에도 무한 루프가 생길 수 있습니다.

의존성 배열이 없다면 이펙트는 매 랜더마다 실행된다. -> state가 변경되면 또 다시 이펙트가 실행된다.

오오 곰곰이 생각해보니 좀 더 이해가 된다.

useEffect는 state의 변화에 반응한다. 의존성 배열이 아예 없으면 매 랜더마다 실행되고, state가 변경되어도 실행된다. `[]`는 useEffect가 연관된 state가 없다는 것을 의미한다. 그래서 최초 랜더시에 1번만 실행된다. 의존성 배열에 값이 있다면 해당 값이 변할 때만 useEffect가 실행된다.

## 모든 랜더링은 고유의 Prop과 State가 있다

> state를 업데이트할 때마다, 리액트는 컴포넌트를 호출합니다. 매 랜더 결과물은 고유의 counter 상태 값을 “살펴봅니다”. 그리고 이 값은 함수 안에 상수로 존재하는 값입니다.
>
> 명심하셔야 할 점은 여느 특정 랜더링 시 그 안에 있는 count 상수는 시간이 지난다고 바뀌는 것이 아니라는 것입니다. 컴포넌트가 다시 호출되고, 각각의 랜더링마다 격리된 고유의 count 값을 “보는” 것입니다.

"각각의 랜더링마다 격리된 고유의 count 값을 '보는' 것이다."

허허 전혀 이렇게 생각하지 않고 있었다.

그런데 일반 함수처럼 바인딩 된 값이 변경된다고 생각하면 안되는 이유가 있을까? 잘 모르겠다.

