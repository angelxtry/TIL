#

## 객체

* 파이썬에서는 숫자 값, 문자열, 클래스, 클래스의 인스턴스, 모듈, 컴파일된 코드 등 모두 object다.
* object는 프로그램 안에서 참조할 수 있도록 이름표를 붙일 수 있다.
* 이 이름표를 변수라고 한다.
* 변수는 object에 대한 참조다. reference
* 모든 object는 identity를 갖고 있다. identity란 해당 object의 실체가 있는 위치를 가리키는 메모리상의 주소 같은 것이다.
* CPython 구현에서는 메모리 주소가 리턴된다.
* identity는 objcet가 생성될 때 결정되며 이후 변경되지 않는다.

## underscore

* IPython에서 underscore는 바로 직전에 실행한 명령의 결과를 가리킨다.
* `_*`
  * 모듈안에서 _로 시작하는 식별자를 정의하면 다른 파일에서 접근할 수 없게 된다.
* `__*__`
  * 시스템에서 정의
* `__*`
  * 클래스 안에서 외부로 노출되지 않는 식별자로 인식된다.

## immutable

```py
In [1]: a = 1.2
In [2]: id(a)
Out[2]: 74767648

In [3]: a = 2.3
In [4]: id(a)
Out[4]: 74767744
```

* 내장 데이터 타입 중에 숫자 데이터 타입(int, float, complex)는 immutable이다.
* 숫자 값이 immutable이라는 것은 값을 바꾸면 identity 값도 바뀐다는 것을 의미한다.
* 다시 말해, 메모리의 위치를 바꾸지 않으면 데이터 내용을 바꿀 수 없다.
* 같은 변수를 사용하여 스칼라 값을 재정의하는 것은 가능하므로 스칼라 값이 immutable이라는 것을 보통 의식하지 않아도 된다.

## 숫자 데이터 타입

* 정수 타입(int)은 값의 범위에 기본적으로 제한이 없지만, 현실적으로는 메모리의 크기의 제한을 받는다.
* 최대 크기는 sys.maxsize로 확인할 수 있다.

## 집합

* set은 중복을 허용하지 않는 순서를 갖지 않는 데이터의 모임이다.
* 기본적으로 mutable이지만 immutable인 frozen set도 있다.

```py
fs = frozenset([1, 2, 'd'])
```

## 변수와 데이터

```py
In [1]: a = 1

In [2]: b = a

In [3]: id(a)
Out[3]: 499102784

In [4]: id(b)
Out[4]: 499102784

In [5]: b = 2

In [6]: a
Out[6]: 1

In [7]: b
Out[7]: 2

In [8]: id(a)
Out[8]: 499102784

In [9]: id(b)
Out[9]: 499102816

In [10]: b = 1

In [11]: id(b)
Out[11]: 499102784
```

* `b = a`를 실행했을 때 b를 a의 별명으로 설정한 것이다.
* 즉, b와 a는 모두 같은 메모리 주소에 연결되어 있다. 참조 값의 할당이라고 한다.
* b에 새로운 값을 대입하는 순간 b가 가리키는 주소가 변경된다.
* b에 다시 1을 대입하면 a와 동일한 주소를 가리키게 된다.
* C언어의 경우 `b = a`를 수행하면 b는 a와 다른 별도의 메모리 공간이 할당되고 값이 복사된다.
* 파이썬의 경우 a와 b에 각각 다른 값을 할당하면 a, b의 주소가 변경된다.
* 정수 타입은 immutable이므로 같은 주소의 데이터가 바뀌지 않는다.
* C언어의 경우 a와 b에 각각 다른 값을 할당하면 동일한 주소에 데이터만 변경된다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = a

In [3]: id(a)
Out[3]: 77505736

In [4]: id(b)
Out[4]: 77505736

In [5]: b
Out[5]: [1, 2, 3, 4]

In [6]: b[1] = 100

In [7]: id(a)
Out[7]: 77505736

In [8]: id(b)
Out[8]: 77505736

In [9]: a
Out[9]: [1, 100, 3, 4]

In [10]: b
Out[10]: [1, 100, 3, 4]

In [11]: a is b
Out[11]: True
```

* a는 list다.
* `b = a`를 실행하면 a와 b는 동일한 주소를 가리킨다.
* b[1]의 데이터를 변경하면 a[1]도 같이 변경되는 것 처럼 보인다.
* 이것은 b[1]의 값을 변경했다기보다 b[1]이 가리키고 있는 주소가 변경되었고 그 주소에 100이 저장된 것이다.
* b[1]의 데이터가 변경되어도 b 자체의 주소는 변경되지 않는다.
* a와 b가 같은 실체를 기리키고 있는지는 is 연산자를 이용해서도 확인할 수 있다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = a

In [3]: a is b
Out[3]: True

In [4]: b = [1, 2, 3, 5]

In [5]: a is b
Out[5]: False

In [6]: b = [1, 2, 3, 4]

In [7]: a is b
Out[7]: False

In [8]: a = [1, 2, 3, 4]

In [9]: b = a

In [10]: a is b
Out[10]: True

In [11]: b = [1, 2, 3, 4]

In [12]: a is b
Out[12]: False
```

* 인덱싱을 통해 데이터의 일부를 변경하는 경우와는 달리 인덱싱이나 슬라이싱이 아닌 재할당을 하는 경우 변수가 새롭게 정의된다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = a

In [3]: a is b
Out[3]: True

In [4]: b[:] = [5, 6, 7, 8]

In [5]: a is b
Out[5]: True
```

* 인덱싱이나 슬라이싱을 사용한 할당문으로 처리할 경우 b가 재정의 되지 않는다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = [1, 2, 3, 4]

In [3]: a == b
Out[3]: True

In [4]: a is b
Out[4]: False

In [5]: [id(k) for k in a]
Out[5]: [495170624, 495170656, 495170688, 495170720]

In [6]: [id(k) for k in b]
Out[6]: [495170624, 495170656, 495170688, 495170720]

In [7]: b[1] = 10

In [8]: a
Out[8]: [1, 2, 3, 4]

In [9]: b
Out[9]: [1, 10, 3, 4]

In [10]: [id(k) for k in b]
Out[10]: [495170624, 495170912, 495170688, 495170720]
```

* a와 b의 값이 동일하다. 하지만 a, b 자체의 identity 값은 다르다.
* a, b 각 요소의 identity 값은 동일하다.
* a, b 자체의 identity 값이 다르므로 b[1]의 값을 변경해도 a에는 영향을 주지 않는다.

```py
In [54]: a = [1, 2, 3, 4]

In [55]: b = a[:]

In [56]: a is b
Out[56]: False

In [57]: a == b
Out[57]: True

In [58]: [id(k) for k in a]
Out[58]: [505197632, 505197664, 505197696, 505197728]

In [59]: [id(k) for k in b]
Out[59]: [505197632, 505197664, 505197696, 505197728]

In [60]: b[0] = 100

In [61]: a
Out[61]: [1, 2, 3, 4]
```

* a를 슬라이싱 하면서 b에 할당했다.
* 이 경우 a와 b의 주소는 다르다.
* 그러므로 b 값을 변경하여도 a에 영향을 주지 않는다.

## 얕은 복사와 깊은 복사

* 얕은 복사: 참조만 복사
* 깊은 복사: 데이터까지 완전히 복사
* 얕은 복사와 깊은 복사의 차이가 드러나는 경우는 컨테이너 타입이나 클래스 인스턴스처럼 내부에 객체를 포함하는 복합 객체를 다룰 때 뿐이다.
* 중첩하지 않은 리스트의 복사는 어느 쪽이든 같다.
* 다음의 경우에 얕은 복사가 수행된다.
  * 표준 라이브러리의 copy를 이용한 복사
  * list/dict 함수를 이용한 리스트 및 딕셔너리의 복사
  * 인덱싱 혹은 슬라이싱을 사용한 복사

### 복합 객체가 아닌 경우

```py
In [1]: import copy

In [2]: a = [1, 2, 3, 4]

In [3]: b = copy.copy(a)

In [4]: a is b
Out[4]: False

In [5]: b[0] = 10

In [6]: a
Out[6]: [1, 2, 3, 4]

In [7]: b
Out[7]: [10, 2, 3, 4]
```

* 얕은 복사와 깊은 복사의 차이가 없다.

## 복합 객체인 경우

```py
In [1]: import copy

In [2]: a = [1, 2, [3, 4]]

In [3]: b = copy.copy(a)

In [4]: b[0] = 10

In [5]: a
Out[5]: [1, 2, [3, 4]]

In [6]: b
Out[6]: [10, 2, [3, 4]]

In [7]: b[2][0] = 30

In [8]: a
Out[8]: [1, 2, [30, 4]]

In [9]: b
Out[9]: [10, 2, [30, 4]]

In [10]: a[2] is b[2]
Out[10]: True
```

* 얕은 복사를 수행했다.
* b[0]을 변경했을 경우 a에는 영향이 없다.
* b[2][0]을 변경하면 a[2][0]의 데이터도 변경된다.
* 파이썬 공식 문서에 따르면 얕은 복사로 새로운 복합 객체를 만든 다음 원래 객체 안에서 찾은 객체에 대한 참조를 삽입한다고 되어 있다.
* list/dict 함수나 인덱싱 및 슬라이싱으로 생성한 복합 객체에도 적용된다.

### 깊은 복사

```py
In [1]: import copy

In [2]: a = [1, 2, [3, 4]]

In [3]: b = copy.deepcopy(a)

In [4]: b[0] = 10

In [5]: b[2][0] = 30

In [6]: a
Out[6]: [1, 2, [3, 4]]

In [7]: b
Out[7]: [10, 2, [30, 4]]
```

* 깊은 복사는 표준 라이브러리 copy의 deepcopy 함수로 수행할 수 있다.
* 깊은 복사는 완전한 사본을 만들어내므로 다른 언어에서 데이터를 복사할 때와 크게 다르지 않다.

## 비교 연산자

* == : 변수의 데이터가 같다.
* != : 변수의 데어터가 같지 않다.
* is : 변수의 identity 값이 같다.
* is not : 변수의 identity 같이 같지 않다.

## 숫자 데이터 타입의 연산

* 파이썬 3.x 에서는 정수와 정수의 나눗셈에서 부동 소수 타입의 결과가 나온다.
* 딱 떨어지는 정수끼리에서도 마찬가지다.
* `//` 연산자를 사용하면 명시적으로 정수 나눗셈을 수행한다.
* 부동 소수 티입 실수도 `//` 연산자를 사용하면 정수 나눗셈을 수행한다.
* 정수 나눗셈은 음의 방향으로 정수를 반올림한다.

## for문

* else 문과 함께 사용할 수 있다.
* else문은 for loop를 모두 순회한 후 실행된다.
* for loop 순회 중에 break가 실행되면 else를 건너뛴다.

## while문

* for문과 동일하게 else문을 사용할 수 있다.

## try문

* 예외처리를 한다.

```py
try:
    statement1
except ImportError:
    statement2
except IOError:
    statement3
else:
    statement4  # 예외가 발생하지 않은 경우에만 실행된다.
finally:
    statement5  # 예외 발생 여부와 상관없이 실행된다.
```

## 가변 길이 인자와 키워드 인자

* 가변 길이 인자는 튜플 형태로 함수에 넘겨진다.
* 키워드 인자는 딕셔너리 형태로 함수에 넘겨진다.

## lambda 식

```py
In [1]: xy = [[3, 5, 1], [4, 2, 9]]

In [2]: ans = list(map(lambda x, y: x * x +y, *xy))

In [3]: ans
Out[3]: [13, 27, 10]
```

* unpacking에 유의하자.

## 파일을 검색하는 순서

* 파이썬에서 모듈을 import 할 때 import 하려는 이름의 모듈이 여러개 존재할 경우 정해진 우선순위에 따라 검색하여 가장 처음 발견된 모듈을 import 한다.
* 순서는 다음과 같다.
  * 현재 작업 디렉토리
  * 환경 변수 PYTHONPATH에 설정된 디렉토리
  * 표준 라이브러리 모듈 디렉토리
  * 서드파티 라이브러리 모듈 디렉토리

```py
In [1]: import sys

In [2]: sys.path
Out[2]:
['',
 ...]

In [3]: sys.path.append('add to path')
```

* sys.path를 통해 확인할 수 있다.
* sys.path.append를 이용하여 추가할 수 있다.
