# s70 세번째 강의

s70 2번째 강의 결과물의 문제점은 tasks 배열과 STATE_P, STATE_C가 외부로 노출되어 있다는 것이다.

외부에서 노출시킨 addTask, changeState 등을 사용하지 않고도 tasks 등을 직접 제어할 수 있다.

우리가 원하는 것은 addTask, removeTask, changeState만 외부로 노출하고 나머지는 노출하고 싶지 않다.

그러기 위해서 전체를 즉시실행함수로 감싼다.

즉시실행함수로 감싸기만 하면 외부에서 함수 또한 호출할 수 없다.

그래서 즉시실행함수에서 object를 return 한다.

```js
return {
    addTask: addTask,
    removeTask: removeTask,
    changeState: changeState
};
```

캡슐화, 은닉

비슷한 단어 처럼보이지만 의미가 다른다.

은닉은 함수바깥에서 내부의 값을 직접 접근할 수 없도록 숨기는 것이다.

캡슐화는 불필요한 부분을 숨기고 추상화하여 필요한 인터페이스만 노출하는 것을 의미한다.

task나 STATE_P 등을 함수로 감싸서 숨긴 것은 은닉이다.

하지만 은닉을 했다고해서 캡슐화를 한 것은 아니다.

최종적으로 필요한 인터페이스만을 외부로 노출해야 캡슐화가 된 것이다.

어떻게 캡슐화를 하느냐, 어떤 인터페이스를 노출하느냐에 따라 프로그램의 편의성이 달라진다.

addTask는 객체는 생성하고, id를 증가시키는 등 여러가지 일을한다.

하지만 외부에 노출된 인터페이스에서는 파라미터 하나만 받는다.

이것은 우리가 선택한 것이어야 한다.

함수는 파라미터와 출력값(리턴값)으로 외부와 통신을 한다.

함수를 만들때는 이 함수를 사용하게 될 사용자가 어떻게하면 이 함수를 편하고 안전하게 사용할 수 있을지 고민해야한다.

그 고민의 결과물이 파라미터와 출력값이 되어야 한다.

함수는 시그니처와 정의라는 용어를 사용한다.

시그니처는 그 함수에 고유성을 부여하는 특성을 말한다.

함수의 고유성은 함수의 이름과 파라미터로 결정된다. 리턴값은 시그니처를 결정하지 못한다.

함수의 정의는 그 함수의 모든 것을 의미한다.

----

전체 즉시실행함수는 object를 리턴한다. 그래서 변수에 할당해야한다.

```js
var todo = (function(){})();
```

실제로 todo를 사용한다면 todo.addTask('할일'); 처럼 사용할 것이다.

여기서 todo.addTask는 의미 중복이다.

그러므로 캡슐화할 때 노출하는 이름을 변경해준다.

```js
return {
    add: addTask,
    remove: addTask,
    changeState: changeState
};
```

모든 이름은 이 함수를 쓸 사람을 위해 만들어야 한다.

----

changeState에 집중해보자.

changeState가 가질 수 있는 값은 STATE_P, STATE_C 밖에 없다.

하지만 노출된 인터페이스에서는 훨씬 더 많은 종류의 값을 받을 수 있다.

이럴 경우 toggle이라는 메소드로 변경하는 것이 낫다.

toggle로 인터페이스를 수정해보자.

```js
return {
    add: addTask,
    remove: removeTask,
    toggle: function(id){
        for(var i = 0; i < tasks.length; i++){
            if(tasks[i].id === id){
                if(tasks[i].state === STATE_P){
                    tasks[i].state = STATE_C;
                } else {
                    tasks[i].state = STATE_P;
                }
                break;
            }
        }
    }
};
```

toggle로 변경하면 changeState의 상태값을 직접 파라미터로 입력받을 필요가 없다.

실제로 todo.toggle(0) 이런식으로 처리하면 0번 인덱스의 작업 상태가 변경될 것이다.

이때도 0이라고 직접 입력하는 것보다 add 함수가 id를 리턴한다면 이 id를 활용할 수 있다.

```js
var addTask = (function(){
    var id = 0;

    return function(title){
                tasks.push({
                    id: id++,
                    title: title,
                    state: STATE_P
                });

                render();
                
                return id - 1;
            };
})();
```

이제 id를 리턴할 수 있게 되었지만 id++ -> id - 1은 혼란스럽다.

```js
var addTask = (function(){
    var id = 0;

    return function(title){
                var result = id;

                tasks.push({
                    id: id++,
                    title: title,
                    state: STATE_P
                });

                render();

                return result;
            };
})();
```

이렇게 변경하면 result는 리턴을 위해 사용되는 코드이고 id는 push에서 1씩 증가한다라는 것을 조금 전 코드보다 더 명확하게 알 수 있다.

작성한 코드를 사용해보자.

```js
var taskId = todo.add('할일');
todo.toggle(taskId);
```

이렇게 사용할 수 있다.

이제 toggle은 state를 파라미터로 받지않기 때문에 state의 입력 파리미터를 검증할 필요가 없어졌다.

(파라미터가 없는 함수가 가장 좋은 함수, 1개인 함수가 2번째로 좋은 함수, 2개인 함수가 3번째로 좋은 함수다. 4번째로 좋은 함수는 없다. 어쩔 수 없어서 사용하는 것이다.)

좋은 프로그램을 만들려면 1. 기능을 구현하고 2. 사용자가 이 기능을 어떻게 사용할 지를 고민해야한다.

30분 25초