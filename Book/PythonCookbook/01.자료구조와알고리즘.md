# 01. 자료구조와 알고리즘
## 시퀀스를 개별 변수로 나누기
* 모든 시퀀스는 간단한 할당문을 사용해서 개별 변수로 나눌 수 있다.
* 변수의 개수가 시퀀스에 일치하지 않으면 에러가 난다.
* unpaking은 순환 가능한 모든 객체에 적용할 수 있다.
* 특정 값을 무시할 때는 underbar`_`를 사용한다.
```py
In [3]: data = ['abc', 1, 2, ['def']]

In [4]: _, a, b, _ = data

In [5]: a
Out[5]: 1

In [6]: b
Out[6]: 2
```

## 임의 순환체의 요소 나누기
```py
def drop_first_last(grades):
    first, *middle, last = grades
    return middle

grades = [10, 20, 30, 40, 50, 60]
middle = drop_first_last(grades)
print(middle)
```
* 갯수를 알 수 없거나 갯수가 많은 경우 `*`를 사용하여 unpacking한다.

```py
records = [
    ('foo', 1, 2),
    ('bar', 'hi'),
    ('foo', 3, 4, 5)
]

def do_foo(args):
    print([x for x in args])

def do_bar(args):
    print([x for x in args])

for tag, *args in records:
    if tag == 'foo':
        do_foo(args)
    elif tag == 'bar':
        do_bar(args)
```
* `*`을 사용한 unpacking은 길이가 일정하지 않은 튜플에 사용하면 편리하다.

```py
line = 'GUARANTEE_TYPE_CODE:SEB_TYPE_CODE:OEB_TYPE_CODE:INT_PAY_TYPE_CODE:PARTIAL_PAY_TYPE_CODE:PUB_PRV_TYPE_CODE'
first, *middle, last = line.split(':')
print(first)
print(last)
```
* 구분자로 문자열을 분리할 때도 unpacking을 사용한다.

* 사용하지 않을 다수의 element는 `*_`를 이용하여 처리한다.

```py
items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
head, *tail = items
print(head)
print(tail)

def sum(items):
    head, *tail = items
    return head + sum(tail) if tail else head
print(sum(items))
```
* 함수형 언어들은 `*`을 사용한 unpacking과 유사한 방식을 많이 가지고 있다.
* 예를 들어 list를 head와 tail로 나누는 방식도 많이 사용된다.
* 이 방식을 이용하여 재귀 함수를 작성할 수 있다.
* 파이썬은 꼬리 재귀 최적화가 되지 않으므로 이러한 방식은 잘 사용하지 않는다.

## 마지막 N개 아이템 유지
```py
from collections import deque


def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)
    

if __name__ == '__main__':
    import pdb; pdb.set_trace()
    with open('somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-'*20)
```
* code가 이해되지 않아 pdb까지 돌려봤다.
* 처음 `python`이라는 단어가 발견되면 그 이전의 5줄을 출력하고 끝내는 코드라고 생각했다. 왜?
* 코드는 주어진 파일을 읽으면서 `python`이라는 단어가 나올 때마다 이전 5줄을 출력하고 파일이 종료되면 끝난다.
* 왜 삽질을 했는지 모르겠...
* 가장 최근의 N개를 찾을 때는 deque가 적절하다.

## deque
* double-ended queue의 약자
* 덱이라고 발음한다.
* 큐의 앞과 뒤 어느 곳에서나 삽입과 삭제가 가능하다.
```py
In [7]: from collections import deque

In [8]: d = deque([10, 20, 30, 40, 50])

In [9]: d
Out[9]: deque([10, 20, 30, 40, 50])

# 오른쪽에 추가
In [10]: d.append(60)

In [11]: d
Out[11]: deque([10, 20, 30, 40, 50, 60])

# 왼쪽에 추가
In [12]: d.appendleft(0)

In [13]: d
Out[13]: deque([0, 10, 20, 30, 40, 50, 60])

# 오른쪽에 순서대로 추가
In [14]: d.extend([70, 80])

In [15]: d
Out[15]: deque([0, 10, 20, 30, 40, 50, 60, 70, 80])

# 왼쪽에 순서대로 추가
In [16]: d.extendleft([-10, -20, -30])

In [17]: d
Out[17]: deque([-30, -20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80])

# 값 삭제
In [18]: d.remove(0)

In [19]: d
Out[19]: deque([-30, -20, -10, 10, 20, 30, 40, 50, 60, 70, 80])

# 가장 오른쪽의 값 삭제
In [20]: d.pop()
Out[20]: 80

In [21]: d
Out[21]: deque([-30, -20, -10, 10, 20, 30, 40, 50, 60, 70])

# 가장 왼쪽의 값 삭제
In [22]: d.popleft()
Out[22]: -30

In [23]: d
Out[23]: deque([-20, -10, 10, 20, 30, 40, 50, 60, 70])
```

```py
In [24]: d = deque(range(5))

# 오른쪽으로 1칸 회전
In [25]: d
Out[25]: deque([0, 1, 2, 3, 4])

In [26]: d.rotate(1)

In [27]: d
Out[27]: deque([4, 0, 1, 2, 3])

In [28]: d.rotate(1)

In [29]: d
Out[29]: deque([3, 4, 0, 1, 2])

# 왼쪽으로 2칸 회전
In [30]: d.rotate(-2)

In [31]: d
Out[31]: deque([0, 1, 2, 3, 4])
```

```py
# queue의 크기를 3으로 고정
In [32]: q = deque(maxlen=3)

In [33]: q.append(1)

In [34]: q.append(2)

In [35]: q.appendleft(3)

In [36]: q
Out[36]: deque([3, 1, 2])

# 3개 추가 이후 다시 추가
In [37]: q.append(4)

# 오른쪽에 추가되면서 왼쪽 값이 삭제됨
In [38]: q
Out[38]: deque([1, 2, 4])

# 왼쪽에 데이터 추가
In [39]: q.appendleft(5)

# 왼쪽에 추가되면서 오른쪽 값이 삭제됨
In [40]: q
Out[40]: deque([5, 1, 2])
```
* 큐의 양 끝에 아이템을 넣거나 빼는 작읍은 시간복잡도 O(1)이 소요된다.
* 리스트는 O(N)이 소요되므로 리스트보다 훨씬 빠르다.

## N아이템의 최대 혹은 최소값 찾기
```py
import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums))
print(heapq.nsmallest(3, nums))

portfolio = [
   {'name': 'IBM', 'shares': 100, 'price': 91.1},
   {'name': 'AAPL', 'shares': 50, 'price': 543.22},
   {'name': 'FB', 'shares': 200, 'price': 21.09},
   {'name': 'HPQ', 'shares': 35, 'price': 31.75},
   {'name': 'YHOO', 'shares': 45, 'price': 16.35},
   {'name': 'ACME', 'shares': 75, 'price': 115.65}
]

cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
print(cheap)

expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
print(expensive)
```
* heapq모듈의 nlargest, nsmallest 함수가 N개의 최대/최소값을 찾기에 적합하다.
* key param도 사용할 수 있다.

## heapq
```py
In [42]: import heapq

In [43]: nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]

In [45]: heap = list(nums)

In [46]: heapq.heapify(heap)

In [47]: heap
Out[47]: [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]

In [49]: heapq.heappop(heap)
Out[49]: -4

In [50]: heapq.heappop(heap)
Out[50]: 1

In [51]: heapq.heappop(heap)
Out[51]: 2

In [52]: heapq.heappop(heap)
Out[52]: 2

In [53]: heap
Out[53]: [7, 23, 8, 23, 42, 37, 18]
```
* heapify()를 수행하면 heap[0]이 가장 작은 아이템이 된다.
* heappop() 함수를 실행하면 가장 작은 아이템을 팝하고 다시 heap[0]이 가장 작은 아이템이 된다.
* N을 힙의 크기라고 하면 O(log N)의 시간 복잡도가 소요된다.
* nlargest, nsmallest 함수는 찾고자 하는 아이템의 개수가 상대적으로 작을 때 사용해야 한다.
* 최대/최소값을 구하려면 min/max를 이용한다.
* N의 크기가 컬렉션 크가와 비슷해지면 우선 컬렉션을 정렬해 놓고 슬라이싱 하는 것이 더 빠르다.
```py
sorted(items)[:N]
sorted(items)[-N:]
```
