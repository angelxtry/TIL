# 01. 자료구조와 알고리즘

## 1.10 순서를 깨지 않고 시퀀스의 중복 없애기

* 시퀀스 값이 해시(hash) 가능하다면 셋과 generator를 사용해 처리

```py
def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)

data = [1, 5, 2, 1, 9, 1, 5, 10]
print(list(dedupe(data)))
```

* 해시 불가능한 타입(예를 들어 dict)의 중복을 없애려면 다음과 같이 처리

```py
def dedupe2(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)

a = [
    {'x': 1, 'y': 2},
    {'x': 1, 'y': 3},
    {'x': 1, 'y': 2},
    {'x': 2, 'y': 4},
]

print(list(dedupe2(a, key=lambda d: (d['x'], d['y']))))
print(list(dedupe2(a, key=lambda d: d['x'])))
```

* key 인자의 목적은 중복 검사를 위한 함수가 시퀀스 아이템을 해시 가능한 타읍으로 변환한다고 명시

* 파일을 읽어 들일 때 중복된 라인을 무시하려면 다음과 같이 처리

```py
with open(somefile, 'r') as f:
    for line in dedupe(f):
        ...
```

## 1.11 슬라이스 이름 붙이기

```py
items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2, 4)
print(items[2:4])
print(items[a])

items[a] = [10, 11]
print(items)

del items[a]
print(items)
```

* items[2:4] 이런 식으로 슬라이싱을 하면 매직넘버가 계속 코드에 포함되어야 한다.
* 내장 함수인 slice()는 슬라이스를 받는 모든 곳에 사용할 수 있는 조각을 생성한다.

```py
a = slice(1, 50, 2)
print(a.start)
print(a.stop)
print(a.step)

s = 'HelloWorld'
print(a.indices(len(s)))
for i in range(*a.indices(len(s))):
    print(s[i])
```

* 슬라이스의 start, stop, step으로 정보를 확인할 수 있다.
* indices(size) 메소드를 사용하면 큭정 크기의 시퀀스레 슬라이스를 매핑할 수 있다.

## 1.12 시퀀스에 가장 많은 아이템 찾기

```py
words = [
   'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
   'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
   'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
   'my', 'eyes', "you're", 'under'
]

from collections import Counter

word_counts = Counter(words)
top_three = word_counts.most_common(3)
print(top_three)
```

* Counter 객체에는 해시 가능한 모든 아이템을 입력할 수 있다.
* Counter는 내부적으로 아이템이 나타난 횟수를 가리키는 dictionary다.

```py
print(word_counts['eyes'])  # 8
print(word_counts['look'])  # 4
```

* 카운트를 수동으로 증가시키고 싶다면 단순하게 더하기를 사용한다.

```py
morewords = ['why','are','you','not','looking','in','my','eyes']
for word in morewords:
    word_counts[word] += 1
print(word_counts['eyes'])  # 9
```

* update() 메소드를 사용하여 카운트를 할 수도 있다.

```py
morewords = ['why','are','you','not','looking','in','my','eyes']
word_counts.update(morewords)
print(word_counts['eyes'])
```

* Counter 인스턴스는 여러 가지 수식을 사용할 수 있다.

```py
a = Counter(words)
b = Counter(morewords)
print(a)
# Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2, 'not': 1, "don't": 1, "you're": 1, 'under': 1})
print(b)
# Counter({'why': 1, 'are': 1, 'you': 1, 'not': 1, 'looking': 1, 'in': 1, 'my': 1, 'eyes': 1})

c = a + b
print(c)
# Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2, 'around': 2, "don't": 1, "you're": 1, 'under': 1, 'why': 1, 'are': 1, 'you': 1, 'looking': 1, 'in': 1})

d = a - b
print(d)
# Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2, "don't": 1, "you're": 1, 'under': 1})
```

* dictionary를 직접 사용해서 아이템의 개수를 세는 방식보다 Counter를 사용하는 것을 더 권장한다.

## 1.13 일반키로 dictionary 리스트 정렬

```py
rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]

from operator import itemgetter
from pprint import pprint

rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))
pprint(rows_by_fname)
pprint(rows_by_uid)
```

* operator 모듈의 itemgetter 함수를 사용한다.
* sorted() 함수에 itemgetter를 키로 전달하여 정렬한다.
* itemgetter에는 키를 여러 개 전달할 수도 있다.

```py
rows_by_lfname = sorted(rows, key=itemgetter('lname', 'fname'))
pprint(rows_by_lfname)
# [{'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
#  {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
#  {'fname': 'Big', 'lname': 'Jones', 'uid': 1004},
#  {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003}]
```

* operator.itemgetter() 함수는 rows 레코드에서 원하는 값을 추출하는 데 사용하는 인덱스를 인자로 받는다.
* 객체의 `__getitem__()` 메소드에 넣을 수 있는 모든 값이 가능하다.
* itemgetter()에 여러 인덱스를 전달하면, 생성한 호출 가능 객체가 모든 요소를 가지고 있는 튜플을 반환하고, sorted()가 튜플의 정렬 순서에 따라 결과의 순서를 잡는다.
* itemgetter()의 기능을 lambda 표현식으로 대체할 수 있다.

```py
rows_by_fname = sorted(rows, key=lambda x: x['fname'])
rows_by_lfname = sorted(rows, key=lambda x: (x['lname'], x['fname']))
pprint(rows_by_fname)
pprint(rows_by_lfname)
```

* 이 코드도 잘 동작하지만 itemgetter()를 사용한 코드의 실행 속도가 조금 더 빠르다.
* itemgetter()는 min, max에도 사용할 수 있다.

```py
print(min(rows, key=itemgetter('uid')))
print(max(rows, key=itemgetter('uid')))
```

## 1.14 기본 비교 기능 없이 객체 정렬

```py
class User:
    def __init__(self, user_id):
        self.user_id = user_id
    def __repr__(self):
        return 'User({})'.format(self.user_id)

users = [User(23), User(3), User(99)]

print(sorted(users, key=lambda x: x.user_id))
```

* 동일한 클래스 객체를 정렬해야 하는데, 이 클래스는 기본적인 비교 연산을 제공하지 않는다.
* 내장 함수 sorted()는 key 인자에 호출 가능 객체를 받아 sorted가 객체 비교에 사용할 수 있는 값을 반환한다.
* lambda를 사용하는 대신, operator.attrgetter()를 사용해도 된다.

```py
from operator import attrgetter
print(sorted(users, key=attrgetter('user_id')))
```

* attrgetter()의 속도가 조금 더 빠르고 동시에 여러 필드를 추출하는 기능이 추가되어 있다.
* dictionary의 itemgetter()를 사용하는 것과 유사하다.
* min, max도 attrgetter()를 사용할 수 있다.

## 1.15 필드에 따라 레크드 묶기

```py
rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]

from operator import itemgetter
from itertools import groupby

rows.sort(key=itemgetter('date'))
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print('  ', i)
```

* 일련의 데이터가 있고 특정 필드 값에 기반한 그룹의 데이터를 출력하고 싶다.
* itertools.groupby() 함수는 데이터를 묶는데 사용된다.
* 일단 그룹핑할 필드에 따라 데이터를 정렬하고, 그 후에 itertools.groupby()를 사용한다.
* groupby() 함수는 이터레이터를 반환한다.
* groupby() 함수는 연속된 아이템에만 동작하기 때문에 정렬 과정을 생략하면 원하는 대로 함수를 실행할 수 없다.
* 단순히 날짜에 따라 데이터를 묶어서 커다란 자료 구조에 넣고 원할 때마다 접근하려는 것이라면, defaultdic()을 사용해서 multidic을 구성하는 것이 낫다.

```py
from collections import defaultdict

rows_by_date = defaultdict(list)
for row in rows:
    rows_by_date[row['date']].append(row)
for r in rows_by_date['07/01/2012']:
    print(r)
```

* defaultdic을 사용하면 정렬 과정을 생략해도 되기 때문에 groupby() 보다 빠르다.
* 메모리 사용량은 defaultdic이 더 많다.

## 1.16 시퀀스 필터링

* 시퀀스 내부에 데이터가 있고 특정 조건에 따라 값을 추출하거나 줄이고 싶다.

```py
mylist = [1, 4, -5, 10, -7, 2, 3, -1]

print([n for n in mylist if n > 0])
print([n for n in mylist if n < 0])
```

* 가장 간단한 방법은 리스트 컴프리헨션이다.
* 이 방법에는 한 가지 단점이 있는데 입력된 내용이 크면 매우 큰 결과가 생성될 수 있다.
* 그래서 generator를 사용한다.

```py
pos = (n for n in mylist if n > 0)
for x in pos:
    print(x)
```

* 필터링 도중에 예외 처리를 해야 한다거나 다른 복잡한 내용이 들어가야 한다면 필터링하는 함수를 만들고 filter()를 사용한다.

```py
values = ['1', '2', '-3', '-', '4', 'N/A', '5']
def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False
ivals = list(filter(is_int, values))
print(ivals)
```

* filter()는 이터레이터를 생성한다.

* 리스트 컴프리헨션은 함수를 사용하여 데이터 가공도 가능한다.

```py
from math import sqrt
print([sqrt(n) for n in mylist if n >0])
```

* 필터링에는 조건을 만족하지 않는 값을 걸러 내는 것 외에도 새로운 값으로 치환하는 방식도 있다.
* 리스트에서 양수만을 찾아내는 필터링 뿐 아니라 잘못된 값을 특정 범위에 들어가도록 수정할 수 있다.

```py
print([n if n > 0 else 0 for n in mylist])
```

* 다른 필터링 도구로 순환 가능한 객체와 Boolean 셀렉터 시퀀스를 입력으로 받는 itertools.compress() 가 있다.
* compress()는 셀렉터에서 true인 요소만 골라서 반환한다.

```py
addresses = [
    '5412 N CLARK',
    '5148 N CLARK', 
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]

counts = [ 0, 3, 10, 4, 1, 7, 6, 1]

from itertools import compress
more5 = [n > 5 for n in counts]
print(more5)

print(list(compress(addresses, more5)))
```

* 주어진 조건에 만족하는지 여부를 담은 Boolean 시퀀스를 만들어 두는 것이 핵심이다.
* filter()와 마찬가지로, compress()는 일반적으로 이터레이터를 반환한다.

## 1.17 dictionary의 부분 추출

```py
from pprint import pprint

prices = {
   'ACME': 45.23,
   'AAPL': 612.78,
   'IBM': 205.55,
   'HPQ': 37.20,
   'FB': 10.75
}

over200p = {key:value for key, value in prices.items() if value > 200}
pprint(over200p)

tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
techs = {key:value for key, value in prices.items() if key in tech_names}
pprint(techs)
```

* dictionary의 특정 부분으로 다른 dictionary를 만들고 싶다.
* dictionary 컴프리헨션을 사용한다.
* dictionary 컴프리헨션을 사용하지 않고 dict() 함수와 튜플을 이용하여 처리할 수도 있다.

```py
over200 = dict((key, value) for key, value in prices.items() if value > 200)
pprint(over200)
```

* 하지만 컴프리헨션이 더 깔끔하고 속도도 빠르다.
* 두 번째 예제도 다른 방법으로 시도할 수 있다.

```py
techs2 = {key:prices[key] for key in prices.keys() & tech_names}
pprint(techs2)
```

* 이것 역시 컴프리헨션이 더 빠르다.
