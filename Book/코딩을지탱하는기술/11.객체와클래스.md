# 11장. 객체와 클래스

## 객체 지향이란

- C++ 설계자인 Bjarne Stroustrup은 class는 사용자 정의형을 만들기 위한 구조라고 설명
- 객체지향 프로그래밍이란 사용자 정의형과 상속을 사용한 프로그래밍이다라고 설명하고 있다.

- 객체 지향이란 용어의 발명자이며 Smalltalk 설계자인 Alan Kay는 다른 의견을 가지고 있다.
- 형에 반대히자는 않지만 고생하지 않는 형 시스템을 본 적이 없다.
- 객체 지향이란 상태랄 가진 객체가 메시지를 주고 받아서 커뮤니케이션하는 프로그램이다.
- 형이나 상속에 대해 다소 부정적인 입장

## 객체는 현실 세계의 모형

## 클래스란

- 적어도 C++에서는 클래스는 사용자가 정의할 수 있는 형이라고 할 수 있다.
- C++은 정적 형결정 언어이고 Ruby나 Python은 동적 형결정 언어다.
- 형이란 용어가 가리키는 것이 서로 다르다.
- 당연히 클래스가 가리키는 것도 서로 다르다.

## 변수와 함수를 합쳐서 모형을 만드는 법

- 프로그래머에겐 하나로 모아서 모형을 만들고 싶다는 목적이 있었다.
- 하나로 모으기 위한 수단에는 여러 가지가 있다.
- 클래스가 유명하지만 우선 클래스 이외의 방법에 대해 설명하도록 한다.

- 첫 번째는 모듈
  - 원래 관련된 함수를 하나로 모아두기 위한 기능
  - Perl에서는 비슷한 기능이 패키지라 불린다.
  - Perl은 객체 지향을 도입하기 위해 함수를 합쳐두기 위한 패키지와 변수를 반쳐두기 위한 해쉬를 연결하는 방식을 채택했다.

- 두 번째는 함수도 변수도 동일하게 해쉬에 넣는 방법이다.
  - JavaScript 등의 언어가 채용하고 있다.

- 세 번째는 클로저
  - 함수 실행 시의 이름 공간의 변수를 하나로 묶기 위해 사용하는 방법이다.
  - 주로 함수형 언어에서 사용되는 방법이다.

## 방법 1: 모듈, 패키지

- 이해하기 쉽게 프로그램을 설계하면 맻 개의 상호간의 연결성이 강한 그룹이 생기는 경향이 있다.
- 요소 전부가 다른 요소와 동일하게 상호 작용 하는 것보다 관련성이 강한 것을 몇 개로 묶어서 나누는 것이 이해하기 쉽다.

- Perl에는 사전(이름과 값의 대응표)을 만드는 기능이 언어 처리계 자체에 탑재되어 있다.
- Perl은 이것을 해쉬라고 부른다.

### 모듈 만으로 부족하다

- 비슷한 사물이 복수 개 있을 경우

### 별도의 데이터 저장소를 만든다

- classA, classB는 동일한 역할의 class
- 동일한 동작이 있다. 중복이다.
- 데이터는 각각 저장되어야 한다.
- 즉, 데이터를 저장할 장소를 개별적으로 복수 개 만드는 방법이 있으면 된다.

### 인수로 개별 해쉬를 전달한다

### 초기화 처리도 패키지에 넣는다

- 생성자

### 해쉬와 패키지를 연결한다

## 방법 2: 함수도 해쉬에 넣는다

- 퍼스트 클래스
  - 변수에 대입한다.
  - 함수의 인수로 전달한다.
  - 함수의 반환값으로 전달한다. 등이 가능한 값
  - 차별 대상이 아닌 일급 시민(first-class citizen)을 의미한 표현이다.
  - 예를 들어 Java, Perl, Python 등에서 문자열은 퍼스트 클래스 값이다.

- JavaScript에서는 함수도 퍼스트 클래스 값이다.

### 함수를 해쉬에 넣는다

- Perl에서 패키지였던 것이 JavaScript에서는 해쉬로 되어 있다.
- 또 다른 차이점은 외형상으로 키워드 this가 존재한다는 것.
- this는 예약어로써, 어떤 함수 my_method가 어떤 obj와 조합되어 obj.my_method()라는 형태로 호출될 때 my_method 안에서 obj를 참조하기 위해 사용한다.

### 공유하고 있는 사물을 프로토타입으로 이동한다

```js
function makeCounter() {
  return {
    count: 0,
    push: function() {
      this.count++;
      console.log(this.count + "마리");
    }
  }
}

const c1 = makeCounter();
const c2 = makeCounter();
c1.push();
c2.push();
c1.push();
```

- makeCounter가 호출될 때마다 push: function() { ... }가 실행되어 새로운 함수가 만들어진다.
- 100번 실행하면 100개의 동일한 push 함수가 만들어지는 것이다.
- 메모리나 CPU 리소수가 무한하게 있다면 문제가 없지만, 현실은 그렇지 못하다.
- 함수 push 등의 Counter 전부에서 공유되는 사물은 하나로 묶어서 개별 카운터가 그것을 참조하는 형태로 하는 것이 메모리나 시간 절약을 위해 좋다.

## 방법 3: 클로저

- 함수를 함수 안에 정의하고, 내포할 수 있는 정적 스코프가 있어서 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념이다.
- 즉, 간단한 내포 구조를 사용하여 상태 정보를 가진 함수를 만들 수 있는 것이다.

- 왜 이것을 클로저라고 부를까? 그것은 자유 변수를 포함한 식을 열린 식이라고 부르고, 그 자유 변수의 방인딩을 조합하여 해당 식을 닫고 있기 때문이다.

## 방법 4: 클래스

### specification 으로서 역할

- C++에게 있어서 클래스(=type)란 specification을 표명한 것이기도 했다.
- 즉, 클래스는 객체가 어떤 메소드를 갖고 있고, 어떤 메소드를 갖고 있지 않은가라는 specification을 선언하는 약할도 했다.
- 존재하지 않는 메소드를 호출하는 경우 에러가 발생한다.
- 이것은 Smalltalk와 C++의 가장 큰 차이이기도 하다.

- Smalltalk의 메소드 호출은 이런 이름의 메소드를 실행해줘라는 메시지를 객체에 전달하는 것이며, 그 메시지를 받은 객체가 어떤 동작(무언가를 실행할지, 에러 처리할지 아니면 무시할 것인지)을 할지는 수신 객체가 자유롭게 결정할 수 있다.
- Smalltalk 설계자이며 객체 지향이라는 용어를 발명한 Alan Kay는 이런 자유가 객체 지향의 중요한 요소라고 생각하고 있다.

### 클래스의 3가지 역할

- 1.결합체를 만드는 생성기
- 2.어떤 조작이 가능한지에 대한 사양
- 3.코드를 재사용하는 단위
