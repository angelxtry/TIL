# 75-01

* 켄트백
* 프로그램은 나만의 언어를 만들어가는 과정이다.

* 디자인 패턴을 맛보기 위해 객체간의 협력 모델
* 테이블 클래스
* 클래스만 알아야 하는 데이터를 위해 클로저 공간을 만듦
* const로 클로저를 만들 수 없으니까 익명함수를 만들어 클로저를 만들고 그 안에서 클래스를 리턴한다.

* 등장하는 용어를 말로 풀어서 정확하게 설명할 수 있는가

* 프로그램에서 개발자가 할 수 있는건 이름밖에 없다.
* 변수, 클래스명, 함수명 그리고 API 문법으로 코딩을 한다.
* 코드에서 의도를 읽어야한다.

* async 공부하자.
* 코드를 만들 때 사용하는 쪽을 먼저 만들고 그것에 대응하는 코드를 작성한다.
* Symbol로 만든 private

* 코드에 하고 싶은 말을 명시적으로 하는 훈력을 하자.
* 그 순간에 할 수 있는 내가 생각한 바를 최대한으로 표현하자.
* 주석으로 쓰지말고 최대한 코드로 작성한다.
* 주석이 보인다면 주석을 모두 코드로 바꾼다.

* Private이라고 이름붙인 Symbol은 자유변수이므로 클래스 안에서만 컨트롤 할 수 있다.

* html5의 fetch 객체

* 딱 그 순간에 작성하는 코드만 생각하자.
* 전/후는 계약으로 설정하자.

* async/await
* 비동기로 실행되고 있다.
* 표준이기 때문에 비동기가 나오면 앞으로는 무조건 사용한다.

* 모든 입력은 나를 적대한다.
* 모든 입력은 믿지 않는다.

* 해체 문법은 해체할 수 없는 객체가 입력되면 바로 종료된다.
* 이것도 일종의 shield pattern이다.

* assign 공부하자.

* 함수에게 값을 넘기는 방법은 2가지다.
* 인자로 넘기던가, 인자 외적인 것으로 넘기던가.
* 인자 외적으로 넘기기 - 전역은 너무 위험해
* 지역 변수로, 즉 context로

* 지역 변수를 사용할 것인가, 인자를 사용할 것인가
* 이것은 선택하는 것이 아니다.
* 메서드는 인스턴스의 상태를 공유하는 함수의 집합이다.
* 메서드는 인자로 보내는 것이 잘못된 것이다.
* 인자로 보낸 값은 해당 메서드에서 검증해야 한다.
* 검증이 되어 있는 값이면 더더욱 인자로 보내는 것이 아니라 컨텍스트 변수를 사용한다.
* 이미 검증이 된 값을 메서드에서 다시 검증하는 것은 중복이다.

* 생각을 코드로 바꾸는 훈련을 해야한다.
* 한국어로 의사 코드를 만들어보자.
* 의사코드에서 핵심은 할일은 그냥 적는 것이 아니라 일을 순서대로 적는 것이다.

* querySelector 공부하자.

* 에러의 3단계
* 컴파일 에러, 문법 에러 - 니가 문법을 잘못짜서 내가 도저히 이해를 못하겠다.
* 런타임 에러 - 대부분 널포인트 참조 에러
* 런타임 에러는 즉시 드러내야한다.
* 컨텍스트 에러
* 런타임 에러에 throw를 하지 않으면 컨텍스트 에러로 번진다.

* 프로그래밍 세계에서 변하지 않는 유일한 원칙
  * 프로그램은 변한다.
* 이미 작성된 복잡하고 거대한 프로그램을 어떻게 변경할 수 있을 것인가?
* 야근하는 이유
* 고객 요구 사항대로 만든다. -> 요구 사항이 바뀐다. -> 계속 프로그램을 다시 짠다. -> 기존 프로그램을 바꿀 수 없기 때문에 -> 벽돌을 시멘트로 발라 쌓으면 안된다. -> 조립되는 구조를 만들어야 한다.
* 그러려면 격리(Isolation)가 필요하다.
* 격리: 한쪽에 변화가 일어나도 다른 쪽에 변화가 일어나지 않는 것.
* 소프트웨어 공학의 상당부분은 격리 전략
* 격리 전략의 기본 -> 변화율에 따라 작성하기
* 변화율? 즉, 수정 요청이 들어오는 빈도라고 이해하면 쉽다.
* 데이터가 변경됐어요. 라는 수정 사항과 표가 마음에 안들어요. 라는 수정 사항은 발생 빈도가 다르다.
* 개발 시점에 프로그램의 변화율을 파악하는 센스가 필요하다.
* 변화의 원인과 주기별로 코드를 나눠야 한다.
* 격리를 하기 위한 실전 수칙: 강한 응집성 & 약한 의존성

* 역할의 반대말은 책임이다.
* 함수 또는 클래스가 어떤 역할을 맡았다면 그 역할에서 처리해야할 책임이 생긴다.
* 역할에 적합한지 판단하려면 이 함수/클래스가 이 책임을 져야할까? 하고 생각해보자.
* 그래서 네이밍이 중요하다.

* 우리의 고객은 나를 적대하는 초딩이다. 매일 마음이 바뀐다.
* 고객과 같은 수준이기 때문에 싸운다.
* 고객을 읽을 수 있다면 예상할 수 있다면 싸우지 않는다.

* json 데이터는 검증되지 않은 raw 데이터다.
* Loader가 json 데이터를 Render에 그대로 보낸다는 애기는 Loader는 데이터에 대해 아무 책임도 지지 않는다는 얘기다.
* 데이터의 검증은 누가해야 하는가?
* Render는 데이터를 화면에 그리는 것에만 집중하는 것이 맞다.
* 검증되지 않은 데이터를 화면에 그리다보면 문제가 발생할 소지가 높다.
* 그럼 어떻게 해야 할까?
* 검증되고 정리된 데이터를 ValueObject 줄여서 VO라고 부른다.
* 프레임워크 프로그램에서 VO라는 단어가 보이면 잘 정리된 안전한 데이터라고 생각하면 된다.

* Loader의 진정한 역할은 Render에게 데이터를 제공하는 역할이다.
* 따라서 Loader에서 Data Supply로 이름을 변경한다.

* 프로그램은 이름이 전부다.
* 이름이 바뀌었다는 얘기는 역할이 변했다는 의미다.
* 이름만 보고 역할을 판단할 수 있어야 한다.
* 그래야 프로그램을 공유할 수 있고, 리뷰할 수 있다.
* 그래서 유비쿼터스 랭귀지가 필요하다.
* 그리고 유비쿼터스 랭귀지를 이용해 함수 이름, 클래스 이름을 서로 약속해야 한다.

* 보통 생각하는 프로그램의 이미지는 알고리즘이다.
* 알고리즘이란 제어로직과 변수를 이용해 원하는 목적을 달성하는 것이다.
* 하지만 프로그램은 역할과 역할끼리 통신하는 것이라는 것도 이해해야 한다.
* 실제 프로그램은 각각의 역할을 하는 객체들이 메시지를 주고 받는 것으로 구성된다.
* 이것을 오브젝트 네트워크가 문제를 해결한다고 말한다.
* 제어가 많아질수록 중첩될수록 제어를 할 수 없게된다.
* 그래서 제어를 역할로 쪼개서 서로 통신을 하게 만들어야 한다.

* Data는 추상 클래스다.
* Data를 상속받는 JsonData, XmlData, CsvData등이 있을 수 있다.
* 자식 클래스는 부모 클래스 즉, Data 클래스에 데이터를 넣어준다.
* Render에서는 전달받은 데이터가 Data 클래스의 인스턴스인지만 확인하면 된다.
* 왜냐하면 Data 클래스에서 데이터를 만들때 충분한 검증을 모두 거쳤기 때문에 Data 클래스의 인스턴스라고 판단된 순간 더이상의 데이터 검증은 필요없다.
* 즉, 타입을 검증하는 것이다. 이런 것을 강타입 특성을 이용한 타입 프로그래밍이라고 한다.
* 클래스가 곧 타입이다.
* 객체에 타입이 존재하는 이유는 타입으로 알고리즘을 대체하기 위해서다.
* 데이터를 검증했던 알고리즘을 타입을 검사함으로써 한번에 해결했다.
* 알고리즘은 목적을 해결하기 위해 필요하다.
* 목적은 다른 말로 표현하면 역할이다.
* 똑같은 말을 다시 하면 타입이 곧 역할이다.
* 언어 자체가 런타임, 컴파일 타임 체크 모두 똑같다.
* 타입이라는 것을 이해해야 한다.
* 객체간에 통신할 때는 타입으로 통신한다.
* 즉 json이나 string이 아니라 우리가 정의한 타입, 다시말하면 VO로 통신한다.

* 복잡한 개념이란 것은 앞의 내용을 다 익히고 쌓아야 이해할 수 있는 것이다.

* Renderer와 JsonData 사이에 INFO를 주고 받는다.
* 이런 INFO를 프로토콜이라고 말한다.
* Info에서 json을 validation하고 title, header, items를 return 한다.

* Data는 return 값이 Info라는 보증이 없다.
* if(!(data instanceof Data))는 잘못된 계약이다.
* 따라서 Data가 Info를 제공한다는 것을 보증해야 한다.
* Data의 _getData가 훅 메서드다.
* JsonData는 부모에게만 data를 보낸다.

* 부모 자식 간에 템플릿 메소드 패턴을 사용했다.
* Data와 Renderer 사이에는 프로토콜을 이용하여 통신한다.

* Renderer와 자식 클래스 간에도 Info를 사용하고 있다.
* 이것은 강한 결합도에 속한다.
* Info 데이터 구조를 변경하면 Renderer와 Data에만 영향이 있는 것이 아니라 Renderer를 상속받는 모든 클래스에 영향을 준다.
* 이것을 어떻게 해결할 것인가.
