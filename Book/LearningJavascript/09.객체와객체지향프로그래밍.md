# 09. 객체와 객체지향 프로그래밍

* 배열과 마찬가지로 자바스크립트 객체 역시 컨테이너
* 두 가지 측면에서 배열과 다르다.
* 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있다.
* 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있다.
* 배열에는 순서가 있다.
* 객체에는 순서가 보장되지 않는다.
* 객체의 프로퍼티는 키(문자열 또는 심볼)와 값으로 구성된다.
* 객체의 진짜 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점이다.

## 프로퍼티 나열

## for in

```js
const SYM = Symbol();

const o = { a: 1, b: 2, c: 3,  [SYM]: 4 };

for (let prop in o) {
  if (!o.hasOwnProperty(prop)) continue;
  console.log(`${prop}: ${o[prop]}`);
}
```

* 객체 프로퍼티를 나열할 때 for in을 주로 사용한다.
* hasOwnProperty는 상속된 프로퍼티가 for in에 나타날 위험을 제거하기 위해 사용한다.
* for in 루프에는 키가 심볼인 프로퍼티는 포함되지 않는다.
* 배열에는 forEach를 사용하는 것이 더 낫다.

## Object.keys

* Object.key는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다.

```js
const SYM = Symbol();

const o = { a: 1, b: 2, c: 3, [SYM]: 4 };

Object.keys(o).forEach(prop => console.log(`${prop}: ${o[prop]}`));
```

* for in을 썼을 때와 같은 결과
* 객체의 프로퍼티를 배열로 가져온다.

```js
const o = { apple: 1, xochitl: 2, ballon: 3, guitar: 4, xylophone: 5 };

Object.keys(o)
  .filter(prop => prop.match(/^x/))
  .forEach(prop => console.log(`${prop}: ${o[prop]}`));
```

* 객체의 프로퍼티를 배열로 가져오기 때문에 배열의 다양한 메서드를 활용할 수 있다.

## 클래스와 인스턴스 생성

```js
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this._userGears = ['P', 'N', 'R', 'D'];
    this._userGear = this._userGears[0];
  }

  get userGear() { return this._userGear; }
  set userGear(value) {
    if (this._userGears.indexOf(value) < 0)
      throw new Error(`Invalid gear: ${value}`);
    this._userGear = value;
  }

  shift(gear) { this.userGear = gear; }
}

const car1 = new Car('Tesla', 'Model S');
const car2 = new Car('Mazda', '3i');
car1.shift('D');
car2.shift('R');

console.log(car1 instanceof Car);
console.log(car1 instanceof Array);
console.log(car1.userGear);
console.log(car2.userGear);
```

* 프로퍼티를 꼭 보호해야 한다면 스코프를 이용해 보호하는 WeakMap 인스턴스를 사용할 수 있다.

```js
const Car = (() => {
  const carProps = new WeakMap();

  class Car {
    constructor(make, model) {
      this.make = make;
      this.model = model;
      this._userGears = ['P', 'N', 'R', 'D'];
      carProps.set(this, { userGear: this._userGears[0] });
    }

    get userGear() { return carProps.get(this).userGear; }
    set userGear(value) {
      if (this._userGears.indexOf(value) < 0)
        throw new Error(`Invalid gear: ${value}`);
      carProps.get(this).userGear = value;
    }

    shift(gear) { this.userGear = gear; }
  }
  return Car;
})();



const car1 = new Car('Tesla', 'Model S');
const car2 = new Car('Mazda', '3i');
car1.shift('D');
car2.shift('R');

console.log(car1 instanceof Car);
console.log(car1 instanceof Array);
console.log(car1.userGear);
console.log(car2.userGear);
```

* IIFE를 써서 WeakMap을 클로저로 감싸고 바깥에서 접근할 수 없게했다.
* WeakMap은 클래스 외부에서 접근하면 안 되는 프로퍼티를 안전하게 저장한다.
* (잘 이해 안됨 ㅠ_ㅠ)

## 클래스는 함수다

* ES6에서 class 키워드를 도입하기 전까지 클래스를 만든다는 것은 곧 클래스를 생성자로 사용할 함수를 만든다는 의미였다.
* class 문법이 더 직관적이고 단순하긴 하지만 class는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐 것은 아니다.

## 프로토타입

* 클래스 인스턴스에서 사용할 수 있는 메서드는 프로토타입 메서드이다.
* 프로토타입 메서드는 Car.prototype.shift 처럼 표기한다.
* Car#shift로 표기하기도 한다.
* 모든 함수에는 prototype이라는 특별한 프로퍼티가 있다.
* 일반적인 함수에서는 프로토타입을 사용할 일이 없지만 객체 생성자로 동작하는 함수에서는 프로토타입이 매우 중요하다.

* 함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때다.
* new 키워드로 만든 새 객체는 생성자의 prototype 프로퍼티에 접근할 수 있다.
* 객체 인스턴스는 생성자의 prototype 프로퍼티를 `__proto__` 프로퍼티에 저장한다.
* 프로토타입에서 중요한 것은 동적 디스패치라는 매커니즘이다.
* 디스패치는 메서드 호출과 같은 의미다.
* 객체의 프로퍼티나 메서드에 접근하려 할 때 프로퍼티나 메서드가 존재하지 않으면 자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾는다.
* 클래스의 인스턴스는 모두 같은 프로토타입을 궁유하므로 프로토타입에 프로퍼티나 메서드가 있다면 해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근할 수 있다.

* 인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있다.
* 자바스크립트는 먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문이다.

```js
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this._userGears = ['P', 'N', 'R', 'D'];
    this._userGear = this._userGears[0];
  }

  get userGear() { return this._userGear; }
  set userGear(value) {
    if (this._userGears.indexOf(value) < 0)
      throw new Error(`Invalid gear: ${value}`);
    this._userGear = value;
  }

  shift(gear) { this.userGear = gear; }
}

const car1 = new Car();
const car2 = new Car();
console.log(car1.shift === Car.prototype.shift);
car1.shift('D');
car2.shift('R');
console.log(car1.shift === car2.shift);

car1.shift = (gear) => {this.userGear = gear.toUpperCase(); }
console.log(car1.shift === Car.prototype.shift);
console.log(car1.shift === car2.shift);
car1.shift('d');
console.log(car1.userGear);
```
