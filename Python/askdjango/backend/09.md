# CRUD

Model Manager

DB 질의 인터페이스를 제공

디폴트 Manager로서 ModelCls.objects가 제공

특정 모델의 전체 데이터 조회. queryset을 획득할 수 있음

`ModelCls.objects.all()`

특정 모델의 최근 10개 데이터 조회

`ModelCls.objects.all().order_by('-id')[:10]`

특정 모델의 새 row 저장

`Model.objects.create(titile="New Title")`

---

`Post.objects.all().__class__` 라고 입력하면

`django.db.models.query.QuerySet` 결과를 확인할 수 있다.

QuerySet

SQL을 생성해주는 인터페이스

Model Manager를 통해 해당 Model에 대한 QuerySet을 획득

Post.objects.all()은 SELECT * FROM post; 와 같은 SQL을 생성하여 DB에 질의를 수행

Chaining 지원: QuerySet 수행 리턴값이 다시 QuerySet

----

Jupyter Notebook을 이용하여 다음과 같이 실행해보자.

`Post.objects.all()`

```py
from django.db import connection
connection.queries[-1]
```

다음과 같은 결과를 확인할 수 있다.

```
{'sql': 'SELECT "blog_post"."id", "blog_post"."title", "blog_post"."content", "blog_post"."status", "blog_post"."tags", "blog_post"."lnglat", "blog_post"."created_at", "blog_post"."updated_at" FROM "blog_post" LIMIT 21',
 'time': '0.021'}
```

```py
Post.objects.all().order_by('-id')[10:20]
```

```
{'sql': 'SELECT "blog_post"."id", "blog_post"."title", "blog_post"."content", "blog_post"."status", "blog_post"."tags", "blog_post"."lnglat", "blog_post"."created_at", "blog_post"."updated_at" FROM "blog_post" ORDER BY "blog_post"."id" DESC LIMIT 10 OFFSET 10',
 'time': '0.001'}
```

order by와 슬라이스를 사용하면 query가 위와 같이 표현된다.

`Post??` 와 같이 입력하면 다음의 결과를 확인할 수 있다.

```
Init signature: Post(*args, **kwargs)
Source:        
class Post(models.Model):
    STATUS_CHOICES = (
        ('d', 'Draft'),
        ('p', 'Published'),
        ('w', 'Withdrawn'),
    )

    title = models.CharField(max_length=100, verbose_name = '제목',
        help_text='포스트 제목을 입력해주세요. 최대 100자 내외.')
    content = models.TextField(verbose_name='내용')
    status = models.CharField(max_length=1, choices=STATUS_CHOICES)
    tags = models.CharField(max_length=100, blank=True)
    lnglat = models.CharField(max_length=50, blank=True,
        validators=[lnglat_validator],
        help_text='위도/경도 포멧으로 입력')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
File:           e:\private\develop\askdjangostudy\winsecond\blog\models.py
Type:           ModelBase
```

Post 같은 model class의 전반적인 정보가 출력된다.

---

DB에 데이터 조회 요청(Retrieve)

QuerySet을 통한 AND 조회 조건 추가(Chaining, Lazy)

```py
queryset = ModelCls.objects.all()
queryset = queryset.filter(조건필드1=조건값1, 조건필드2=조건값2)
queryset = queryset.filter(조건필드3=조건값3)
```

queryset은 계속 새로운 queryset이 만들어진다.

모든 조건이 AND로 지정된다.

실제 데이터 row에 접근할 때 DB에 query를 보낸다.(Lazy)

```py
Post.objects.all().filter(title__icontains='소문')
```

위와 같이 조회하면 다음의 결과가 출력된다.

```
<QuerySet [<Post: Post object>]>
```

여기서 Post object가 아니라 title 등을 확인하고 싶다면 models.py에서 Post class를 수정한다.

```py
def __str__(self):
    return self.title
```

이렇게 입력 후 다시 실행해보면 다음과 같은 결과가 출력된다.

`<QuerySet [<Post: 소문으로 종합해 본 아이폰8, 10년만에 확 달라질 4가지는?>]>`

결과에 title이 제대로 출력되지 않을 경우 jupyter notebook의 kernel을 restart 한다.

```py
for post in Post.objects.all():
    print(post)
```

위의 결과는 저장된 post의 제목이 모두 출력된다.

`print(post) ==> str(post) == post.__str__()`

---

```py
import random

for i in range(1000):
    status = random.choice(['d', 'p', 'w'])
    Post.objects.create(auther='leesh', title='제목 #{}'.format(i),
                        content='테스트 내용', status=status)
```

위와 같이 실행하면 1000개의 post가 저장된다.

`Post.objects.filter(title__icontains='1')`

icontains는 ignore case contains의 약자로 대소문자를 구분하지 않고 특정문자가 포함되었는지 필터링한다.

`Post.objects.filter(title__icontains='1', title__endswith='3')`

두 조건이 AND 조건으로 처리된다.

```py
qs1 = Post.objects.filter(title__icontains='1', title__endswith='3')
qs2 = Post.object.filter(title__icontains='1').filter(title__endswith='3')
print(qs1)
print(qs2)
```

두 조건이 동일하다는 것을 확인할 수 있다.

```py
Post.objects.filter(title__icontains='1').exclude(title__endswith='3')
```

제외조건은 exclude를 사용한다.

```py
from django.db.models import Q
Post.objects.filter( Q(title__icontains='1') | Q(title__endswith='3') )
```

OR 조건은 Q를 import 하고 | 연산자를 사용한다.

---

blog.views.post_list 뷰에서 간단 검색 구현

blog/views.py 파일 수정

```py
from django.shortcuts import render
from .models import Post

def post_view(request):
    qs = Post.objects.all()

    return render(request, 'blog/post_list.html', {
        'post_list': qs,
    })
```

blog/templates/blog/post_list.html 파일 수정

```html
<body>
    <h1>Django Study</h1>
    <ul>
    {% for post in post_list %}
        <li>
            {{ post.id }}
            {{ post.title }}
            <small>at {{ post.updated_at }}</small>
        </li>
    {% endfor %}
    </ul>
<body>
```

이렇게 하면 blog 페이지에 Post 객체의 항목이 모두 출력된다.

검색 기능을 추가하자.

```html
<form action="" method="get">
    <input type="text" name="q" value="{{ q }}" />
    <input type="submit" value="검색" />
</form>
```

blog/views.py

```py
from django.shortcuts import render
from .models import Post

def post_view(request):
    qs = Post.objects.all()

    q = request.GET.get('q', '')
    if q:
        qs = Post.object.filter(title__icontains=q)
    
    return render(request, 'blog/post_list.html', {
        'post_list': qs,
        'q': q,
    })
```

간단 검색 기능 구현 완료

