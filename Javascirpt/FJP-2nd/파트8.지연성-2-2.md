# 파트8. 지연성-2-2

## L.flatten

```js
log([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);
```

이렇게 중첩된 배열이 있을 때 중첩을 모두 풀어 하나의 배열도 만드는 함수가 L.flatten이다.

이터러블인지 판단하는 함수가 필요하다.

```js
const isIterable = a => a && a[Symbol.iterator];
```

`a[Symbol.iterator]`가 있으면 return 되고 없으면 undefined가 return 된다.
아무 값도 안들어오는 상황 같은 예외를 피하기 위해 `a &&`를 붙여준다.

```js
L.flatten = function *(iter) {
  for (const a of iter) {
    if (isIterable(a)) {
      for (const b of a) yield b;
    }
    else yield a;
  }
};

var it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);
log(it.next());
log(it.next());
log(it.next());
log(it.next());
log(it.next());
log(...it);
```

`L.flatten`은 지연 평가를 하기 때문에 다음과 같은 코드도 효율적으로 동작한다.

```js
var it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);
log(take(5, it));
```

`L.flatten`이 있으면 즉시 평가하는 flatten도 쉽게 만들 수 있다.

```js
const flatten = pipe(L.flatten, takeAll);
log(flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]));
```

`yield *`을 활용하면 다음과 같이 코드를 변경할 수 있다.

```js
L.flatten = function *(iter) {
  for (const a of iter) {
    if (isIterable(a)) yield *a;
    else yield a;
  }
};
```

`yield *iterable`는 다음과 같다.

```js
for (const val of iterable) yield val;
```

## L.deepFlat

`yield *`을 활용하여 `L.deepFlat`을 구현할 수 있다.

```js
L.deepFlat = function *f(iter) {
  for (const a of iter) {
    if (isIterable(a)) yield *f(a);
    else yield a;
  }
};

var it = L.deepFlat([1, [2, [3, [4], [5, 6]]]]);
log(...it);
```

## L.flatMap

flatMap은 flat을 하면서 map을 동시에 처리한다.
JavaScript 내장 함수인 flatMap은 다음과 같이 동작한다.

```js
log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a));
```

flatMap의 정확한 사용법이나 best case 같은 것을 잘 모르겠다.
나중에 꼭 찾아보자.

```js
log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a.map(a => a * a)));
```

이렇게 사용할 수도 있다.

flatMap은 map을 한 후에 flatten을 한 것과 동일하다.

```js
log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));
```

이 방식은 flatten을 하기 전에 배열 전체를 순회하면서 새로운 배열이 생성되고, flatten을 하면서 다시 한번 배열 전체를 순회한다.
flatMap을 사용하면 이 부분이 한번에 처리되면서 좀 더 효율적으로 동작한다.
