# 1. 타입과 값

## 7가지 내장 타입으로 바라보기

* 자바스크립트에는 7가지 내장 타입이 있습니다.

1. null
2. undefined
3. boolean
4. number
5. string
6. object
7. symbol

* 위 타입은 다시 크게 두 가지로 나눌 수 있습니다.
* 객체와 객체가 아닌 것입니다.
* 위 7가지 타입에서 객체 object 를 제외한 모든 값은 원시 값이며
* 원시 값의 경우 인자로 전달하거나 할당할 때 항 상 값 복사가 이루어지고
* 객체의 경우는 항상 레퍼런스 사본을 만듭니다.
* 이것이 자바스크립트에서 불변성을 다루는 기초가 된다.

* array는 타입이 아니라 값이다.

```js
const log = console.log;
var a = 10;
var b = a;  // 값 복사
a = 20;
console.log(b);  // 10

// var o1 = { a: { b: 10 } };
var o1 = { a: 10 };
var o2 = o1;
o2.a = 20;
console.log(o1);  // 20
```

* 원시타입과 객체의 전달/할당이 위와 같이 이루어지는 것을 잘 인지하고 다루는 것이 중요합니다.
* 이는 자바스크립트로 함수형 프로그래밍을 할 때 중요하며, 특히 불변성을 다루는 기초가 됩니다.

## 자바스크립트에서의 객체

* 자바스크립트에서의 Array, Map, WeakMap, Set, WeakSet, Promise 등은 모두 object의 하위 타입입니다.

```js
log(typeof {});  // "object"
log(typeof []);  // "object"
log(typeof new Map);  // "object"
log(typeof new Set);  // "object"
log(typeof new Promise(a => a));  // "object"
```

## JSON 데이터 타입

* javascript의 타입과 JSON의 타입은 약간 다르다.
* undefined가 없다는 것은 꼭 기억해야 한다.

* [JSON 데이터 타입](https://www.json.org/json-ko.html)은 다음과 같습니다.

* string
* number
* object
* array
* true, false, null

* JSON은 경량의 DATA 교환 형식이면서, 현대 프로그래밍에서 가장 많이 사용되는 DATA 교환 언어입니다.
* 위 값에 해당하지 않는 모든 값은 JSON으로 직렬화가 불가능합니다.
* 예들 들면 undefined도 JSON으로 직렬화할 수 없습니다.

* JSON을 string으로 만들어야 통신할 수 있다.

```js
JSON.stringify(undefined);
// undefined <- JSON String이 된 것이 아니라 함수가 실패하여 undefined가 리턴 된 것

JSON.stringify({ a: undefined });
// "{}"

JSON.stringify([undefined]);
// [null]

JSON.stringify({ a: 1, b: undefined});  // { "a": 1 }
```

* Map이나 Set 역시 JSON으로 직렬화할 수 없습니다.

```js
JSON.stringify(new Set([1, 2, 3]));
// {}

JSON.stringify(new Map[['a', 1]]);
// {}

// Set이나 Map을 미처 구현하지 못한 것이 아니라 구현하지 않은 것이다.
```

* 이처럼 자바스크립트에서는 JSON으로 직렬화할 수 있는 값과 그렇지 않은 값으로 나누어 데이터를 바라볼 수 있습니다.

## Iterable, Iterator

* ES6에는 Iterable/Iterator에 대한 프로토콜이 있고, 그것은 ES6에서 매우 중요합니다.
* 자바스크립터에서 Iterable, Iterator, Symbol.iterator, Generator 둥은 자바스크립트의 `for...of` 문이나 전개 연산자 등과 사용됩니다.
* 이것들은 ES6에서 함수형 프로그래밍을 하는 것에 있어서도 아주 중요한 역할을 합니다.
* ES6의 String, Array, Map, Set 등은 아래와 같이 사용하도록 Symbol.iterator 프로퍼티를 가진 객체입니다.

* iterable이 무엇인지 아는 것이 중요하다.

```js
for (const v of [1, 2, 3]) console.log(v);
```

* 이 코드를 array라서 실행된다고 생각하지 말고 Symbol.iterator라서 실행된다는 것을 알아야한다.

```js
console.log([...[1], ...[2, 3]);

for (const v of 'ABC') console.log(v);
```

* 위 코드도 마찬가지로 Symbol.iterator가 구현되어 있다.

```js
console.log([...'ABC']);  // ["A", "B", "C"]
```

```js
const obj = {
  a: 1,
  b: 2
};
for (const v of obj) console.log(v);
```

* 위 코드는 iterable이 아니라는 에러가 발생한다.

```js
const obj = {
  a: 1,
  b: 2,
  [Symbol.iterator]: function() {
    return {
      next: function() {
        return {
          value: 1,
          done: true
        }
      }
    };
  }
}
for (const v of obj) console.log(v);
```

* 코드를 이렇고 고치고 실행해보면 일단 에러는 발생하지 않는다.
* for...of는 일단 Symbol.iterator를 찾는다.
* 만약 Symbol.iterator가 있다면 for...of는 다음과 같이 바뀐다.

```js
for (const v of obj[Symbol.iterator]()) console.log(v);
```

* Symbol.iterator는 iterable을 return 하는 함수다.
* iterable은 next를 가지고 있고 next는 함수이어야 한다.
* next는 실행했을 때 value, done을 가지는 객체를 return 해야 한다.

```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      cur: 0,
      next: function() {
        if (this.cur > 5) return { value: undefined, done: true }
        return {
          value: this.cur++,
          done: false
        };
      }
    };
  }
};

for (const v of obj) console.log(v);
```

* 위와 같이 실행하면 0 부터 5까지 출력된다.
* 이것이 iterable의 조건이다.

```js
const iter = obj[Symbol.iterator]();

console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
```

* 이렇게 실행할 수도 있다.

```js
console.log([...obj]);
// [0, 1, 2, 3, 4, 5]
```

* obj는 iterable을 구현했기 때문에 전개연산자도 사용 가능하다.

## Symbol.iterator

### ES6의 Iterable/Iterator 프로토콜 맞추기, 그리고 Generator

* 자바스크립트에서 `for...of`나 전개 연산자(`...`)와 잘 동작하려면 `Symbol.iterator`를 잘 사용해야 합니다.

1. iterable은 `iterable[Symbol.iterator]();` 메서드를 가져야하고, 결과는 iterator 여야 합니다.
2. iterator는 `iterator.next()` 메서드를 가져야하고, 결과는 `{ value: something, done: true/false }` 여야 합니다.
3. iterator도 `iterator[Symbol.iterator]();`를 갖도록 하고, `iterator[Symbol.iterator]() == iterator`라면 더욱 잘 만들어진 iterator라고 할 수 있습니다.
4. 자바스크립트의 내장 iterables의 iterator를 리턴하는 메서드를 실행하여 얻은 iterator는 모두 `iterator[Symbol.iterator]() == iterator`와 같은 규약을 지키고 있습니다.
5. Generator를 통해 만든 iterator 역시 `iterator[Symbol.iterator]() == iterator`를 지킵니다.

* 3, 4, 5를 잘 응용하면 for...of 와 잘 동작하는 것을 넘어, 데이터 순회에 대한 매우 재밌고 새로운 해법들을 만들 수 있어 매우 중요합니다.

```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      cur: 0,
      next: function() {
        if(this.cur > 5) return { value: undefined, done: true }
        return {
          value: ++this.cur,
          done: false
        }
      },
      [Symbol.iterator]: function() {
        return this;
      }
    }
  }
};

function *reverseIter(arr) {
  var l = arr.length;
  while (l--) yield arr[l];
}

const iter1 = reverseIter([1, 2, 3]);
const.log( iter1[Symbol.iterator]() == iter1 );
const.log( iter1[Symbol.iterator]() == iter1 );
const.log( iter1[Symbol.iterator]() == iter1 );
for (const v of iter1) console.log(v);

const iter2 = obj[Symbol.iterator]();
```

```js
function *gen() {
}

console.log(gen());
```

* 일단 gen()을 출력해보면 일반 함수와 다른 값이 출력된다.

```js
function *gen() {
  yield 1;
  yield 2;
  yield 3;
  yield 5;
}

const iter2 = gen();
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
```

* 이것은 함수를 실행해 놓고 멈추는 것과 비슷한 역할을 한다.

```js
for (const v of gen()) console.log(v);
```

* 위에서 구현현 iterable한 것을 쉽게 구현할 수 있다.

```js
function *gen(len) {
  var i = -1;
  while (++i < len) yield i;
}

for (const v of gen(5)) console.log(v);
```

* generator를 실행한 결과는 iterable이다.

```js
console.log([...gen(5)]);
console.log([...gen(5), ...gen(10)]);
```

* generator는 지연평가 된다.
* 위 코드에서 ... 이 없었다면 gen(5) 같은 코드는 평가되지 않은 상태로 존재한다.

* 뒤에서 부터 역으로 순회하기

```js
for (const v of [1, 2, 3].reverse()) console.log(v);
```

* javascript의 reverse는 객체를 하나 더 만든다.
* for...i 를 사용하는 것이 성능이 더 좋지 않을까?

```js
function *reverseIter(arr) {
  var l = arr.length;
  while(l--) yield arr[l];
}

console.log(reverseIter([1, 2, 3]));
```

* reverseIter는 generator이기 때문에 값이 출력되지 않는다.
* 즉, 이 순간에는 배열 복사 등으로 메모리가 추가로 필요하지 않는다.

```js
const iter3 = reverseIter([1, 2, 3]);
console.log(iter3.next());
console.log(iter3.next());
console.log(iter3.next());
console.log(iter3.next());

for (const v of reverseIter([1, 2, 3])) console.log(v);
```

* array의 reverse 함수보다 효율적인 reverseIter를 만들었다.
* 하지만 reverseIter에서 index를 사용하는 등 오류를 발생시킬 여지가 남아있다.

* generator를 사용하면 next를 직접 구현할 일을 별로 없다.
* 하지만 next를 꼭 알고 있어야 한다.

----

```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      cur: 0,
      next: function() {
        if (this.cur > 5) return { value: undefined, done: true }
        return {
          value: this.cur++,
          done: false
        };
      }
    };
  }
};

function * reverseIter(arr) {
  var l = arr.length;
  while (l--) yield arr[l];
}

const iter1 = reverseIter([1, 2, 3]);
for (const v of iter1) console.log(v);

const iter2 = obj[Symbol.iterator]();
for (const v of iter2) console.log(v);
```

* generator인 iter1은 값이 제대로 출력된다.
* iter2는 다음과 같은 에러 메시지가 출력된다.

```cmd
Uncaught TypeError: iter2 is not iterable
```

```js
const iter1 = reverseIter([1, 2, 3]);
console.log( iter1[Symbol.iterator] );
console.log( iter1[Symbol.iterator]() === iter1 );
console.log( iter1[Symbol.iterator]() === iter1 );
console.log( iter1[Symbol.iterator]() === iter1 );
console.log( iter1[Symbol.iterator]() === iter1 );
for (const v of iter1) console.log(v);

const iter2 = obj[Symbol.iterator]();
console.log( iter2[Symbol.iterator] );  // undefined
for (const v of iter2) console.log(v);
```

* iter1은 `iter1[Symbol.iterator]`가 존재한다.
* 그리고 `iter1[Symbol.iterator]() === iter1`는 항상 true다.
* 그에 반해 iter2는 `iter2[Symbol.iterator]`가 없다.

```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      cur: 0,
      next: function() {
        if (this.cur > 5) return { value: undefined, done: true }
        return {
          value: this.cur++,
          done: false
        };
      },
      [Symbol.iterator]: function() {
        return this;
      }
    };
  }
};
```

* `[Symbol.iterator]`가 return하는 함수에 다시 `[Symbol.iterator]`를 정의하고 this를 return하도록 했다.
* 이렇게 구현하면 iter2도 iterator가 된다.

```js
function go(a, ...fs) {
  var b = a;
  var iter = fs[Symbol.iterator]();
  return function recur(b) {
    for (const f of iter) {
      b = f(b);
      if (b instanceof Promise) return b.then(recur);
    }
    return b;
  } (b);
}
```

* 이전에 작성했던 go 함수다.
* iter라는 변수에 `fs[Symbol.iterator]()`를 넣었다.
* 이 코드가 없었다면 이 함수는 무한 루프에 빠진다.
* recur는 클로저이고 클로저가 참조하는 iter는 계속 같은 값이 아니다.

----

```js
var users = {
  cid1: { id: 1, name: '' },
  cid2: { id: 2, name: '' },
  cid3: { id: 3, name: '' },
};

var users2 = [
  { id: 1, name: '' },
  { id: 2, name: '' },
  { id: 3, name: '' },
];
```

* 데이터가 상당히 많다고 가정할 때 user가 user2보다 낫다.
* 왜냐하면 id:2인 항목을 가져오려면 user2는 배열을 돌아야 한다.
* user는 user.cid2 로 바로 선택할 수 있다.

```js
for (const u of Object.values(users)) console.log(u.name);
```

* 이렇게 하면 user를 순회할 수 있다.
* 하지만 순회하기 전에 동일한 크기의 배열을 만들고 순회한다.

```js
console.log(
  [...Object.values(users), {id:6, name: 'HH'}]
);
```

* 이런 것도 동일하다.
* 일단 동일한 크기의 배열을 만들고, 전개 연산자를 이용하여 배열을 풀고 id: 6을 추가한다.

## 47:00
