# 01 design pattern & view pattern

## warming up

코드를 어떻게 사용하지?
여기에 초점을 두고 개발하자.

```js
const Table = (_=>{
  const Private = Symbol();
  return class{
    constructor(parent){

    }
    load(url){

    }
    render(){

    }
  }
})();
const table = new Table("#data");
table.load("75_1.json");
```

런타임 언어는 throw를 써야한다.
디버그 버전에서는 error 함수를 만들어서 throw
릴리즈 버전에서는 console.log를 이용

dom 객체에 대한 조사는 실제로 필요한 단계까지 미뤄라.

절차형 프로그래밍은 procedure를 의미한다.
이것은 A -> B -> C 순서로 진행되는 것을 의미하는 것이 아니다.
procedure는 함수를 의미한다.

---

map과 reduce

이중 for 같은 거 사용하지 말고 최대한 추상화된 언어에서 지원하는 자체 함수를 사용하라.

자기 할 일만 잘 하게 하면 실수가 생길 여지가 적어진다.
이것이 디자인 패턴이다.

---

프로그래밍 세계에서 유일하게 변하지 않는 원칙
모든 프로그램은 변한다.
이미 작성된 복잡하고 거대한 프로그램을 어떻게 변경할 수 있을까?
해법은 격리(isolation)
결국 소프트웨어 공학의 상당 부분은 격리 전략이다.
이것이 소프트웨어의 유지 보수 비용을 결정하게 된다.
격리 전략의 기본은 변화율에 따라 작성하는 것이다.

수정 빈도가 다른 것들을 격리하자.
궁금: 메소드로 나누어야 하는가? 클래스로 나누어야 하는가?

변화율이란건 시간적인 대칭성이다.
변화의 원인과 주기별로 정리해보자.

실천수칙 -> 강한 응집성 & 약한 의존성

---

data load와 rendering은 테이블에 포함되지 않아도 된다.

생성시에 인자를 받는다는 것은 일회성 객체라는 의미다.
함수명 등의 이름도 중요하지만 시그니쳐를 이해할 필요가 있다.

setData 메소드와 render 메소드는 분리하는 것이 맞다.
왜 분리해야 하는가?
두 개의 용도가 다르다. 변화율이 다르다.
왜 분리했는지 설명할 수 있어야 한다.

값은 검증해서 사용해야 한다.
json은 값이다. 이것을 object로 만들어서 사용해야 한다.
object를 다른 말로 표현하면 type이라고 한다.
역할을 type으로 만들어서 표현할 줄 알아야 한다.
즉, 로직을 type으로 표현할 수 있어야 한다.

json을 JsonData라는 object로 만들어야겠다는 생각을 하는 순간 Data라는 추상 클래스가 만들어 진다는 것을 알 수 있어야 한다.

객체지향

- 내적일관성
- 대체가능성

어떻게 json인 것을 알 수 있는가.
VO를 만들어야 한다.

---

도메인이라는 것은 순수한 데이터이고 네이티브 코드와 철저하게 분리되어야 한다.
renderer와 native를 분리해야한다.

역할 분리를 제대로 했다면 객체가 역할과 책임을 가지게 된다.
