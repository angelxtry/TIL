# 08. 함수형 및 반응형 프로그래밍

## yield 문으로 제네레이터 함수를 작성하는 방법

- 제네레이터 함수의 핵심적인 장점은 복잡한 처리를 두 개의 부분으로 나눌 수 있다는 것이다.
  - 변환 또는 필터 적용
  - 처리 대상 데이터

- 일반적인 map의 정의는 다음과 같다.

```py
def map(f, coll):
  for c in coll:
    yield f(c)
```

- filter 함수는 다음과 같다.

```py
def filter(f, coll):
  for c in coll:
    if f(c):
      yield c
```

## 제네레이터식을 조합해 사용하는 방법

- 다음과 같은 두 개의 독립된 함수가 있다고 하자.

```cmd
y = f(x)
z = g(y)
```

-두 번째 함수에 첫 번째 함수의 결과를 적용하는 방식으로 두 함수를 조합할 수 있다.

```cmd
z = g(f(x))
```

- 하지만 이 방법은 함수 개수가 늘어날수록 쓰기 불편해진다.
- 코드 내의 여러 곳에서 이런 함수 쌍들을 사용하는 것은 DRY 원칙을 위반하는 것이다.
- 그 대신에 다음과 같이 합성 함수를 작성하는 것이 바람직하다.

```cmd
z = (g . f)(x)
```

- (g . f) 함수는 두 개의 함수를 한 개의 새로운 합성 함수로 합친 것이다.
- 어떤 변경이 필요할 경우, 해당 기능을 구현하는 짧은 함수를 작성한 후 합성 함수 내의 파이프라인에 적절히 삽입하면 된다.

## 데이터 컬렉션에 변환 처리를 적용하는 방법

- 제네레이터 함수를 작성할 때 일반적으로 다음과 같은 형태를 따른다.

```py
for item in collection:
  new_item = some transformation of item
  yield new_item
```

- 다음과 같은 함수가 있다.

```py
def parse_date_iter(source):
    for item in source:
        date = datetime.strptime(
            item[0],
            '%Y-%m-%d %H:%M:%S,%f')
        new_item = (date,) + item[1:]
        yield new_item
```

- 이 함수도 for를 이용한 제네레이터를 만드는 함수의 전형을 따르고 있다.

- 위 함수에서 한 개의 행에 적용되는 변환 함수를 추출한다.
- 제네레이터 함수가 아니므로 yield 문을 사용하지 않는다.

```py
def parse_date(item):
  date = datetime.strptime(
    item[0],
    '%Y-%m-%d %H:%M:%S,%f')
    new_item = (date,) + item[1:]
    return new_item
```

- 이 함수는 문장, 표현식, map() 함수, 이렇게 세 가지 방법으로 사용될 수 있다.

- 문장

```py
for item in collection:
  new_item = parse_date(item)
  yield new_item
```

- 식

```py
(parse_date(item) for item in data)
```

- map() 함수

```py
map(parse_date, data)
```

- 다음과 같이 map() 함수를 사용할 수 있다.

```py
for row in map(parse_date, data):
  print(row[0], row[3])
```

- map() 함수는 순회 가능한 데이터인 data의 각 항목에 parse_date() 함수를 적용하는 순회 가능 객체를 생성한다.
- 제네레이터식이나 제네레이터 함수를 작성하지 않아도 된다.

- map()은 더 다양한 일을 할 수 있다.

```py
def mul(a, b):
  return a * b

list1 = [1, 2, 3, 4]
list2 = [2, 3, 4, 5]

result = list(map(mul, list1, list2))
print(result)
```

- 위 처럼 두 개의 시퀀스를 다양한 연산자를 사용해 한 개의 시퀀스로 합칠 수 있다.

- zip() 내장 함수처럼 동작하는 맵을 만들 수도 있다.

```py
def bundle(*args):
  return args
result = list(map(bundle, list1, list2))
print(result)

result1 = list(zip(list1, list2))
```

- 위 코드에서 map()과 zip()의 결과는 동일하다.
