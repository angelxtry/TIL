# 05. C# 1.0

## 5.1 문법 요소

### 5.1.1 구문

#### 5.1.1.1 전처리기 지시문

* C#의 전처리기 지시문(preprocessor directive)은 특정 소스코드를 상황에 따라 컴파일 과정에서 추가/제거하고 싶을 때 사용한다.

```cs
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            string txt = Console.ReadLine();
            if (string.IsNullOrEmpty(txt) == false)
            {
                Console.WriteLine("사용자 입력: " + txt);
            }
        }
    }
}
```

* Console.RealLine 메서드는 엔터키가 눌릴 때까지의 키보드 입력을 받는 역할을 한다.
* string.IsNullOrEmpty 메서드는 인자로 들어온 string 객체가 null이거나 빈 문자열("")이면 true, 아니면 false를 리턴한다.

```cs
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            string txt = Console.ReadLine();
            if (string.IsNullOrEmpty(txt) == false)
            {
                Console.WriteLine("사용자 입력: " + txt);
            }
#if OUTPUT_LOG
            else
            {
                Console.WriteLine("입력되지 않음");
            }
#endif
        }
    }
}
```

* `#if/#endif` 전처리기 지시문을 사용하면 해당 전처리 상수(OUTPUT_LOG)가 정의되어 있으면 해당 소스코드를 포함하여 컴파일하고, 정의되어 있지 않으면 컴파일 과정에서 제거한다.
* Solution Explorer에서 프로젝트를 선택 -> 마우스 우클릭 -> Properties -> Build tap -> Conditional compilation symbos -> OUTPUT_LOG를 입력한다.
* `#define`, `#undef` 등도 있다.

```cs
# define __X86__
# define OUTPUT_LOG

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
#if OUTPUT_LOG
            Console.WriteLine("OUTPUT_LOG가 정의됨");
#else
            Console.WriteLine("OUTPUT_LOG가 정의안됨");
#endif

#if __X86__
            Console.WriteLine("X86 정의됨");
#elif __X64__
            Console.WriteLine("X64 정의됨");
#else
            Console.WriteLine("정의안됨");
#endif
        }
    }
}
```

* `#define/#undef` 문은 반드시 소스코드보다 먼저 작성해야 한다.
* using문 다음에 작성하면 컴파일 오류가 발생한다.

#### 5.1.1.2 지역 변수의 유효 범위

* 지역 변수의 유효 범위는 변수를 포함하고 있는 블록과 일치한다.
* 중첩된 블록의 경우 부모 블록은 자식 블록의 유효 범위를 포함한다.

```cs
class Program
{
    static void Main(string[] args)
    {
        int i = 5;
        {
            int i = 10;  // 컴파일 오류 발생
        }
    }
}
```

* 같은 수준의 블록에서는 서로의 유효 범위를 넘어서지 않는다.

```cs
class Program
{
    static void Main(string[] args)
    {
        {
            int i = 10;
        }
        {
            int i = 20;
        }
    }
}
```

#### 5.1.1.3 리터럴에도 적용되는 타입

* 코드 내에서 사용되는 리터럴도 그에 해당하는 타입이 적용된다.
* 숫자 5는 int 형의 인스턴스이고 숫자 5를 통해서도 System.Int32 타입의 멤버를 사용할 수 있다.
* 문자열도 마친가지다.

```cs
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(5.ToString() + 6.ToString());
        Console.WriteLine("test".ToUpper());
    }
}
```

#### 5.1.1.4 특성 attribute

* 소스코드에 작성된 주석은 소스 파일에만 존재할 뿐, 컴파일러에 의해 빌드된 후 생성되는 EXE/DLL 파일에는 남지 않는다.
* 닷넷의 어셈블리 파일에는 해당 어셈블리 스스로를 기술하는 메타데이터가 포함되어 있다.
* 어셈블리 내에서 구현하고 있는 타입, 그 타입 내에 구현된 멤버 등의 정보가 메타데이터에 해당한다.
* 특성은 메타데이터에 함께 포함되며, 원하는 데이터를 보관하는 특성을 정의하여 사용할 수 있다.
* 특성 자체도 클래스다.
* `[Flags]` 특성은 FlagsAttribute라는 클래스다.

#### 사용자 정의 특성

* 특성은 System.Attribute를 상속받았다는 점을 제외하면 일반 클래스와 동일하다.
* 관례상 특성 클래스의 이름에는 Attribute라는 점미사를 붙인다.

```cs
class AuthorAttribute : System.Attribute{}

[AuthorAttribute]
class Dummy1 {}

[Author]  // Attribute 접미사 생략 가능
class Dummy1 {}

[Author()]  // new Author(); 와 동일. 생성자를 표현.
class Dummy1 {}
```

* 특성 클래스에 매개변수가 포함된 생성자를 추가할 수도 있다.
* (생략)

### 5.1.2 연산자

#### 5.1.2.1 시프트 연산자 shift

* 
