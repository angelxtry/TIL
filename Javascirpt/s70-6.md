# s70 마지막 강의

context 컨텍스트

문맥?

컨텍스트를 설명할 수 없다면 고급 프로그래밍을 할 수 없을 수도 있다?

공통, 교집합, 공유, 약속, 동의

공유

하나의 context가 존재하는데 여럿이 함께 공유하여 사용한다.

누가? 메소드들

무엇을? 상태

객체지향 프로그래밍에서 context란 메소드들이 공유하는 상태

이 상태를 다른 말로 표현하면 인스턴스라고 할 수 있다.

인스턴스는 context인가?

인스턴스를 여러 개 만들면 context가 여러개 생기는 건가? 

인스턴스 레벨에서는 두 질문 다 맞다.

하지만 클래스 레벨에서는 인스턴스는 context가 아니다.

클래스는 설계의 단계이고 인스턴스는 메모리에 실제한다.

클래스는 아직 인스턴스로 실체화 되지 않았지만 만약 인스턴스가 생성된다면 이렇게 될 것이라고 가정하여 작성한다.

절차지향 프로그래밍에서는 가정이 없다.


class A{
    method {
        this.a +=3;
    }
}

this는 아직 실체화되지 않았다. 현재 메모리에 존재하는 것이 아니라 미래에 이러한 context가 생길 것이라고 가정해 놓은 것이다.

왜 이렇게 작성할까?

재사용 때문이다.

a += 3

a에 3을 더하는 코드다. 이 코드를 재활용하여 b += 3이라고 쓸 수 있는가?

없다.

이것을 개선하려면 함수가 필요하다.

funtion (x) {
    return x + 3;
}

하지만 a = k(a)라고 한다면 이것은 단순한 재할당이다.

a가 단순한 값이라면 상관없다. 하지만 a가 객체일 경우 재할당을 한다는 것은 완전히 다른 객체를 생성한다는 의미가 된다.

a = { v; }

a는 object다. 

a.v = 3;

b.v = 3;

이런식으로 코드를 작성하면 코드를 재활용할 수 없다.

코드를 재사용하려면 함수를 만들어야 한다.

k = function(x){
    x.v += 3;
}

이 함수를 함수라고 판단할 수 있을까?

아니다. 함수가 아니다. 리턴을 하는 것이 아니라 내부에서 값을 바꾼다.

이것은 프로시저다.

우리가 객체를 사용하는 이유는 캡슐화, 은닉 등의 이유다.

다시말해 스코프를 한정지어서 변수들을 그룹지어 사용하길 원한다.

앞에서도 얘기했지만 함수가 객체에 속한 변수들의 값을 바꿔버린다면 우리는 객체의 변화를 따라가기가 어렵다.

객체를 변화시키는 함수는 객체에 속해있는 메소드로 만든다.

이 메소드들이 공유하는 자원을 context라고 부른다.

위 함수의 로직은 context를 수정하는 로직으로 변경된다.

클래스 입장에서 보면 특정 변수에 적용되었던 알고리즘을 컨텍스트에 적용하는 것이다.

로직이 context에 적용되도록 수정하면 new를 이용하여 인스턴스를 여려개 만드는 것이 가능해진다.

함수는 순수함수와 비순수함수로 나눌 수 있다.

우리가 지향해야 하는 순수함수는 인자와 지역변수만을 사용하는 함수다.

비순수함수는 인자와 지역변수 외에 외부 상태에 의존하는 함수다.

외부 상태에 의존하는 함수는 쓸모가 없다. 

그래서 특정한 외부상태를 만들고 그 상태에만 의존하는 함수를 만들어서 사용하는데 이런 함수를 메소드라고 부른다.

다시 말하면 메소드는 context에 일반화된 로직을 가지고 있어야 한다.

context, 지역변수, 인자외에 다른 상태에 의존적이라면 메소드가 아니다.

즉, 메소드는 context에 제네릭해야한다.

----

tasks 라는 배열에 저장되는 데이터는 title, id, state다.

tasks에는 메소드가 없기 때문에 tasks는 단지 이 값들만 가지고 있고 나머지 로직은 모두 위부에 위임하고 있다.

task를 하나의 완전한 type으로 만들고 메소드를 추가해보자.

```js
var Task = function(title){
    this._title = title;
};
```

변수명에 언더라인을 붙이는 것은 외부에서 접근하지 않겠다는 약속이다.

Task에서 외부에서 입력받아야 하는 변수는 title 하나 밖에 없다.