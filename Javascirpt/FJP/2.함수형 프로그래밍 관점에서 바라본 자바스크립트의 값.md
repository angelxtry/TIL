# 2. 함수형 프로그래밍 관점에서 바라본 자바스크립트의 값

## 목차

- 자바스크립트에서의 함수형 프로그래밍을 위한 타입과 값
- JSON 데이터 타입
- undefined
- 열거 가능한 값, 컬렉션
- 컬렉션 순회
- 불변성
- 함수와 화살표 함수
- Promise

## 자바스크립트에서의 함수형 프로그래밍을 위한 타입과 값

>> 자바스크립트에서 함수형 프로그래밍을 하기 위해서는 타입과 값에 대한 추상을 정확히 해둘 필요가 있습니다. 또한 어떠한 전략을 취할 것인지를 정의해야 합니다. 이것을 통해 다양한 함수 합성을 더 안전하게 할 수 있다는 믿음을 가질 수 있게 되며, 이것은 복잡성을 정복하고 안정성을 얻기 위한 중요한 기초가 됩니다.
>> 좋은 전략을 정하기 위해서는 먼저 자바스크립트의 내장 타입과 값들의 특징에 대해 정확히 이해하는 것이 필요하거, 그 위에 함수형 프로그래밍 언어들이 가진 전략들을 잘 취사하여 올려야 합니다. 자바스크립트는 멀티 패러다임 언어이며, 다른 함수형 언어들이 갖는 뼈대 전략이 없는 편입니다. 그렇지만 걱정하지는 않아도 됩니다. 자바스크립트는 높은 수준의 함수형 코드를 작성할 수 있게 하는 많은 기능을 지원합니다.
>> 함수형 프로그래밍에서 데이터 타입에 대한 컨셉은 크게 두 가지 계열이 있고, 하스켈과 클로저를 통해 생각해 볼 수 있습니다. 두 언어 모두 데이터 타입에 대한 명확한 철학을 지니며, 그 뼈대 위에 안전하게 합성하기, 모듈화 수준 높이기, 부수 효과를 없애거나 구분하기, 불변성 이루기, 동시성/병렬성 잘 다루기 등의 목적을 이루고 있습니다.

### 합셩이란

>> (f g)(x) = f(g(x));
>> 함수는 합성이 가능해야 합니다. 즉, 함수에서 나온 결과를 다른 함수의 매개변수로 사용하는 것이 가능해야 합니다.
>> 합성을 가능하게 하는 것 중 가장 중요한 것 -> 결국 타입과 값에 대한 추상을 정확히 하는 것
>> 하스켈을 ADT와 타입 클래스를 통해 개발자가 새로운 타입이나 함수를 만들 때에도 안전한 합성을 가능하게 하며, 모나드를 통해 부수 효과를 철저히 관리하고, 강력한 타입 시스템을 통해 견고한 프로그램을 작성할 수 있게 합니다. 클로저는 적은 종류의 데이터 구조와 추상, 그리고 영속성(Persistent data structure)을 통해 높은 다형성/불변성을 지원하여 문구(form)/함수 조합을 극대화 할 수 있게 합니다.
>> 그렇다면 자바스크립트에서의 함수형 프로그래밍에서는 어떤 전략을 취할 수 있을까요. 결론은 하스켈이나 클로저 스타일을 자바스크립트 위에 적용하는 것이겠지만 ADT, 지연성, 불변성, head, tail, 등을 엄격하게 구현할수록 불필요한 자원 사용이 많아져 성능이 떨어지게 되기도 하고, 자바스크립트만이 가진 일부 장점이 사라지게도 되고, 다른 자바스크립트 세상과의 조합성이 낮아지게 되기도 하니, 균형을 잘 찾는 것이 필요합니다.

## JSON 데이터 타입

>> JSON으로 표현 가능한 값인 string, number, object, array, true, false, null은 자바스크립트에서 다루기 매우 좋고 빠릅니다. 이 값들은 `JSON.stringify()`를 하기 위해 `myObj.toJSON()`등의 작업을 할 필요가 없어, 중첩된 데이터를 다루거나 다른 환경으로 전송하거나 저장하고 꺼내쓸 때 매우 쉽습니다. 자바스크립트는 JSON을 만들기 우해 별도의 작업을 할 필요가 없다는 특별한 장점을 가지고 있습니다.
>> JSON을 중심으로 프로그래밍을 할 경우 적은 종류의 데이터 구조와 추상 전략을 취할 수 있습니다. 이는 조합성을 높이고, 함수의 재사용성을 높일 수 있게 합니다. 만일 백엔드 프로그래밍을 NodeJS로 하고 있다면, 프론트엔드와 백엔드에서 공유할 코드도 얻을 수 있습니다.

- 클로저가 적은 종류의 데이터 구조와 추상 전략을 취한다.

```js
const json = {
  string: 'text',
  number: 1,
  object: {
    key1: 'val1',
    key2: 'val2'
  },
  array: [1, 2, 3],
  others: [true, true, null]
}
```

- 최대한 이 정도의 데이터만 사용한다.
- JSON 위주로 코딩을 하면 백엔드, 프론트의 코드를 공유할 수 있다.
- 결제에서 가장 중요한 것은 클라이언트의 값을 믿으면 안된다는 것이다.
- 클라이언트에서 sum을 해서 서버에 보내지만 서버에서도 다시 한번 sum을 해야 한다.
- sum을 하는 로직을 서버, 클라이언트가 공유할 수 있다면 개발이 훨씬 빨라질 수 있다.

## undefined

>> `undefined`는 정의되지 않은 변수나, 리턴 값이 없는 함수, 객체에 정의되지 않은 key 접근을 통해 얻게 됩니다. undefined는 DB에 저장할 수도 없고, JSON으로 전달할 수도 없습니다. 서버 API를 통해 undefined 받게 될 가능성도, undefined를 다른 컴퓨터로 전달할 방법도 없습니다. 때문에 자바스크립트 외부 세상으로 부터 전달 받을 수 있는 값이 아닙니다.
>> 런타임에서 직접 undefined를 할당하지만 않는다면 undefined를 함수를 실행해서 아무것도 찾지 못했거나, 아무것도 하지 못했을 때를 나타내는 구문자로 사용하기에 적합합니다. 실제로 이러헥 쓰이는 내장 함수나 라이브러리들이 많으며, 나머지 매개 변수의 구분자도 `undefined` 입니다.

```js
const a = {}
console.log(a.aaa);
```

- a에 없는 프로퍼티에 접근했을 때 undefined
- undefined는 런타임에만 발생한다.
- 하스켈의 nothing과 유사하다.

```js
const sub = (a = 0, b = 0) => a - b;
console.log(sub(10, 5));  // 5
console.log(sub(10));  // 10
console.log(sub(10, undefined));  // 10
```

- undefined가 구분자로 사용되었다.
- 이것이 자바스크립트 언어의 방향인 것 같다.

```js
console.log([1, 2, 3].find(a => a > 3));

console.log([1, 2, undefined, 4].find(a => !a));
console.log([1, 2, 4].find(a => !a));
```

- 첫 번째 코드의 실행 결과는 undefined다.
- 이때는 조건에 맞는 값이 없기 때문에 undefined가 출력되었다.
- 두 번째 코드의 결과도 undefined다.
- 이때는 배열안의 undefined가 조건에 맞기 때문에 출력되었다.
- 데이터로 undefined를 사용하면 결과가 없어서인지 해당 조건에 맞아서인 모호해진다.
