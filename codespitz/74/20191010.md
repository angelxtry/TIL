# sub routine chain
* call stack
    * 내가 더이상 지역변수와 인자를 기억할 필요가 없게 만들자.
    * R2를 호출한 이후를 더이상 기억하지 않게 만들자.
    * return R2
    * 꼬리재귀를 만들면 지연변수나 인자를 기억하지 않아도 되지만 return point가 남아있다.
    * 아무일도 안하는 R1의 리턴을 사용하지 않고 R2의 리턴을 바로 M에게 전달한다면?
    * 이 연쇄를 반복하면 stack을 잡을 필요가 없다.
    * 꼬리 재귀 최적화
    * 꼬리 재귀 최적화를 사용하면 메모리의 고갈을 막을 수 있다.
    * 꼬리 재귀 최적화는 언어가 지원해야 한다.
    * ES6는 구현하도록 표준이지만 safari만 구현하고 있다.

* 이 재귀함수가 스텍을 해제할 수 없는 이유는 연산 스텍때문.
* + 연산자가 문제
* 마지막에 연산식이 있다면 마지막에 return 이 있다고 하더라도 말짱 도루묵이다.
* 우리들은 알게 모르게 메모리를 쓰고 있다.
* 연산자의 좌항을 레지스터 a라고 부른다.
* 메모리를 사용하지 않고 인자를 활용하자.

* 테일리커시브를 만들려면 메모리에 대한 요구를 모두 다음 상태로 넘긴다.

* 웹브라우저가 아직 테일리커시브를 지원하지 않기 때문에 루프로 변경해야 한다.
* 재귀함수를 테일리커시브 함수로 우선 변경한다.
* 테일리커시브로 바꾸면 루프로 바꾸기 쉽다.
* 테일리커시브의 메모리 정리한 것을 루프 위의 초기값으로 만든다.
* 조건이 루프의 조건으로 들어온다.

* 지금까지는 정적함수를 배웠다.
* 컴파일 시점에 모두 정의된 함수.
* 실행 중에 함수를 만들어내지 않는다.

* 현대 언어들은 실행도중에 함수를 만들어내기도 한다.
* 클로저
    * static state 정적 함수 관계
    * 정적 함수는 지역 변수, 인자, 전역변수를 사용할 수 있다.
    * runtime state
    * 지역변수에 함수를 만들어서 집어넣었다.
    * 함수를 값처럼 변수에 대입할 수 있게 된다.
    * 함수가 곧 객체다. 즉 참조로 움직인다.
    * 이렇게 태어난 함수의 지역변수는 전역변수, 메일플로우의 지역변수, 함수내의 인자, 지역변수를 사용할 수 있다.
    * 메인플로우의 지역변수를 자유변수라고 부른다.
    * 자유변수: 루틴이 사용할 수 있는 루틴의 인자나 지역변수 그리고 전역변수를 제외한 변수
    * 클로저: 자유변수를 인식할 수 있는 공간. 즉 메인플로우 안의 루틴을 클로저라고 부른다.
        * 클로저의 자격이 있는 것은 당연히 함수 밖에 없다.
    * nested closure
        * 메인플로우와 루틴 사이에 블럭이 있다.
        * 안쪽에서는 바깥쪽의 변수를 사용할 수 있지만 바깥쪽에서는 안쪽의 변수를 확인할 방볍이 없다.
        * 역으로 설계해야한다.
        * 안쪽을 먼저 설계하고 차근차근 바깥쪽을 설계한다.
        * 어느 시점에 함수를 만드느냐 = 언제 서비스를 사용하는가
        * 반대로 생각해야 하기때문에 생각을 방해한다.
        * 중첩 클로저는 왜 쓰는건가 - 공통 서비스를 레이어화 하기위해, 수 입장에서
    * 왜 자유변수를 쓰는가
        * 이미 제공받는 서비스가 필요하기 때문에
        * 배경이 되는 서비스를 깔고 그 안쪽에 핵심 코어 로직을 만든다.
        * 클래스를 자유변수와 함수로 다 대체할 수 있다.
* shadowing
    * 클로저의 장점
    * 바깥쪽에서 안쪽을 못건드린다.
    * 하지만 안쪽에서는 바깥쪽을 다 보고 사용할 수 있다.
    * 막내가 집안의 모든 계좌와 비밀번호를 알고 있다.
    * 이런것을 막는 방법은 쉐도우 밖에 없다.
    * 안쪽에서 바깥쪽과 동일한 변수명을 만들면 바깥쪽을 못본다.
    * 쉐도우가 없으면 안쪽에서 바깥쪽을 못보게 할 수 있는 방법이 없다.

* co routine
    * r1은 세번 호출하면?
    * 루틴의 공통점
        * 호출되면 끝까지 실행된다.
        * 호출할 때마다 고유하다.
    * 코루틴
        * return 하지 않고 yield
        * flow control을 양보
        * 양보했을 때 루틴의 지역변수들은 다 살아있다.
        * 하나의 루틴이 여러번 진입할 수 있고 여러 번 빠져나갈 수 있으면 코루틴이라고 부른다.
        * 지역변수와 인자가 보존되고 있는 것이 중요하다.
        * 메모리 지속을 위해 코루틴을 쓰는 경우도 많다.
        * 객체의 메서드인 코루틴은 객체의 상태를 유지하고 있다.
        * 여러번 들락날락 하는 동안 지역변수와 인자가 유지된다.
        * 함수형에 위반일 수도 있다? 하지만 함수형
    * 동기화 vs 비동기화
        * 동기명령 - 한번에 쭉 실행되는것 - 블로킹된다.
        * 비동기화
            * 동기명령을 중간에 멈출 수 있는 suspend
            * 언어에서 suspend를 지원하지 않으면 코루틴이 성립하지 않는다.
    * function*(a)

```js
const a = {*_(){
}}
const b = a._()
```
* 코루틴을 만들려면 제네레이터가 필요하다.

* 여러번 호출해도 속성을 가지고 있는 객체의 인스턴스 같다.
* 객체지향으로 짠 것은 코루틴으로 바꿀 수 있다.
* 객체보다 배치적으로 루틴을 작성한 것이 코루틴
* 많은 객체들은 시나리오대로 흘러간다.
* 절체적인 객체의 경우 코루틴이 훨씬 더 유리하다.
* 객체를 만들면 메소드의 호출 순서를 통제할 수 없다.
* 코루틴을 호출하는 것은 다음 다음 다음
* 해당 절차는 코루틴에 숨겨져 있다.
* 절차가 중요한 작업은 객체보다 제네레이터가 낫다.

* 클래스에 대해 공부하세요.
* 왜 ES6에서는 native array를 만들 수 있는가?
* 왜 native 객체를 상속 받을 수 있는가