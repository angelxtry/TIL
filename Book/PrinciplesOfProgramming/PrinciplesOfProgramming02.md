# 프로그래밍의 정석

## 3.22 아키텍처 비기능 요구사항

> 비기능 요구사항의 관점에는 다음과 같은 것이 있다.
> 1. 변경 용이성
> 2. 상호 운용성
> 3. 효율성
> 4. 신뢰성
> 5. 테스트 용이성
> 6. 재사용성

> 아키텍처 설계 시점부터 고려되어야 할 관점이다.
> * 요구사항을 정의할 때는 각각의 관점이 어느 정도 필요해 질지를 확인한다.
> * 개발할 때는 아키텍처 설계 시점에 비기능 요구사항을 고려한 구조를 고민한다.
> * 테스트할 때는 비기능 요구사항을 충족하고 있는지를 확인한다.

> 기능 테스트는 무엇을 하는지, 즉 what에 주목한다. 비기능 테스트는 어떻게 동작하는지, 즉 how에 주목한다.

> 비기능 요구사항을 충족하려면 해당 소프트웨어에 최적인 비기능 요구사항 수준을 판변한 후에 비기능 테스트에도 합격 기준을 마련하는 것이 필요하다. 목표가 없으면 요구사항을 충족할 수 없다. 품질 측정 기준을 사용해 구체적으로 설정하기 바란다.

> 중요한 비기능 요구사항 중 하나로 보안이 있다. 정보 보안이 정식 정의는 정보의 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)을 유지하는 것이다.

> 기밀성: 허가되지 않은 사람이 정보를 사용하지 못하게 만드는 것. 암호화하여 혹시나 정보 유출이 발생하더라도 유출된 정보를 볼 수 없게 만드는 대책도 수행한다.

> 무결성: 자산이 정확함과 완점함을 보호하는 특성. 제3자의 허가되지 않은 정보 조작을 방지. 디지털 서명등을 활용

> 가용성: 인가된 개체가 요구했을 때 접근 및 사용이 가능한 특성. 장애나 바이러스에 대처하기 위해, 시스템이나 정보를 이중화하거나 백신 프로그램을 활용

## 3.23 변경 용이성
> 해당 소프트웨어를 얼마나 쉽게 개선할 수 있는가

> 수정, 확장, 재조직, 다른 플랫폼으로 이식이 용이한가
> * 보수성, 확장성, 재구축, 이식성

> 보수성: 변경을 국소화해서 다른 모듈에 부작용이 미치는 것을 최소화

> 확장성: 신규 기능 추가, 신규 버전으로 모듈 교체, 뷸필요한 기능이나 모듈의 제거 등과 같은 작업의 용이함. 모듈간의 결합도가 약해야 한다.

> 재구축: 모듈 간 관계의 재조직화. 모듈의 구현에는 영향을 미치지 않고, 모듈을 유연하게 배치할 수 있는 구조로 작성

> 이식성: 다양한 하드웨어 플랫폼, 사용자 인터페이스, 운영체제, 프로그래밍 언어, 컴파일러 등에 적합하게 작성. 시스템 라이브러리나 사용자 인터페이스 라이브러리 등 플랫폼 고유의 기능을 다루는 부분을 전용 모듈로 독립될 수 있도록 작성

> 좋은 아키텍처 설계의 핵심은 어느 붑ㄴ이 변경에 대해 높은 유연성을 지녀야 하는지, 변경이 발생하지 않는 부분은 어디인지를 파악하는 것

> 유연성을 지녀야 할 부분은 변경을 고려한 설계를 지원하는 패턴을 사용

> 유연성에만 치우치지 말고 단순함과의 균형을 고려해야 한다.

> 소프트웨어 에이징: 소프트웨어 노후화. 시간이 지날수록 자연스럽게 성능이 떨어진다는 의미
> * 설계가 유연성이 없으므로 변경 때문에 아키텍처가 파괴된다.
> * 설계가 좋다고 해도 설계를 이해하지 못하는 사람이 변경해서 아키텍처가 파괴된다.
> * 아키텍처를 이해하기가 어렵다는 이유로 무질서하게 변경이 이루어져 아키텍처가 파괴된다.
> * 업데이트가 이루어지지않거나 시대에 뒤쳐져 진부해진다.

> 소프트웨어 에이징은 막을 수없다. 속도를 늦출 수는 있다.

## 3.24 상호 운용성(Interoperability)
> 다른 소프트웨어와 정보를 주고받을 수 있는 능력. 재활용을 통해 신규 개발이 줄어들고, 개발 기간 단축, 비용 삭감 등의 효과

> 프로토콜이나 데이터 형식을 선정할 때는 업계의 표준 규격을 선택하도록 하자.

## 3.25 효율성(Efficiency)
> 리소스를 효율적으로 사용하여 적절한 성능을 내는 것
> * 시간 효율성
>   * 처리율(throughput): 일정 시간 내에 처리를 몇 건 끝낼 수 있는가
>   * 응답 시간(response time): 사용자의 입력 조작부터 응답까지 걸리는 시간
>   * 소요 시간(turnaround time): 사용자의 작업 개시로부터 요구받은 정보의 출력을 끝내기까지 걸리는 시간
> * 자원 효율성
>   * CPU 사용 시간, 메모리 사용량, 스토리지 소비량, 네트워크 전송량 등으로 측정

> 모듈 간의 직접 결합을 피하려고 모듈들 사이에 매개 모듈을 도입 - 간접화
> * 간접화를 이용해 느슨한 결합성을 유지하고 높은 보수성과 확장성, 재사용성을 확보할 수 있다.
> * 대부분의 설계 패턴에서는 기본적인 개념으로 간접화를 도입한다.
> * 간접화를 도압할 때는 효율성과의 균형을 고려해야 한다.
> * 간접화를 도입하면 처리 자체는 장황해지므로 효율성은 떨어진다.

## 3.26 신뢰성(Reliability)
> 예외적인 상확 혹은 예기치 못한 방법이나 부정한 방법으로 사용된 상황에서도 기능을 유지하는 능력
> * 결합 허용력(fault tolerance), 견고성(robustness)

> 결합 허용력
> * 정상적인 동작을 계속 유지하는 능력
> * 예외 발생에 대해 올바른 행위를 보증하고 내부적으로는 복구를 실시한다.

> 견고성
> * 부정한 사용 방법이나 입력 실수로부터 소프트웨어를 보호

> 중복(redundancy): 이중화
> 장애 완화(fail soft): 장애 발생 시 제공하는 기능을 한정하고 중요한 기능만을 제공해서 처리의 지속성을 수선시
> 장애 시 안전(fail safe): 장애 발생 시 해당 부분을 분리
> fool proof: 사용자가 잘못된 조작을 해도 안전하게 가능할 수 있도록 설계

## 3.27 테스트 용이성
> 효율적인 테스트
> * 테스트가 깊이 있고 질이 높다.
> * 적은 비용으로 빠르게 품질을 검증할 수 있다.

> 아키텍처 확정 시점부터 검증 방법에 대한 관점을 포함하여 설계

> 테스트를 쉽게 하기 위한 구조가 메인 코드가 되어도 좋다는 정도로 관점의 전환이 필요

> 모듈 간 종속 관계를 제거하는 것이 핵심이다.

## 3.28 재사용성
> 재사용하는 소프트웨어 개발
> * 프로젝트 내의 기존 모듈, 예전 프로젝트의 모듈, 각종 라이브러리 등을 이용하는 것

> 재사용을 위한 소프트웨어 개발
> * 다른 소프트웨어에서 재사용하기 위한 소프트웨어를 개발

> 난이도 3배의 법칙
> * 재사용 가능한 모듈을 만드는 작업은 단일 소프트웨어에서 사용할 모듈을 개발할 때보다 3배 어렵다는 법칙
> * 모듈 자체를 일반화해야 하고 모듈의 테스트도 일반적인 케이스로 실시해야 한다.

> 테스트 3종류의 법칙
> * 재사용 가능한 모듈은 공유하기 전에 3가지의 다른 소프트웨어로 테스트할 필요가 있다는 법칙

> 같은 문제 영역에서 몇 가지 소프트웨어를 구현하다 보면 설계가 능숙해지고, 난관을 돌파한 경험을 통해 해당 문제 영역에 특화된 프레임워크를 설계할 수 있다.

> 프레임워크는 인터페이스가 정해져 있는 허브 같은 것으로서, 프로임워크에 문제 영역의 가변적인 부분을 컴포넌트로 탈착할 수 있다. - 플러그인 설계

## 3.29 7가지 설계 원리
> 결함을 만들어 내지 않기 위해 고려해야 할, 코드 구조상의 7가지 핵심 관점

> 품질 좋은 코드를 만들기 위한 경험, 패턴.

> 코드 리뷰를 할 때 점검할 관점으로 사용한다.

> 7가지 관점이 있다.
> 1. 단순 원리
> 2. 동형 원리
> 3. 대칭 원리
> 4. 계층 원리
> 5. 선형 원리
> 6. 명증 원리
> 7. 안전 원리

> 코드 리뷰를 할 때 일정한 가치관이나 관점이 없으면 지적이 산만해진다. 참여 구성원이나 상황에 따라 관점에 누락이 생기거나 오차가 있다면 지적에 일관성이 없어지며 리뷰 자체의 품질도 안정되지 않는다. 따라서 7가지 설계 원리처럼 일관되고 핵심적인 점검 관점이 필요하다.

## 3.30 7가지 설계 원리 - 1. 단순 원리(Simplicity Principle)
> 단숨함을 중시한다.

> 복잡하고 전체적인 관련성을 중시하는 것이 아니라 국소적이고 완전성을 중시한다.

## 3.31 7가지 설계 원리 - 2. 동형 원리(Isomorphism Principle)
> 형태를 중시한다. 똑같은 것은 똑같이 다루도록 신경 쓴다.

> 어떤 모둘에서 다루는 숫자의 단위, 공개 함수의 파라미터 수, 사용 순서 등이 통일되도록 한다.

> 똑같은 것이 똑같이 표현되어 있으면 다른 것이 돋보인다. 다른 것이란 버그의 원인이 되기 쉬운 부분이다.

> 통일감 있는 코드는 가독성이 높다.

## 3.32 7가지 설계 원리 - 3. 대칭 원리(Symmetry Principle)
> 대칭성을 중시한다. 어떤 처리에 관해 대응되는 것도 함께 생각해야 한다.

> 예를 들어 어떤 플래그가 참일 때의 처리가 있다면 거짓일 때의 처리도 있어야 한다.

> 조건 분기는 오류가 생기기 쉬운 부분인데 대칭성이 사고의 프레임워크가 되어 조건 누락을 막아준다.

> 예외적인 상황을 생각해 보고 이런 상황을 최대한 제거하자. 예외적 상황은 특수한 경우이기 때문에 대칭성을 무너뜨리고 오류가 발생하기 쉬운 부분이 된다. 특수한 경우가 너무 많다면 애초에 요구사항이 제대로 정리되지 않았을 가능성이 있다.

> 명명의 대칭성도 고려한다.

## 3.33 7가지 설계 원리 - 4. 계층 원리(Hierachy Principle)
> 구조의 계층성을 중시한다.

> 계층마다 수행할 처리를 정해서 같은 종류의 처리가 다른 계층들 사이를 넘나들지 않는 것이 중요하다.

> 예를 들어 리소스를 할당했다면 같은 계층에서 리소스를 해제해야 한다.

> 하나의 계층은 추상화 수준이 같은 요소만으로 구성한다.

> 상위에서 봤을 때 하위 수준은 외부에서 바라보는 듯한 관점으로 기술한다. 상위 수준이 하위 수준을 호출하는 코드여야 이해하기 쉽다.

## 3.34 7가지 설계 원리 - 5. 선형 원리(Linerity Principle)
> 처리의 직선적 흐름을 중시한다.

> 하나의 기능은 여러 가지 다른 기능의 묶음에 의해 실현되는 선형 결합적인 것이 단순하고 좋은 구조다.

> switch 문으로 코드를 제어하거나 상태값을 무턱대고 늘리면 코드를 이해하기 어려워진다.

> 계층의 상위에서 하위를 향해 한 방향으로 흘러가는 처리의 흐름을 의식해서, 반복을 피하고 한 줄로 연결된 법한 시퀀스로 만들면 가독성이 매우 향상되고 기능 추가 등의 개선도 쉬워진다.

> 처리의 분기르 ㄹ적게 만들고 처리의 흐름을 직선적으로 읽을 수 있는 코드를 작성한다.

> 그렇게 하려면 특별한 동작을 주 처리에 섞어 작성하지 않도록 해야 한다.

## 3.35 7가지 설계 원리 - 6. 명증 원리(Clarity Principle)
> 로직의 명증성을 중시한다.

> 한눈에 봐도 분명하게 옳다고 말할 수 있는 코드를 작성해야 한다. 조금이라도 불명료한 곳이 있으면 명증해 둔다.

> 명증하는 데 수간을 가리지 않는다. 주석, 도표, 별도 문서 등 모든 방법을 동원한다.

## 3.36 7가지 설계 원리 - 7. 안전 원리(Safety Principle)
> 안정성을 중시한다.

> 있을 수 없는 조건을 굳이 고려해서 코드를 작성한다. (case-default, NULL check)

> 코드의 구현에 대해 요구사항이나 기능의 설명서는 필요조건에 불과하다. 문제가 발생했을 때 어디까지 동작해야 충분한지는 적혀 있지 않다.

## 3.37 UNIX 사상
> 17개의 원칙

## 3.38 UNIX 사상 - 1. 모듈화의 원칙
> 코드 중에 관계성이 높은 요소를 모아 모듈을 작성한다. 나아가 모듈의 인터페이스는 불필요한 것을 제거하고 단순하게 만든다.

> 이렇게 하면 어떤 기능에 관한 변경이 해당 모듈 안으로 한정된다.

## 3.39 UNIX 사상 - 2. 명확성의 원칙
> 코드를 읽을 때 이해하기 어려운 코드에 대해 해독을 3회 이상 반복해서는 안된다. 첫 번째만 예외일 수 있다. 두 번째에 똑같은 코드를 해독하게 되었다면 대책을 강구해야 한다.

## 3.40 UNIX 사상 - 3. 구성의 원칙(Rule of Composition)
> 소프트웨어는 다른 소프트웨어와 조합할 수 있도록 가능한 한 단순하게 필터로 만든다.

> 필터랑 입력으로 테이터 스트림을 받아들여 가공한 다음 다른 데이터 스트림으로 출력하는 소프트웨어를 말한다. 이때 데이터 스트림의 형식은 텍스트 형식으로 해야 좋은 설계다.

> 텍스트 스트림 인터페이스는 단순하므로 소프트웨어를 강제적으로 정보 은닉 상태로 만들어 준다.

## 3.41 UNIX 사상 - 4. 분리의 원칙(Rule of Separation)
> 메커니즘에서 정책을 분리한다.

> 정책
> * 해당 소프트웨어의 전제에 종속되는 부분
> * 코드 중에서 비교적 불안정하다.
> * 비즈니스 로직이나 사용자 인터페이스

> 메커니즘
> * 소프트웨어의 전제에 종속되지 않는 독립된 부분
> * 코드 중에서 비교적 안정적이다.

> 정책과 메커니즘이 연결되어 있으면
> * 정책이 경직되면서 사용자의 요구에 맞춰 정책을 변경하기 어려워진다.
> * 정책을 변경하려고 하면 안정된 메커니즘까지 변경해야 한다.

> 서비스계 애플리케이션
> * 프로트엔드와 백엔드로 모듈을 분할한다.
> * 통신 프로토콜을 이해하고 클라이언트의 요구사항을 받아들이는 프론트엔드가 정책
> * 실제 서비스를 수행하는 백엔드가 메커니즘

> 편집 애플리케이션
> * 편집 기능을 확장하는 모듈을 설정 파일로 구동할 수 있게 한다.
> * 확장 가능한 사용자 인터페이스가 정책
> * 편집 엔진이 메커니즘
> * 내부의 모듈 분할이 명확해지고 사용자가 자유롭게 확장할 수 있는 기능을 제공할 수 있다.

## 3.42 UNIX 사상 - 5. 단순성의 원칙
> 코드가 단순해지도록 설계

> 코드가 팽창하여 복잡해지는 상태를 거부한다. 반대로 단순한 해결 방법을 높게 평가한다.

> 다수의 기능으로 소프트웨어를 화려하게 꾸미려는 압력에 저항한다. 반대로 서로 연동하는 작은 부품으로 분할하는 방법을 찾는다.

## 3.43 UNIX 사상 - 6. 절약의 원칙(Rule of Parsimony)
> 큰 코드는 작성하지 않도록 한다. 코드의 분량이 큰 것과 코드 내부의 복잡도가 큰 것 양쪽을 모두 의미한다.

## 3.44 UNIX 사상 - 7. 투명성의 원칙(Rule of Transparency)
> 투명성
> * 소프트웨어의 동작에 관해 한눈에 봐도 무엇을 어떻게 하고 있는지를 이해할 수 있을 것

> 개시성
> * 소프트웨어 내부 상태에 관해 감시할 수 있거나 보여줄 수 있을 것

> 소프웨어의 동작을 시각화하면 디버깅이나 오류 확인이 간단해진다.

> 설계 초기 단에부터 모듈 내 변수 내용을 서식 문자열로 출력하는 메서드를 넣어 두거나 로그를 충분하게 포함시키자.

## 3.45 UNIX 사상 - 8. 안정성의 원칙(Rule of Robustness)
> 예상외의 조건에서도 적절하게 동작하는 것

> 투명성
> * 코드를 예측할 수 있어서 무엇이 일어나고 있는지를 금방 이해할 수 있는 것

> 단순성
> * 동작이 복잡하지 않아서 모든 분기 조건을 어려움 없이 설명할 수 있는 것

> 투명하고 단순한 코드를 유지하기 위해 다음 작업을 수행한다.

> 코드리뷰
> * 코드를 작성한 프로그래머가 코드의 내부 구조에 관해 올바르게 설명할 수 있어야한다.

> 특이한 입력이나 극단적으로 큰 입력에 견딜 수 있음을 검증
> * 다른 소프트웨어를 이용하여 테스트 하자.

## 3.46 UNIX 사상 - 9. 표현성의 원칙(Rule of Representation)
> 코드에서 정보를 표현할 때는 로직아 아닌 데이터에 모아 작성하는 방식으로 한다.
> * 정보를 데이터에 고정시킴으로써 로직은 읽기 쉬워지고 안정된다.
> * 자료구조를 활용하면 매우 복잡한 것이라도 간단히 모델링할 수 있다.

> 사람 입장에서 절차적인 로직은 쉽게 이해하기 힘들다. 반면에 자료구조는 복잡하 것이라도 비교적 쉽게 이해할 수 있다. 데이터는 로직보다 다루기 쉽다.

> 표현력이나 정보량을 비교하더라도 자료구조의 우위는 명확하다.

> 코드상에서 피할 수 없는 복잡한 부분이 있다면 데이터에 모으도록 한다.

## 3.47 UNIX 사상 - 10. 충격 최소의 원칙(Rule of Least Surprise)
> 사용하는 사람이 의외라고 느끼는 기분이 최소가 되도록 설계한다.

> 유사한 점이 많은 소프트웨어의 인터페이스를 모델로 삼는다.

> 예상 사용자의 특징을 고려한다.

> 언뜻 보면 비슷하지만 미묘하게 다른 상황을 피한다.
> * 소프트웨어의 인터페이스뿐만 아니라 프로그래밍의 인터페이스에도 해당한다.

## 3.48 UNIX 사상 - 11. 침묵의 원칙(Rule of Silence)
> 표시를 최소한으로 줄이고 과묵하게 작업을 수행하게 한다.

> 중요한 정보만 출력하고 출력에 내부 동작과 관련된 정보가 혼재되지 않도록 만들자.

> 실제로 발생한 오류만을 표준 오류 출력으로 표시하고 그 밖에 요구되지 않은 데이터는 일체 출력하지 않도록 한다.

> 디버깅 목적으로 진행 상황에 관해 메시지를 표시하고 싶다면 장황하게 switch문을 만들고, 일반적인 상황에서는 사용되지 않게 비활성화 한다.

## 3.49 UNIX 사상 - 12. 복구의 원칙(Rule of Repair)
> 소프트웨어 동작 중 오류 복구에 실패했다면 처리를 계속해서는 안된다.

> 오류가 발생했을 때는 가능하면 조기에 요란하게 통지하자.

> 소프트웨어의 입력과 출력에 관해 '받아들일 때는 자유주의로, 내보낼 때는 보수주의로'라는 사고방식이 있다.
> * 입력에 관해서는 잘못된 혀식이라도 가능한 한 적절한 의미를 끄집어내서 관용적으로 받아들여야 하고
> * 출력에 관해서는 엄밀히 따져 명료하고도 정확한 데이터를 송출해야 한다는 의미다.

> 관용적이어야 할 것은 '동작의 사양'이지 '사양의 해석'이 아니다.

무슨 소린지 잘 모르겠다.

## 3.50 UNIX 사상 - 13. 경제성의 원칙

## 3.51 UNIX 사상 - 14. 생성의 원칙(Rule of Generation)
> 코드를 작성하기 위한 코드를 작성한다. 무리하지 않는 범위에서 적재적소에 부분적으로나마 코드를 생성하도록 한다.

> 반복이 많고 정형적인 코드는 코드 생성기를 활용한다.

## 3.52 UNIX 사상 - 15. 최적화의 원칙
> 코드를 최적화하기 전에 바르게 동작하는 코드를 작성한다.

> 바르게 만든 다음에 빠르게 만든다.

> 일단 동작하는 프로토타입을 만드는 것은 최적화라는 관점에서도 효과적이다. 프로토타입을 사용하면 코드를 작성하지 않아도 되는 기능이 파악된다.

## 3.53 UNIX 사상 - 16. 다양성의 원칙

## 3.54 UNIX 사상 - 17. 확장성의 원칙
> 확장성의 원칙은 데이터 형식(데이터 레이아웃, 데이터 포멧)에도 적용된다.

> 데이터 형식을 자기 완결적이면서 자기 설명적인 구문으로 구성하는 것이 좋은 방식이다.


## 3.64