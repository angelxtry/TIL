# 3. 함수, 반복자, 제네레이터

> 함수형 프로그래밍의 핵심은 순수 함수를 사용해 입력 정의역(domain)의 값을 출력 치역(range)의 값으로 바꾸는 것이다.

> 함수적인 시각에서 다음과 같은 파이썬의 기능을 몇 가지 살펴본다.
> * 부수 효과가 없는 순수 함수
> * 인자로 넘길 수 있거나 함수의 결과로 반환할 수 있는 객체인 함수
> * 객체지향적인 후위 표기법이나 전위 표기법으로 파이썬 문자열 사용
> * tuple이나 namedtuple을 사용해 상태가 없는 객체 생성
> * 반복 가능한 컬렉션을 함수형 프로그래밍을 위한 주 설계 도구로 활용

> 함수형 파이선을 작성하려면 튜플과 변경할 수 없는 컬렉션에 초점을 맞출 필요가 있다.

## 순수 함수 작성하기
> 자유 변수(free variable)를 사용해 파이썬의 전역에 있는 ㄱㅂㅅ을 참조하면 매개변수를 적절히 사용해 처리할 수 있다.

```py
def some_function(a, b, t):
    return a + b * t + global_adjustment
```
> 이 함수를 리팩토링하여 global_adjustment 변수를 적절한 매개변수로 바꿀 수 있다. 다만, 이 함수에 대한 모든 참조를 바꿀 필요가 있다 그러한 작업은 복잡한 애플리케이션에서 많은 파장이 있을 수 있다. 전역 참조는 함수의 본문에서 자유 변수처럼 보일 것이다. 그러한 자유 변수에 대한 대입문도 없고, 그에 해당하는 매개변수도 없다면, 이를 전역 변수로 생각할 만한 여지가 충분하다.

의미를 명확히 잘 모르겠다. 책은 한번 다 보고 다시 보면 좀 더 이해가 될까?

> 상태가 있는 파이썬 내부 객체는 많다. file 클래스의 인스턴스나 모든 파일의 유사한 객체들은 자주 사용되는 상태가 있는 객체의 예다. 우리는 파이썬에서 상태가 있는 객체를 사용하는 대부분의 경우는 일반적으로 컨택스트 관라지(context manager)처럼 동작한다는 사실을 알고 있다. ...

> 상태가 있는 파일 객체 사용을 잘 정의된 영역 안으로 제한할 수 있는 with문을 사용해야 한다.

## 일급 게층 객체인 함수
> 호출 가능한 객체를 사용해 함수를 만들 수도 있다. 호출 ㄱ능한 객체도 일급 계층 객체다. 심지어 호출 가능 클래스 정의를 고차 함수라고 생각할 수도 있다. 호출 가능 객체에서 `__init()__` 메서드를 사용하는 방식을 신중하게 생각할 필요가 있다. 즉, 상태가 있는 클래스 변수를 피해야 한다. 한 가지 일반적인 응용방법은 `__init()__` 메서드를 사용해 전략 디자인 패턴(Strategy design pattern)에 부합하는 객체를 만드는 것이다.

> 전략 디자인 패턴을 따르는 클래스는 알고리즘이나 알고리즘의 일부를 제공하는 다른 객체에 의존한다. 이 패턴은 알고리즘의 자세한 부분을 클래스 안에 컴파일 해 넣는 대신, 실행 시점에 알고리즘의 세부 사항을 주입할 수 있게 해준다.

```py
import collections
class Mersenne1(collections.Callable):
    def __init__(self, algorithm):
        self.pow2 = algorithm
    def __call__(self, arg):
        return self.pow2(arg)-1
```

> 이 클래스는 `__init__()`를 사용해 다른 함수에 대한 참조를 저장한다. 하지만 아무런 상태가 있는 인스턴스 변수를 만들지 않는다.

> 다음의 함수는 주어진 인자만큼 2를 거듭제곱한다.
```py
def shifty(b):
    return 1 << b

def multy(b):
    if b == 0:
        return 1
    return 2*multy(b-1)

def faster(b):
    if b == 0:
        return 1
    if b%2 == 1:
        return 2*faster(b-1)
    t = faster(b//2)
    return t*t
```
multy함수를 제외하고는 하나도 이해 못하겠다 ㅠㅠ

> shift() 한수는 비트 왼쪽 시프트 연산을 사용해 2의 거듭제곱을 계산한다. multy() 함수는 단순한 재귀 곱셈을 사용한다. faster() 함수는 분할 정복 전략을 사용해 b번이 아니라 log2(b)번의 곱셈을 수행한다.

> 알고리즘 전략을 내장한 Mersenne1 클래스의 인스턴스는 다음과 같이 만들 수 있다.
```py
m1s = Mersenne1(shifty)
m1m = Mersenne1(multy)
m1f = Mersenne1(faster)
```

> 이는 결과는 같지만, 서로 다른 알고리즘을 사용하는 다양한 함수를 만드는 방법을 보여준다.

전략 디자인 패턴도 잘 사용한다면 활용법이 많을 것 같다. 어떤 일련의 과정이 있고 이 과정에 특정 함수를 포함시켜야 한다면 좋은 방법이 될 것 같다.

예를들어 데이터를 전송하고 복잡한 로그를 남겨야 하는 작업이 있다. 로그를 남기는 작업은 class에 포함시키고 전송방식을 각 함수로 만들어 전략으로 포함시킨다. 그것들을 각각 ftp_send(), mail_send() 등으로 이름을 붙여 함수로 만들어 놓고 매개변수를 이용하여 전달하면 ftp와 mail을 구분하기 위핸 매개변수 하나를 줄일 수 있고 함수이름으로 더 명확하게 코드를 작성할 수 있다고 생각된다.

## 문자열 사용하기
> 파이선 문자열은 변경 불가능하기 때문에 함수형 프로그래밍 객체의 좋은 예라고 할 수 있다. 파이썬의 string 모듈에는 많은 메서드가 들어 있고, 그들 모두는 결과로써 새로운 문자열을 내놓는다. 이러한 메서드는 부수 효과가 없는 순수 함수다.

> 전위 방식인 대두분의 함수와 달리 string 메서드 함수들을 사용하는 구문은 후위 방식이다. 이는 복잡한 문자열 연산이 일반적인 함수와 혼합되는 경우, 가독성이 떨어진다는 의미다.

```py
from decimal import *
def clean_decimal(text):
    if text is None:
        return text
    try:
        return Decimal(text.replace('$', '').replace(',', ''))
    except InvalidOperation:
        return text
```
> 이 함수는 $와 , 문자열을 제거하기 위해 replace를 두 번 호출한다. 그결과로 얻은 문자열을 Decimal 클래스 생성자의 인자로 전달하고, 그 결과로 생긴 객체를 반환한다.

> 이를 더욱 일관성 있게 만들려면 다음과 같이 string의 메서드 함수를 처리하는 전위 연산자 함수를 정의해야 한다.
```py
def replace(data, a, b):
    return data.replace(a, b)
```

> 이러한 함수가 있으면 좀 더 일관성 있는 전위 연산자 형태의 `Decimal(replace(replace(text, '$', ''), ',', ''))` 이라는 구문을 사용할 수 있다.

> 매우 단순한 경우에는 다음과 같이 같은 목적을 쉽게 달성할 수 있다.
```py
replace = str.replace
replace('$12.45', '$', '')
# 12.45
```

> 이러한 일관성이 전위와 후위 연산을 섞어 사용하는 것에 비해 얼마나 큰 개선인지는 분명하지 않아 보인다. 인자가 많은 함수의 문제는 인자들이 식의 여기 저기에 나타날 수 있다는 점이다.

> 좀 더 나은 접근 방식은 다음과 비슷하게 구분 기호를 정리해주는 전위 연산자 방식의 함수를 정의하는 것이다.

```py
def remove(str, chars):
    if chars:
        return remove(str.replace(chars[0], ''), chars[1:])
    return str
```

> 이 함수는 재귀적으로 char 변수에 있는 글자들을 str에서 제거한다. 이를 `Decimal(remove(text, '$,'))와 같이 사용하면 문자열을 정리하는 목적을 더욱 잘 드러낼 수 있다.

## tuple과 namedtuple 사용하기
