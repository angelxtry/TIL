# react-nodebird 6

제로초님의 인프런 강의를 보고 따라한 것임을 미리 밝힌다.

## 해시태그 링크 만들기

프론트에서 해시태그를 링크로 변환하여 클릭할 수 있게 만들자.

`components/PostCard.js`

```js
import React, { useState, useCallback } from 'react';
import { Card, Icon, Button, Avatar } from 'antd';

import PostCardContent from './PostCardContent';
import CommentForm from './CommentForm';
import CommentList from './CommentList';

const PostCard = ({ post }) => {
  const [commentFormOpened, setCommentFormOpened] = useState(false);
  const onToggleComment = useCallback(() => {
    setCommentFormOpened((prev) => !prev);
  }, []);

  return (
    <div>
      <Card
        corver={post.img && <img alt="example" src={post.img} />}
        actions={[
          <Icon type="retweet" key="retweet" />,
          <Icon type="heart" key="heart" />,
          <Icon type="message" key="message" onClick={onToggleComment} />,
          <Icon type="ellipsis" key="ellipsis" />
        ]}
        extra={<Button>팔로우</Button>}
      >
        <Card.Meta
          avatar={<Avatar>{post.User.nickname[0]}</Avatar>}
          title={post.User.nickname}
          description={<PostCardContent postContent={post.content} />}
        />
      </Card>
      {commentFormOpened && (
        <>
          <CommentForm post={post} />
          <CommentList post={post} />
        </>
      )}
    </div>
  );
};

export default PostCard;

```

`components/PostCardContent.js`

```js
import React from 'react';
import Link from 'next/link';

const PostCardContent = ({ postContent }) => {
  return (
    <div>
      {postContent.split(/(#[^\s]+)/g).map((v) => {
        if (v.match(/#[^\s]+/)) {
          return (
            <Link
              href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }}
              as={`/hashtag/${v.slice(1)}`}
              key={v}
            >
              <a>{v}</a>
            </Link>
          );
        }
        return v;
      })}
    </div>
  );
};

export default PostCardContent;

```

코드가 너무 길어 분리했다.

`PostCardContent`를 보면 데이터를 정규표현식과 split을 이용하여 분리하여 배열로 만든다.

배열을 map으로 순회하면서 해시태그이면 링크로 만들고, 아니면 그대로 출력한다.

링크는 동적으로 path가 변경될 수 있도록 href를 작성했다.

`as`는 실제로 브라우저의 주소창에 표시되는 url을 변경한다.

`as`가 없다면 url은 `http://localhost:3000/hashtag?tag=해시태그` 이렇게 표시될 것이다.

`as`에 의해 url은 `http://localhost:3000/hashtag/해시태그`로 변경된다.

## next에 express 연동

프론트에 다음의 package를 설치한다.

```js
> npm i express morgan cookie-parser express-session dotenv

> npm i -D nodemon
```

root 경로에 `server.js` 파일을 생성한다.

```js
const express = require('express');
const next = require('next');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const expressSession = require('express-session');
const dotenv = require('dotenv');

const dev = process.env.NODE_ENV !== 'production';
const prod = process.env.NODE_ENV === 'production';

const app = next({ dev });
const handle = app.getRequestHandler();
dotenv.config();

app.prepare().then(() => {
  const server = express();

  server.use(morgan('dev'));
  server.use(express.json());
  server.use(express.urlencoded({ extended: true }));
  server.use(cookieParser(process.env.COOKIE_SECRET));
  server.use(
    expressSession({
      resave: false,
      saveUninitialized: false,
      secret: process.env.COOKIE_SECRET,
      cookie: {
        httpOnly: true,
        secure: false
      }
    })
  );

  server.get('*', (req, res) => {
    return handle(req, res);
  });

  server.listen(9090, () => {
    console.log(`http://localhost:9090`);
  });
});

```

일단 여기까지 작성하면 next와 express가 연동될 준비가 되었다.

`COOKIE_SECRET`은 서버와 동일하게 사용한다.

`package.json`에서 `scrpit`를 변경하여 `next`가 아닌 `nodemon`이 프론트를 실행하도록 변경하자.

```json
"scripts": {
  "dev": "nodemon"
},
```

`nodemon.json` 파일도 생성한다.

```json
{
  "watch": [
    "server.js",
    "nodemon.json"
  ],
  "exec": "node server.js",
  "ext": "js json jsx"
}

```

`npm run dev`로 실행해보면 next가 실행되는 것을 확인할 수 있다.

## hashtag 동적 라우팅

`server.js`에 라우팅 관련 코드를 추가한다.

```js
const express = require('express');
const next = require('next');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const expressSession = require('express-session');
const dotenv = require('dotenv');

const dev = process.env.NODE_ENV !== 'production';
const prod = process.env.NODE_ENV === 'production';

const app = next({ dev });
const handle = app.getRequestHandler();
dotenv.config();

app.prepare().then(() => {
  const server = express();

  server.use(morgan('dev'));
  server.use(express.json());
  server.use(express.urlencoded({ extended: true }));
  server.use(cookieParser(process.env.COOKIE_SECRET));
  server.use(
    expressSession({
      resave: false,
      saveUninitialized: false,
      secret: process.env.COOKIE_SECRET,
      cookie: {
        httpOnly: true,
        secure: false
      }
    })
  );

  server.get('/hashtag/:tag', (req, res) => {
    return app.render(req, res, '/hashtag', { tag: req.params.tag });
  });

  server.get('*', (req, res) => {
    return handle(req, res);
  });

  server.listen(9090, () => {
    console.log(`http://localhost:9090`);
  });
});

```

express와 다른 점은 `res.json` 같은 함수를 사용한 것이 아니라 `app.render`를 사용한다는 것이다.

이렇게 라우팅을 설정하면 `hashtag` 페이지에 tag를 동적으로 전달할 수 있다.

`pages/hashtag.js` 파일을 생성한다.

```js
import React from 'react';

const hashtag = () => {
  return <div>hashtag</div>;
};

hashtag.getInitialProps = async (context) => {
  console.log('hashtag getInitialProsp: ', context.query.tag);
};

export default hashtag;

```

여기서 집중해야 할 것인 `getInitialProps`이다.

`getInitialProps`는 비동기로 동작하고 context라는 인자를 받는다.

이 context에 라우팅 처리 때 전달한 `{ tag: req.params.tag }`가 들어있다.

context를 `getInitialProps`에 넣고 `getInitialProps`를 호출하기 위해 `pages/_app.js`파일의 코드를 수정한다.

```js
import React from 'react';
import Head from 'next/head';
import PropTypes from 'prop-types';
import { applyMiddleware, compose, createStore } from 'redux';
import { Provider } from 'react-redux';
import withRedux from 'next-redux-wrapper';
import createSagaMiddleware from 'redux-saga';

import Layout from '../components/Layout';
import rootReducer from '../reducers';
import rootSaga from '../sagas';

const CandC = ({ Component, store, pageProps }) => {
  return (
    <Provider store={store}>
      <Head>
        <title>C And C</title>
        <link
          rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/antd/3.23.6/antd.min.css"
        />
      </Head>
      <Layout>
        <Component {...pageProps} />
      </Layout>
    </Provider>
  );
};

CandC.propTypes = {
  Component: PropTypes.elementType
};

CandC.getInitialProps = async (context) => {
  // console.log(context);
  const { ctx, Component } = context;
  let pageProps = {};
  if (Component.getInitialProps) {
    pageProps = await Component.getInitialProps(ctx);
  }
  return { pageProps };
};

const configureStore = (initialState, options) => {
  const sagaMiddleware = createSagaMiddleware();
  const middlewares = [sagaMiddleware];
  const enhancer =
    process.env.NODE_ENV === 'production'
      ? compose(applyMiddleware(...middlewares))
      : compose(
          applyMiddleware(...middlewares),
          !options.isServer &&
            typeof window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined'
            ? window.__REDUX_DEVTOOLS_EXTENSION__()
            : (f) => f
        );
  const store = createStore(rootReducer, initialState, enhancer);
  sagaMiddleware.run(rootSaga);
  return store;
};

export default withRedux(configureStore)(CandC);

```

부분만 잘라서 확인하자.

```js
CandC.getInitialProps = async (context) => {
  // console.log(context);
  const { ctx, Component } = context;
  let pageProps = {};
  if (Component.getInitialProps) {
    pageProps = await Component.getInitialProps(ctx);
  }
  return { pageProps };
};

```

context는 next에서 전달한 인자다.

여기서 Component는 `pages` 폴더 하위의 페이지들이다.

여기서 각 페이지의 `getInitialProps` 함수를 실행한다.

`getInitialProps`는 일종의 life cycle이라고 간주할 수 있다.

이 함수는 가장 먼저 실행된다.

이 함수는 프론트에서도 실행되고, 서버에서도 실행된다.

next의 특징인 ssr을 할 때도 이 함수를 사용한다.

각 컴포넌트의 `getInitialProps`에서 return 한 값은 `_app.js`의 `pageProps`로 전달되고, `CandC`에서 해당 인자를 받는다.

그리고 그 인자는 다시 `Component`로 전달되어 해당 컴포넌트에서 사용할 수 있게 된다.

## 해시태그 클릭 시 검색 처리

이번엔 `reducers/post.js` 부터 시작하자.

```js
case LOAD_MAIN_POSTS_REQUEST:
case LOAD_HASHTAG_POSTS_REQUEST: {
  return {
    ...state,
    mainPosts: [],
    loadMainPostsError: ''
  };
}
case LOAD_MAIN_POSTS_SUCCESS:
case LOAD_HASHTAG_POSTS_SUCCESS: {
  return {
    ...state,
    mainPosts: action.payload.data
  };
}
case LOAD_MAIN_POSTS_FAILURE:
case LOAD_HASHTAG_POSTS_FAILURE: {
  return {
    ...state,
    loadMainPostsError: action.error
  };
}

```

기존과 동일한 행동을 한다.

`sagas/post.js`

```js
function loadHashtagPostsAPI({ tag }) {
  return axios.get(`/hashtag/${tag}`);
}

function* loadHashtagPosts(action) {
  try {
    const result = yield call(loadHashtagPostsAPI, action.payload);
    yield put({
      type: LOAD_HASHTAG_POSTS_SUCCESS,
      payload: result.data
    });
  } catch (error) {
    console.error(error);
    yield put({ type: LOAD_HASHTAG_POSTS_FAILURE, error });
  }
}

function* watchLoadHashtagPosts() {
  yield takeLatest(LOAD_HASHTAG_POSTS_REQUEST, loadHashtagPosts);
}

```

axios에 전달할 때 url로 tag를 전달한다.

`routes/hashtag.js`

```js
const express = require('express');
const { User, Post, Hashtag } = require('../models');

const router = express.Router();

router.get('/:tag', async (req, res, next) => {
  try {
    const posts = await Post.findAll({
      include: [
        {
          model: Hashtag,
          where: { name: decodeURIComponent(req.params.tag) }
        },
        { model: User, attributes: ['id', 'nickname'] }
      ]
    });
    res
      .status(200)
      .json({ code: 200, message: 'Hashtage search success.', data: posts });
  } catch (error) {
    console.error(error);
    next(error);
  }
});

module.exports = router;

```

`Post` 테이블에 where 조건을 넣는 것이 아니라 `Hashtag` 테이블에 where 조건이 들어가야 한다.

따라서 `include` 안에 where문을 넣는다.

해시태그는 한글도 있을 수 있기 때문에 `decodeURIComponent`를 사용해야 한다.

마지막으로 프론트를 보자.

`pages/hashtag.js`

```js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';

import PostCard from '../components/PostCard';
import { LOAD_HASHTAG_POSTS_REQUEST } from '../reducers/post';

const hashtag = ({ tag }) => {
  const { mainPosts } = useSelector((state) => state.post);
  const dispatch = useDispatch();
  useEffect(() => {
    dispatch({
      type: LOAD_HASHTAG_POSTS_REQUEST,
      payload: { tag }
    });
  }, [tag]);
  return (
    <div>
      {mainPosts.map((c, i) => (
        <PostCard key={i} post={c} />
      ))}
    </div>
  );
};

hashtag.getInitialProps = async (context) => {
  return { tag: context.query.tag };
};

export default hashtag;

```

해시태그가 완성됐다.

하나만 더 확인하자.

express를 사용했기 때문에 해시태그의 링크를 만들 때 다음과 같이 코드를 작성할 수도 있다.

`components/PostCardContent.js`

```js
import React from 'react';
import Link from 'next/link';

const PostCardContent = ({ postContent }) => {
  return (
    <div>
      {postContent.split(/(#[^\s]+)/g).map((v) => {
        if (v.match(/#[^\s]+/)) {
          return (
            <Link
              href={`/hashtag/${v.slice(1)}`}
              // href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }}
              // as={`/hashtag/${v.slice(1)}`}
              key={v}
            >
              <a>{v}</a>
            </Link>
          );
        }
        return v;
      })}
    </div>
  );
};

export default PostCardContent;

```

이렇게 코드를 작성하고 해시태그를 클릭하면 url도 `http://localhost:9090/hashtag/해시태그`처럼 정상적으로 동작하는 것 처럼 보인다.

하지만 Chrome의 Network 탭을 열어보면 화면 전체가 다시 로딩되는 것을 볼 수 있다.

```js
href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }}
as={`/hashtag/${v.slice(1)}`}

```

이렇게 작성해야만 Network 탭 전체가 갱신되지 않고 해당 부분만 다시 랜더링 된다.

## 아바타 클릭 시 해당 사용자 포스트 출력

아바타에 링크를 연결하여 아바타를 클릭하면 `http://localhost:9090/user/1`과 같이 url이 변경되고 해당 사용자의 포스트만 출력되는 기능을 추가하려고 한다.

일단 프론트 페이지에 링크부터 추가해보자.

`components/PostCard.js`

```js
import React, { useState, useCallback } from 'react';
import Link from 'next/link';
import { Card, Icon, Button, Avatar } from 'antd';

import PostCardContent from './PostCardContent';
import CommentForm from './CommentForm';
import CommentList from './CommentList';

const PostCard = ({ post }) => {
  const [commentFormOpened, setCommentFormOpened] = useState(false);
  const onToggleComment = useCallback(() => {
    setCommentFormOpened((prev) => !prev);
  }, []);

  return (
    <div>
      <Card
        corver={post.img && <img alt="example" src={post.img} />}
        actions={[
          <Icon type="retweet" key="retweet" />,
          <Icon type="heart" key="heart" />,
          <Icon type="message" key="message" onClick={onToggleComment} />,
          <Icon type="ellipsis" key="ellipsis" />
        ]}
        extra={<Button>팔로우</Button>}
      >
        <Card.Meta
          avatar={
            <Link
              href={{ pathname: '/user', query: { id: post.User.id } }}
              as={`/user/${post.User.id}`}
            >
              <a>
                <Avatar>{post.User.nickname[0]}</Avatar>
              </a>
            </Link>
          }
          title={post.User.nickname}
          description={<PostCardContent postContent={post.content} />}
        />
      </Card>
      {commentFormOpened && (
        <>
          <CommentForm post={post} />
          <CommentList post={post} />
        </>
      )}
    </div>
  );
};

export default PostCard;

```

`Avatar`를 `Link`와 `a` 태그로 감싸주었다.

그리고 `Link`의 href와 as를 설정했다.

프론트의 `server.js` 파일에서 라우팅 설정을 한다.

```js
const express = require('express');
const next = require('next');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const expressSession = require('express-session');
const dotenv = require('dotenv');

const dev = process.env.NODE_ENV !== 'production';
const prod = process.env.NODE_ENV === 'production';

const app = next({ dev });
const handle = app.getRequestHandler();
dotenv.config();

app.prepare().then(() => {
  const server = express();

  server.use(morgan('dev'));
  server.use(express.json());
  server.use(express.urlencoded({ extended: true }));
  server.use(cookieParser(process.env.COOKIE_SECRET));
  server.use(
    expressSession({
      resave: false,
      saveUninitialized: false,
      secret: process.env.COOKIE_SECRET,
      cookie: {
        httpOnly: true,
        secure: false
      }
    })
  );

  server.get('/hashtag/:tag', (req, res) => {
    return app.render(req, res, '/hashtag', { tag: req.params.tag });
  });

  server.get('/user/:id', (req, res) => {
    return app.render(req, res, '/user', { id: req.params.id });
  });

  server.get('*', (req, res) => {
    return handle(req, res);
  });

  server.listen(9090, () => {
    console.log(`http://localhost:9090`);
  });
});

```

`pages/user.js` 파일을 생성하자.

```js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';

import PostCard from '../components/PostCard';
import { LOAD_USER_POSTS_REQUEST } from '../reducers/post';

const user = ({ id }) => {
  const { mainPosts } = useSelector((state) => state.post);
  const dispatch = useDispatch();
  useEffect(() => {
    dispatch({
      type: LOAD_USER_POSTS_REQUEST,
      payload: { id }
    });
  }, [id]);
  return (
    <div>
      {mainPosts.map((c, i) => (
        <PostCard key={i} post={c} />
      ))}
    </div>
  );
};

user.getInitialProps = async (context) => {
  return { id: context.query.id };
};

export default user;

```

`pages/hashtag.js`와 구조가 동일하다.

`reducers/post.js`를 수정한다.

```js
case LOAD_MAIN_POSTS_REQUEST:
case LOAD_HASHTAG_POSTS_REQUEST:
case LOAD_USER_POSTS_REQUEST: {
  return {
    ...state,
    mainPosts: [],
    loadMainPostsError: ''
  };
}
case LOAD_MAIN_POSTS_SUCCESS:
case LOAD_HASHTAG_POSTS_SUCCESS:
case LOAD_USER_POSTS_SUCCESS: {
  return {
    ...state,
    mainPosts: action.payload.data
  };
}
case LOAD_MAIN_POSTS_FAILURE:
case LOAD_HASHTAG_POSTS_FAILURE:
case LOAD_USER_POSTS_FAILURE: {
  return {
    ...state,
    loadMainPostsError: action.error
  };
}
```

결국 mainPosts를 가져오는 것이므로 동일한 행동을 한다.

`sagas/post.js`

```js
function loadUserPostsAPI({ id }) {
  return axios.get(`/user/${id}/posts`);
}

function* loadUserPosts(action) {
  try {
    const result = yield call(loadUserPostsAPI, action.payload);
    yield put({
      type: LOAD_USER_POSTS_SUCCESS,
      payload: result.data
    });
  } catch (error) {
    console.error(error);
    yield put({ type: LOAD_USER_POSTS_FAILURE, error });
  }
}

function* watchLoadUserPosts() {
  yield takeLatest(LOAD_USER_POSTS_REQUEST, loadUserPosts);
}

```

이 코드 또한 동일하다.

axios를 url을 잘 확인하자.

이제 서버의 `routes/user.js` 파일을 수정한다.

```js
router.get('/:id/posts', async (req, res, next) => {
  try {
    const posts = await Post.findAll({
      where: { UserId: parseInt(req.params.id, 10), RetweetId: null },
      include: [{ model: User, attributes: ['id', 'nickname'] }]
    });
    return res
      .status(200)
      .json({
        code: 200,
        message: 'Posts select(UserId) success.',
        data: posts
      });
  } catch (error) {
    console.error(error);
    return next(error);
  }
});

```

## 아바타 클릭 시 해당 사용자 정보 출력

`components/PostCard.js`

```js
import React, { useState, useCallback } from 'react';
import Link from 'next/link';
import { Card, Icon, Button, Avatar } from 'antd';

import PostCardContent from './PostCardContent';
import CommentForm from './CommentForm';
import CommentList from './CommentList';

const PostCard = ({ post }) => {
  const [commentFormOpened, setCommentFormOpened] = useState(false);
  const onToggleComment = useCallback(() => {
    setCommentFormOpened((prev) => !prev);
  }, []);

  return (
    <div>
      <Card
        corver={post.img && <img alt="example" src={post.img} />}
        actions={[
          <Icon type="retweet" key="retweet" />,
          <Icon type="heart" key="heart" />,
          <Icon type="message" key="message" onClick={onToggleComment} />,
          <Icon type="ellipsis" key="ellipsis" />
        ]}
        extra={<Button>팔로우</Button>}
      >
        <Card.Meta
          avatar={
            <Link
              href={{ pathname: '/user', query: { id: post.User.id } }}
              as={`/user/${post.User.id}`}
            >
              <a>
                <Avatar>{post.User.nickname[0]}</Avatar>
              </a>
            </Link>
          }
          title={post.User.nickname}
          description={<PostCardContent postContent={post.content} />}
        />
      </Card>
      {commentFormOpened && (
        <>
          <CommentForm post={post} />
          <CommentList post={post} />
        </>
      )}
    </div>
  );
};

export default PostCard;

```

해시태그와 동일한 방식으로 `Link`를 추가했다.

`reducers/user.js`

```js
case LOAD_OTHER_USER_REQUEST: {
  return {
    ...state,
    loadOtherUserError: ''
  };
}
case LOAD_OTHER_USER_SUCCESS: {
  return {
    ...state,
    userInfo: action.payload.data
  };
}
case LOAD_OTHER_USER_FAILURE: {
  return {
    ...state,
    userInfo: null,
    loadOtherUserError: action.error
  };
}

```

`sagas/user.js`

```js
function loadOtherUserAPI({ id }) {
  return axios.get(`/user/${id}`, { withCredentials: true });
}

function* loadOtherUser(action) {
  try {
    const result = yield call(loadOtherUserAPI, action.payload);
    yield put({ type: LOAD_OTHER_USER_SUCCESS, payload: result.data });
  } catch (error) {
    console.error(error);
    yield put({ type: LOAD_OTHER_USER_FAILURE, error });
  }
}

function* watchLoadOtherUser() {
  yield takeLatest(LOAD_OTHER_USER_REQUEST, loadOtherUser);
}

```

서버의 `routes/user.js`

```js
router.get('/:id', async (req, res, next) => {
  try {
    const user = await User.findOne({
      where: { id: parseInt(req.params.id, 10) },
      include: [
        { model: Post, as: 'Posts', attributes: ['id'] },
        { model: User, as: 'Followings', attributes: ['id'] },
        { model: User, as: 'Followers', attributes: ['id'] }
      ],
      attributes: ['id', 'nickname', 'userId']
    });
    const jsonUser = user.toJSON();
    jsonUser.Posts = jsonUser.Posts ? jsonUser.Posts.length : 0;
    jsonUser.Followings = jsonUser.Followings ? jsonUser.Followings.length : 0;
    jsonUser.Followers = jsonUser.Followers ? jsonUser.Followers.length : 0;
    return res.status(200).json({
      code: 200,
      message: 'User select(UserId) success.',
      data: jsonUser
    });
  } catch (error) {
    console.error(error);
    return next(error);
  }
});

```

`pages.user.js`

```js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Card, Avatar } from 'antd';

import PostCard from '../components/PostCard';
import { LOAD_USER_POSTS_REQUEST } from '../reducers/post';
import { LOAD_OTHER_USER_REQUEST } from '../reducers/user';

const user = ({ id }) => {
  const { mainPosts } = useSelector((state) => state.post);
  const { userInfo } = useSelector((state) => state.user);
  const dispatch = useDispatch();
  useEffect(() => {
    dispatch({
      type: LOAD_OTHER_USER_REQUEST,
      payload: { id }
    });
    dispatch({
      type: LOAD_USER_POSTS_REQUEST,
      payload: { id }
    });
  }, [id]);

  return (
    <div>
      {userInfo ? (
        <Card
          actions={[
            <div key="twit">
              짹짹 <br /> {userInfo.Posts}
            </div>,
            <div key="following">
              팔로잉 <br /> {userInfo.Followings}
            </div>,
            <div key="follower">
              팔로워 <br /> {userInfo.Followers}
            </div>
          ]}
        >
          <Card.Meta
            avatar={<Avatar>{userInfo.nickname[0]}</Avatar>}
            title={userInfo.nickname}
          />
        </Card>
      ) : null}
      {mainPosts.map((c, i) => (
        <PostCard key={i} post={c} />
      ))}
    </div>
  );
};

user.getInitialProps = async (context) => {
  return { id: context.query.id };
};

export default user;

```

동일한 코드가 계속 보이는데 언젠가는 리펙토링 해야지 ㅠㅠ

## 댓글 작성

댓글 작성은 `components/CommentForm.js`에서 시작한다.

```js
import React, { useState, useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Form, Input } from 'antd';

import { ADD_COMMENT_REQUEST } from '../reducers/post';

const CommentForm = ({ post }) => {
  const [commentText, setCommentText] = useState('');
  const { isLoggedIn } = useSelector((state) => state.user);
  const { isAddedComment, isAddingComment } = useSelector(
    (state) => state.post
  );
  const dispatch = useDispatch();

  const onSubmitComment = useCallback(
    (e) => {
      e.preventDefault();
      if (!isLoggedIn) {
        return alert('Plz login.');
      }
      return dispatch({
        type: ADD_COMMENT_REQUEST,
        payload: {
          postId: post.id,
          content: commentText
        }
      });
    },
    [isLoggedIn, commentText]
  );

  useEffect(() => {
    setCommentText('');
  }, [isAddedComment]);

  const onChangeCommentText = useCallback((e) => {
    setCommentText(e.target.value);
  }, []);

  return (
    <Form onSubmit={onSubmitComment}>
      <Form.Item>
        <Input.TextArea
          rows={4}
          value={commentText}
          onChange={onChangeCommentText}
        />
      </Form.Item>
      <Button type="primary" htmlType="submit" loading={isAddingComment}>
        Add Comment
      </Button>
    </Form>
  );
};

export default CommentForm;

```

`reducers/post.js`

```js
case ADD_COMMENT_REQUEST: {
  return {
    ...state,
    isAddingComment: true,
    isAddedComment: false,
    addCommentError: ''
  };
}
case ADD_COMMENT_SUCCESS: {
  const postIndex = state.mainPosts.findIndex(
    (v) => v.id === action.payload.postId
  );
  const post = state.mainPosts[postIndex];
  const comments = [...post.comments, action.payload.comments.data];
  const mainPosts = [...state.mainPosts];
  mainPosts[postIndex] = { ...post, comments };
  return {
    ...state,
    isAddingComment: false,
    isAddedComment: true,
    mainPosts
  };
}
case ADD_COMMENT_FAILURE: {
  return {
    ...state,
    isAddingComment: false,
    isAddedComment: false,
    addCommentError: action.error
  };
}

```

`sagas/post.js`

```js
function addCommentAPI({ postId, content }) {
  return axios.post(
    `/post/${postId}/comment`,
    { content },
    { withCredentials: true }
  );
}

function* addComment(action) {
  try {
    const result = yield call(addCommentAPI, action.payload);
    yield put({
      type: ADD_COMMENT_SUCCESS,
      payload: {
        postId: action.payload.postId,
        comments: result.data
      }
    });
  } catch (error) {
    console.error(error);
    yield put({
      type: ADD_COMMENT_FAILURE,
      error
    });
  }
}

function* watchAddComment() {
  yield takeLatest(ADD_COMMENT_REQUEST, addComment);
}

```

서버의 `routes/post.js`

```js
router.post('/:id/comment', async (req, res, next) => {
  try {
    if (!req.user) {
      return res.status(401).json({ code: 401, message: 'Plz login.' });
    }
    const post = await Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).json({ code: 404, message: 'Post not found.' });
    }
    const newComment = await Comment.create({
      PostId: post.id,
      UserId: req.user.id,
      content: req.body.content
    });
    await post.addComment(newComment.id);
    const comment = await Comment.findOne({
      where: { id: newComment.id },
      include: [{ model: User, attributes: ['id', 'nickname'] }]
    });
    return res
      .status(200)
      .json({ code: 200, message: 'Comment write.', data: comment });
  } catch (error) {
    console.error(error);
    return next(error);
  }
});

```

로그인 되어있지 않으면 401 리턴.

포스트를 먼저 검색한 후 해당 포스트에 댓글을 등록한다.

그리고 `addComment` 함수를 이용하여 `POST` 테이블과 `COMMENT` 테이블을 연결시킨다.

마지막으로 등록된 댓글을 다시 조회하여 프론트로 리턴한다.

## 댓글 불러오기

`components/PostCard.js`

```js
import React, { useState, useCallback } from 'react';
import Link from 'next/link';
import { useDispatch } from 'react-redux';
import { Card, Icon, Button, Avatar } from 'antd';

import PostCardContent from './PostCardContent';
import CommentForm from './CommentForm';
import CommentList from './CommentList';
import { LOAD_COMMENTS_REQUEST } from '../reducers/post';

const PostCard = ({ post }) => {
  const [commentFormOpened, setCommentFormOpened] = useState(false);
  const dispatch = useDispatch();
  const onToggleComment = useCallback(() => {
    setCommentFormOpened((prev) => !prev);
    if (!commentFormOpened) {
      dispatch({
        type: LOAD_COMMENTS_REQUEST,
        payload: { postId: post.id }
      });
      console.log('setCommentFormOpened: ', post.id);
    }
  }, []);

  return (
    <div>
      <Card
        corver={post.img && <img alt="example" src={post.img} />}
        actions={[
          <Icon type="retweet" key="retweet" />,
          <Icon type="heart" key="heart" />,
          <Icon type="message" key="message" onClick={onToggleComment} />,
          <Icon type="ellipsis" key="ellipsis" />
        ]}
        extra={<Button>팔로우</Button>}
      >
        <Card.Meta
          avatar={
            <Link
              href={{ pathname: '/user', query: { id: post.User.id } }}
              as={`/user/${post.User.id}`}
            >
              <a>
                <Avatar>{post.User.nickname[0]}</Avatar>
              </a>
            </Link>
          }
          title={post.User.nickname}
          description={<PostCardContent postContent={post.content} />}
        />
      </Card>
      {commentFormOpened && (
        <>
          <CommentForm post={post} />
          <CommentList post={post} />
        </>
      )}
    </div>
  );
};

export default PostCard;

```

`PostCard`에서 댓글을 불러오는 것이 조금 어색하지만 일단 진행해보자.

`sagas/post.js`

```js
function loadCommentsAPI({ postId }) {
  return axios.get(`/post/${postId}/comments`);
}

function* loadComments(action) {
  try {
    const result = yield call(loadCommentsAPI, action.payload);
    yield put({
      type: LOAD_COMMENTS_SUCCESS,
      payload: {
        postId: action.payload.postId,
        comments: result.data
      }
    });
  } catch (error) {
    console.error(error);
    yield put({
      type: LOAD_COMMENTS_FAILURE,
      error
    });
  }
}

function* watchLoadComments() {
  yield takeLatest(LOAD_COMMENTS_REQUEST, loadComments);
}

```

`routes/post.jg`

```js
router.get('/:id/comments', async (req, res, next) => {
  try {
    const post = await Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).json({ code: 400, message: 'Post not found.' });
    }
    const comments = await Comment.findAll({
      where: { PostId: req.params.id },
      order: [['createdAt', 'ASC']],
      include: [{ model: User, attributes: ['id', 'nickname'] }]
    });
    return res
      .status(200)
      .json({code: 200, message: 'Comments select success.', data: comments });
  } catch (error) {
    console.error(error);
    return next(error);
  }
});

```

`reducers/user.js`

```js
case LOAD_COMMENTS_SUCCESS: {
  const postIndex = state.mainPosts.findIndex(
    (v) => v.id === action.payload.postId
  );
  const post = state.mainPosts[postIndex];
  const comments = action.payload.comments.data;
  const mainPosts = [...state.mainPosts];
  mainPosts[postIndex] = { ...post, comments };
  return {
    ...state,
    mainPosts
  };
}

```

이렇게 작성하고 나면 `components/CommentList.js`에서 각 포스트의 댓글 창을 열었을 때 comment가 로드된다.

## 로그인, 로그아웃 확인 미들웨어

`routes/middleware.js` 파일을 생성한다.

```js
exports.isLoggedIn = (req, res, next) => {
  if (req.isAuthenticated()) {
    next();
  } else {
    res.status(401).json({ code: 401, message: 'Plz login.' });
  }
};

exports.isNotLoggedIn = (req, res, next) => {
  if (!req.isAuthenticated()) {
    next();
  } else {
    res.status(401).json({ code: 401, message: 'Logout plz.' });
  }
};

```

`req.isAuthenticated()`는 로그인 여부를 확인한다.

```js
if (!req.user)
```

`req.isAuthenticated()`는 위 코드와 동일하다.

`next()`에 에러를 넣으면 에러처리로 넘어간다.

`next()`에 인자가 없으면 다음 미들웨어를 진행한다.

따라서 `isLoggedIn` 미들웨어는 로그인 한 사용자는 다음 로직을 계속 진행하고, 로그인 하지 않았으면 401 응답을 보낸다.

```js
router.get('/', (req, res) => {
  if (!req.user) {
    return res.status(401).json({ code: 401, message: 'Plz Login.' });
  }
  return res
    .status(200)
    .json({ code: 200, message: 'Login success', data: req.user });
});

```

위와 같은 코드를 `isLoggedIn`을 사용하여 다음과 같이 수정할 수 있다.

```js
router.get('/', isLoggedIn, (req, res) => {
  return res
    .status(200)
    .json({ code: 200, message: 'Login success', data: req.user });
});

```

## 이미지 업로드 구현 - 프론트

`components/PostCard.js`

```js
const imageInput = useRef();

const onClickImageUpload = useCallback(() => {
  imageInput.current.click();
}, [imageInput.current]);

<div>
  <input
    type="file" multiple hidden
    ref={imageInput} // onChange={onChangeImages}
  />
  <Button onClick={onClickImageUpload}>Image upload</Button>
  <Button
    type="primary"
    style={{ float: 'right' }}
    htmlType="submit"
    loading={isAddingPost}
  >
    write
  </Button>
</div>
```

중간 중간 코드가 생략되었다.

`imsageInput`이라는 `useRef`를 하나 생성했다.

그리고 `input` 태그에 `ref={imageInput}`을 추가한다.

마지막으로 `Button`의 `onClick`에 호출되는 `onClickImageUpload`에 `imageInput.current.click();`을 추가한다.

결과적으로 `Button`을 클릭하면 `hidden`으로 감춰진 `파일 선택` 버튼을 클릭할 수 있다.

```js
const onChangeImages = useCallback((e) => {
    console.log(e.target.files);
  }, []);

<div>
  <input
    type="file" multiple hidden
    ref={imageInput} onChange={onChangeImages}
  />
  <Button onClick={onClickImageUpload}>Image upload</Button>
  <Button
    type="primary"
    style={{ float: 'right' }}
    htmlType="submit"
    loading={isAddingPost}
  >
    write
  </Button>
</div>

```

`파일 선택` input을 이용하여 파일을 선택할 수 있고, 파일을 선택하면 이 데이터는 `e.target.files`에 저장된다.

```js
const onChangeImages = useCallback((e) => {
  console.log(e.target.files);
  const imageFormData = new FormData();
  [].forEach.call(a.target.files, (f) => {
    imageFormData.append('image', f);
  });
  dispatch({
    type: UPLOAD_IMAGES_REQUEST,
    payload: imageFormData
  });
}, []);

```

이미지는 브라우저에서 제공하는 `FormData`라는 것으로 저장한다.

그리고 `dispatch`를 이용하여 reducer에 전달한다.

이미지 업로드가 구현된 `PostCard.js`는 다음과 같다.

```js
import React, { useCallback, useEffect, useState, useRef } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Form, Input, Button } from 'antd';

import { ADD_POST_REQUEST, UPLOAD_IMAGES_REQUEST } from '../reducers/post';

const PostForm = () => {
  const [text, setText] = useState('');
  const { imagePaths, isAddedPost, isAddingPost } = useSelector(
    (state) => state.post
  );
  const imageInput = useRef();

  const dispatch = useDispatch();

  const onChangeText = useCallback((e) => {
    setText(e.target.value);
  }, []);

  const onSubmit = useCallback(
    (e) => {
      e.preventDefault();
      if (!text || !text.trim()) {
        return alert('Plz wrtie content.');
      }
      dispatch({
        type: ADD_POST_REQUEST,
        payload: { content: text }
      });
    },
    [text]
  );

  useEffect(() => {
    if (isAddedPost) {
      setText('');
    }
  }, [isAddedPost]);

  const onClickImageUpload = useCallback(() => {
    imageInput.current.click();
  }, [imageInput.current]);

  const onChangeImages = useCallback((e) => {
    console.log(e.target.files);
    const imageFormData = new FormData();
    [].forEach.call(e.target.files, (f) => {
      imageFormData.append('image', f);
    });
    dispatch({
      type: UPLOAD_IMAGES_REQUEST,
      payload: imageFormData
    });
  }, []);

  return (
    <Form
      onSubmit={onSubmit}
      encType="multipart/form-data"
      style={{ margin: '10px 0 20px' }}
    >
      <Input.TextArea
        maxLength={140}
        placeholder="기분을 적어주세요."
        value={text}
        onChange={onChangeText}
      />
      <div>
        <input
          type="file"
          multiple
          hidden
          ref={imageInput}
          onChange={onChangeImages}
        />
        <Button onClick={onClickImageUpload}>Image upload</Button>
        <Button
          type="primary"
          style={{ float: 'right' }}
          htmlType="submit"
          loading={isAddingPost}
        >
          write
        </Button>
      </div>
      <div>
        {imagePaths.map((v) => (
          <div key={v} style={{ display: 'inline-block' }}>
            <img
              src={`http://localhost:8080/${v}`}
              style={{ width: '200px' }}
              alt={v}
            />
            <div>
              <Button>제거</Button>
            </div>
          </div>
        ))}
      </div>
    </Form>
  );
};

export default PostForm;

```

reducer와 saga를 구현하자.

`reducers/post.js`

```js
case UPLOAD_IMAGES_REQUEST: {
  return {
    ...state,
  };
}
case UPLOAD_IMAGES_SUCCESS: {
  return {
    ...state,
    imagePaths: [...state.imagePaths, ...action.payload.data],
  };
}
case UPLOAD_IMAGES_FAILURE: {
  return {
    ...state,
  };
}
```

`sagas/post.js`

```js
function uploadImagesAPI(formData) {
  return axios.post('/post/images', formData, {
    withCredentials: true
  });
}

function* uploadImages(action) {
  try {
    const result = yield call(uploadImagesAPI, action.payload);
    yield put({
      type: UPLOAD_IMAGES_SUCCESS,
      payload: result.data
    });
  } catch (e) {
    console.error(e);
    yield put({
      type: UPLOAD_IMAGES_FAILURE,
      error: e
    });
  }
}

function* watchUploadImages() {
  yield takeLatest(UPLOAD_IMAGES_REQUEST, uploadImages);
}

```

## 이미지 업로드 구현 - 서버

`routes/post.js`

```js
const express = require('express');
const multer = require('multer');
const path = require('path');

const db = require('../models');
const { isLoggedIn } = require('./middleware');

const router = express.Router();

const upload = multer({
  storage: multer.diskStorage({
    destination(req, file, done) {
      done(null, 'uploads');
    },
    filename(req, file, done) {
      const ext = path.extname(file.originalname);
      const basename = path.basename(file.originalname, ext);
      // abc.png, ext===.png, basename===abc
      done(null, basename + new Date().valueOf() + ext);
    },
  }),
  limits: { fileSize: 20 * 1024 * 1024 },
});

```

`multer`, `path`를 로드한다.

`multer`는 다소 설정이 필요하다.

`storage`는 저장 매체를 의미한다. 나중에 S3등으로 변경할 수 있다.

`filename`은 확장자와 파일명을 분리하여 사이에 시간을 추가한다.

`filesize`는 20M로 제한했다.

```js
router.post('/images', upload.array('image'), (req, res) => {
  console.log(req.files);
  res
    .status(200)
    .json({
      code: 200,
      message: 'Image upload success',
      data: req.files.map((v) => v.filename)
    });
});

```

`upload.array`는 이미지 파일을 여러 개 올릴 수 있다는 것을 의미한다.

한 장만 올릴 수 있게 하려면 `upload.single` 같은 것을 사용한다.

결과는 `req.files`에 저장된다. (single일 경우 `req.file`)

마지막으로 `index.js`에 static 경로를 추가한다.

```js
app.use(morgan('dev'));
app.use('/', express.static('uploads'));
app.use(
  cors({
    origin: true,
    credentials: true
  })
);

```

이제 프론트에서 이미지 업로드를 하면 미리보기까지 구현될 것이다.

## 이미지 삭제

```js
<div>
  {imagePaths.map((v, i) => (
    <div key={v} style={{ display: 'inline-block' }}>
      <img src={`http://localhost:8080/${v}`} style={{ width: '200px' }} alt={v} />
      <div>
        <Button onClick={onRemoveImage(i)}>제거</Button>
      </div>
    </div>
  ))}
</div>
```

제거 Button에 onClick 이벤트를 추가한다.

```js
const onRemoveImage = useCallback(index => () => {
    dispatch({
      type: REMOVE_IMAGE,
      index,
    });
  }, []);

```

각 이미지의 제거 버튼을 클릭했을 경우 REMOVE_IMAGE action을 발생시킨다.

onClink에서 일반적인 함수 호출을 한 것이 아니라 onRemoveImage(i)와 같이 호출했기 때문에 onRemoveImage는 고차함수로 정의한다.

reducer에 등록한다.

```js
case REMOVE_IMAGE: {
  return {
    ...state,
    imagePaths: state.imagePaths.filter((v, i) => i !== action.index)
  };
}

```

## 이미지와 포스트를 동시에 저장하기

`components/PostForm.js`

```js
const onSubmit = useCallback(
  (e) => {
    e.preventDefault();
    if (!text || !text.trim()) {
      return alert('Plz wrtie content.');
    }
    const formData = new FormData();
    imagePaths.forEach((i) => {
      formData.append('image', i);
    });
    formData.append('content', text);
    dispatch({
      type: ADD_POST_REQUEST,
      payload: formData
    });
  },
  [text, imagePaths]
);

```

기존에 text만 전달하던 것을 FormData 형식으로 변환하여 이미지까지 함께 전달한다.

`reducers/post.js`

```js
case ADD_POST_SUCCESS: {
  return {
    ...state,
    isAddingPost: false,
    isAddedPost: true,
    mainPosts: [action.payload.data, ...state.mainPosts],
    imagePaths: []
  };
}
```

`imagePaths`를 추가하여 성공적으로 저장되면 화면의 이미지 미리보기를 지운다.

`routes/post.js`

```js
router.post('/', isLoggedIn, upload.none(), async (req, res, next) => {
  try {
    const hashtags = req.body.content.match(/#[^\s]+/g);
    const newPost = await Post.create({
      content: req.body.content,
      UserId: req.user.id
    });

    if (hashtags) {
      const result = await Promise.all(
        hashtags.map((tag) =>
          Hashtag.findOrCreate({
            where: { name: tag.slice(1).toLowerCase() }
          })
        )
      );
      console.log('Hashtags: ', result);
      await newPost.addHashtags(result.map((r) => r[0]));
    }

    if (req.body.image) {
      // 이미지 주소를 여러개 올리면 image: [주소1, 주소2]
      if (Array.isArray(req.body.image)) {
        const images = await Promise.all(
          req.body.image.map((image) => {
            return Image.create({ src: image });
          })
        );
        await newPost.addImages(images);
      } else {
        // 이미지를 하나만 올리면 image: 주소1
        const image = await db.Image.create({ src: req.body.image });
        await newPost.addImage(image);
      }
    }

    const postInfo = await Post.findOne({
      where: { id: newPost.id },
      include: [
        { model: User, attributs: ['id', 'nickname'] },
        { model: Image }
      ]
    });

    return res
      .status(200)
      .json({ code: 200, message: 'Post saved.', data: postInfo });
  } catch (error) {
    console.error(error);
    next(error);
  }
});

```

multer를 이용하여 만든 `upload` 미들웨어가 여기서도 사용된다. (이미지 저장시에도 사용된다.)

이미 이미지들은 다 저장되었고 지금은 이미지 이름과 포스트를 DB에 저장하는 것이기 때문에 `upload.none()`을 사용한다.

multer에서 image의 파일명을 `req.body.image`에 저장한다.

image가 하나면 값, 여러개이면 배열로 저장된다.

Image 테이블에 src 컬럼 저장 후 PostId 저장을 위해 `addImages`, `addImage`를 사용했다.

모두 저장 후 다시 Post를 불러올 때 Image도 함께 불러온다.

Post 테이블의 데이터를 프론트로 전달하는 모든 라우터에 Image 테이블을 참조하도록 추가하자.
