# 파트7. 지연성 1

## range

숫자를 인자로 받아서 숫자의 크기만한 배열을 반환

```js
const range = l => {
  let i = -1;
  let res = [];
  while (++i < l) {
    res.push(i);
  }
  return res;
};

log(range(5));
log(range(2));
```

range로 생성한 배열의 합을 구해보자.

```js
log(reduce(add, range(5)));
```

## 느긋한 L.ragne

```js
const L = {};
L.range = function *(l) {
  let i = -1;
  while (++i < l) {
    yield i;
  }
};

var list = L.range(5);
log(list);
log(reduce(add, list));
```

range를 변경하고 동일하게 출력했다.
L.range는 `L.range {<suspended>}`라고 출력된다.

L.range는 next()가 호출될 때까지 아무일도 하지 않는다.

테스트를 해보자.

```js
function test(name, time, f) {
  console.time(name);
  while(time--) f();
  console.timeEnd(name);
}

test('range', 10, () => reduce(add, range(1000000)));
test('L.range', 10, () => reduce(add, L.range(1000000)));
```

지연 함수와 지연이 아닌 함수의 실행 순서를 비교해보자.

```js
go(range(10),
  map(n => n + 10),
  filter(n => n % 2),
  take(2),
  log);

go(L.range(10),
  L.map(n => n + 10),
  L.filter(n => n % 2),
  take(2),
  log);
```

지연이 아닌 go는 각 함수들이 순서대로 실행된다.

지연 함수를 포함한 go는 가장 먼저 take 함수가 실행된다.
take 함수에서 for...of를 만나서 이터러블을 순회하게 되면 가장 먼저 filter가 실행된다.
계속 실행해보면 역순으로 filter -> map -> range로 실행이 된다.

go의 첫 함수인 range의 인자가 크거나 작은 것에 상관없이 지연 함수로 작성한 코드는 일정한 시간이 걸리게 된다.

## map, filter 계열 함수들이 가지는 결합 법칙

사용하는 데이터가 무엇이던지
사용하는 보조 함수가 순수 함수라면
결합 법칙이 성립한다.
