# 5. 고차 함수
> 고차 함수는 다른 함수를 인자로 받거나 함수를 결과로 반환하는 함수다.

> 함수를 만들어 내는 함수라는 개념은 조금 이상하게 들릴수도 있다. 하지만 Callable 클래스의 객체에 대해 공부한다면 호출 가능한 객체를 반환하는 함수를 보게 된다. 그러한 함수는 다른 함수를 만들어 내는 함수의 한 가지 예다.

> 이번 장에서는 다음과 같은 함수를 살펴본다.
> * max() 와 min()
> * 고차 함수를 호출할 때 편하게 쓸 수 있는 람다식
> * map()
> * filter()
> * iter()
> * sorted()

> max(), min(), sorted() 함수는 고차 함수 역할 외에도 기본적으로 적용되는 동작 방식이 있다. 함수를 인자로 넘기기 위해서는 key=인자 형태를 사용해야 한다. map()과 filter() 함수는 함수를 첫 번째 위치 기반 인자로 받아들인다.

## max()와 min()을 사용해 최댓값, 최솟값 알아내기
> 각 3-튜플에는 시작 지점의 위치, 끝 지점 위치, 거리 값이 들어 있다. 위치는 위도와 경도의 쌍이다. 이 시퀀스에서 최대와 최소 거리를 찾는 데에는 세 가지 방법이 있다. 

> * 거리를 제네레이터 함수로 뽑아낸다. 그 함수는 오직 거리만을 돌려주고, 해당 구간의 시작과 끝 위치는 버린다. 최댓값이나 최솟값 구간의 위치 정보를 가지고 추가 처리를 해야 하는 경우에는 이러한 방식이 잘 들어맞지 않을 것이다.

> * `풀기(처리(감싸기()))` 패턴을 사용한다. 이렇게 하면 최대, 최소 거리가 있는 구간을 얻을 수 있다. 그로부터 거리만 필요하다면 거리만을 뽑아낼 수도 있다. 구간을 나태내는 두 위치 정보를 사용해 어떤 구간이 최대 또는 최소인지를 파악할 수 있다.

> * max()와 min()을 고차 함수로 사용한다.

```py
from ch02_ex3 import float_from_pair, lat_lon_kml, limits, haversine, legs

path = float_from_pair(lat_lon_kml())
trip = tuple((start, end, round(haversine(start, end), 4))
    for start, end in legs(iter(path)))
```

> 이 부분은 KML 파일에서 읽은 경로 정보에서 얻은 각 구간의 하버사인 거리를 기반으로 trip 튜플을 만든다. 일단 trip 객체를 만들고 나면 거리를 뽑아내 최대와 최소를 구할 수 있다.

```py
long, short = max(dist for start, end, dist in trip),
              min(dist for start, end, dist in trip)
print(long, short)
```

> 제네레이터 함수를 사용해 trip 튜플의 각 구간에서 필요한 원소를 뽑아낸다. 각 제네레이터 식이 오직 한 구간만을 소모하기 때문에 이 제네레이터 식을 반복해야만 한다.

> 다음은 풀기(처리(감싸기())) 패턴을 사용한 것이다. 실제로도 warp()과 unwarp()이라는 이름의 함수를 정의하여 패턴이 어떻게 동작하는지 명확히 이해할 수 있게 했다.

```py
def warp(leg_iter):
    return ((leg[2], leg) for leg in leg_iter)

def unwarp(dist_leg):
    distance, leg = dist_leg
    return leg

long, short = unwarp(max(warp(trip))), unwarp(min(warp(trip)))
print(long, short)
```

> 앞의 예와 달리 이 메서드는 최대와 최소 거리 구간의 모든 특성을 가져올 수 있다. 감싸는 함수는 튜플에서 거리를 뽑아내 거리와 원래의 튜플의 쌍을 만든다. 그 후 min(), max()의 기본 형태를 사용하여 거리과 구간 정보가 들어 있는 튜플을 처리한다. 처리한 후 첫 번째 원소를 없애면 구간 정보만 남는다.

> 마지막으로 가장 중요한 형태는 max()와 min()의 고차 함수 기능을 사용한다. 이를 위해 먼저 도우미 함수를 정의하고, 그 함수를 사용하여 구간의 컬렉션을 원하는 요약 형태로 축약한다.

```py
def by_dist(leg):
    lat, lon dist = leg
    return dist
long, short = max(trip, key=by_dist), min(trip, key=by_dist)
print(long, short)
```

> max()와 min()은 모두 반복 가능 객체와 함수를 인자로 받는다. 파이썬의 모든 고차 함수에서는 키워드 매개변수 `key=`를 사용해 필요한 키 값을 뽑아내도록 할 수 있다.

```py
wrap = ((key(leg), leg) for leg in trip)
return max(wrap)[1]
```

> max()와 min() 함수는 주어진 key 함수가 시퀀스의 각 원소를 2-튜플로 감싸고, 그 2-튜플을 처리한 후 2-튜플을 분해해 원래의 값으로 돌려놓는 것처럼 작동한다.

## 파이썬의 람다 식 사용하기
> 많은 경우 도우미 함수를 따로 정의하는 것은 필요 이상의 코드를 작성하게 된다. key 함수의 핵심을 식 하나로 표현할 수 있는 경우가 자주 있다. 그러한 경우조차 식 하나를 일일히 def문과 return문으로 감싸는 것은 낭비같아 보인다.

> 파이썬은 람다 형식을 사용해 고차 함수를 쉽게 사용할 수 있게 해준다. 람다 형식을 사용하면 작은 무명 함수를 쉽게 정의할 수 있다. 다만, 함수의 본문이 단일 식으로 이뤄져야 한다.

```py
long, short = max(trip, key=lambda leg: leg[2]),
              min(trip, key=lambda leg: leg[2])
```

> 파이썬에서 튜플의 원소에 대해 의미 있는 이름을 정의하는 방법은 namedtuple을 사용하는 것과 람다를 사용하는 두 가지가 있다. 두 방법은 동등하다.

> 람다를 사용하는 것이 이름 있는 튜플을 사용하는 것보다 더 쓸모 있는지는 분명하지 않다. 필드를 뽑아내기 위해 여러 람다를 정의하는 것은 이름 있는 튜플을 정의하는 것보다 더 많은 코드가 필요하다. 반면, 람다를 사용하면 전위 형식의 함수 호출 표기법을 사용할 수 있기 때문에 함수형 프로그래밍을 하는 상황에서는 그 편이 더 나을 것이다.

> 더 중요한 것은, 나중에 sorted() 예제에서 볼 수 있는 것처럼, sorted(), min(), max() 등의 함수에서 이름 있는 튜플보다 람다를 더 효과적으로 사용할 수 있다는 점이다.

## 람다와 람다대수
> 순수 함수 언어에 대한 책에서는 람다 대수와 하스켈 커리가 발명한 커링(currying)이라는 기법에 대해 설명할 필요가 있을 것이다. 하지만 파이썬은 그러한 람다 대수와는 거리가 멀다. 파이썬의 함수는 단일 인자의 람다 형식으로 환원되지 않는다.

> 커링은 functools.partial 함수를 사용해 구현할 수 있다.

## map() 함수를 사용해 함수를 컬렉션에 적용하기
map() 함수는 한 컬렉션을 다른 컬렉션으로 매핑한다. 이 함수는 주어진 함수를 원래 컬렉션의 모든 원소에 적용하여 결과 컬렉션을 만들어 내는 것을 보장한다. 이는 내장 함수를 데이터의 컬렉션에 적용하는 이상적인 방법이다.

## map에 람다 형식 사용하기
> 여행 경로의 각 구간 거리를 해리에서 일반 마일로 변경

```py
map(lambda x: (start(x), end(x), dist(x)*6076.2/5280), trip)

((start(x), end(x), dist*6076.12/5280) for x in trip)
```

> map()과 제네레이터 식은 완전히 동일하다.

> map() 함수와 제네레이터 식 사이의 중요한 차이점은 map() 함수가 제네레이터 식보다 더 빠른 경향이 있다는 점이다. 속도 향상은 보통 20퍼센트 정도다.

진짜일까? 간단한 코드를 만들어 비교해보자!

## map()을 여러 시퀀스에 활용하기
> 두 컬렉션에 있는 데이터를 각각 짝지워 사용해야 할 경우

```py
map(function, zip(one_iterable, two_iterable))

(function(x, y) for x, y in zip(one_iterable, two_iterable))
```

> map()과 동일한 기능을 하는 제네리이터

> 우리는 평면적인 리스트에서 튜플의 시퀀스를 끌어냈다. 각 튜플은 인접한 두 값을 포함할 것이다. zip() 함소는 더 짧은 목록이 끝나면 제대로 수행을 멈춘다. 하지만 zip(x, x[1:]) 패턴은 실체화한 시퀀스나 range() 함수로 만들어 낸 반복 가능 객체에만 작동한다.

```py
from ch02_ex3 import lat_lon_kml, float_from_pair, haversine

path = tuple(float_from_pair(lat_lon_kml()))
distance1 = map( lambda s_e: (s_e[0], s_e[1], haversine(*s_e)),
                zip(path, path[1:]))
```

> 여기서는 필요한 지점의 경로를 path 변수에 넣었다. 이는 위도, 경도로 이뤄진 쌍으로 이뤄진 수서가 있는 시퀀스다. 우리가 zip(path, path[1:]) 패턴을 사용할 것이기 때문에 일반적인 반복 가능 객체를 사용할 수 없으므로 이 시퀀스를 반드시 실체화해야 한다.

```py
distance2 = map(lambda s, e: ( s, e, haversine(s, e)), path, path[1:])
```

> 함수 하나와 반복 가능 객체 2개를 map() 함수에 제공했다. map() 함수는 각 반복 가능 객체의 다음 원소를 가져와서 그 두 값을 첫 번째 인자로 받은 함수에 전달한다.

## filter()를 사용해 데이터를 받아들이거나 거부하기
> filter() 함수의 목적은 술어(predicate)라고 불리는 어떤 의사결정 함수를 주어진 컬렉션의 모든 원소에 적용하는 것이다. True라는 결과가 나오면 그 값을 통과시키고, 그렇지 않으면 그 값을 거부한다. itertools 모듈에는 이와 비슷한 목적의 filterfalse() 라는 함수가 있다.

```py
long = list(filter(lambda leg: dist(leg) >= 50, trip))
```

```py
filter(lambda x: x%3==0 or x%5==0, range(10))
sum(_)
# 23
```

> 다음과 같이 제네레이터로 표현할 수도 있다.

```py
sum(x for x in range(10) if x%3==0 or x%5==0)
```

## filter()를 사용해 이상 값 식별하기
...

## iter() 함수와 끝을 표시하는 특별한 값 사용하기
> 내장 iter() 함수는 어떤 컬렉션 객체를 기반으로 하는 반복자를 만들어 낸다. 이를 사용해 어떤 컬렉션을 감싸 반복자를 만들 수 있다.

...

## sorted()를 사용해 데이터 정렬하기
> 파이썬에서 어떤 순서대로 결과를 만들어 내는 데에는 두 가지 방법이 있다. list 객체를 만들고, list.sort() 메서드를 사용해 원소를 정렬할 수 있다. 다른 방법은 sorted() 함수를 사용하는 것이다. 이 함수는 어떤 반복 객체에도 사용할 수 잇다. 다만, 정렬한 결과 list 객체를 만들어 낸다.

> sorted() 함수를 사용하는 방법은 두 가지다. 그냥 컬렉션에 이 함수를 적용할 수도 있다. 또한 key= 인자를 사용하는 고차 함수로 사용할 수도 있다.

```py
sorted(dist(x) for x in trip)
```
> 제네레이터 식을 사용하여 여행 데이터로 부터 거리만을 가져왔다. 거리를 원래의 3-튜플과 함꼐 계속 유지하고 싶다면, sorted() 함수에 key 함수를 지정하여 튜플을 정렬하는 방식을 사용할 수 있다.

```py
sorted(trip, key=dist)
dist = lambda leg: leg[2]
```

## 고차 함수 작성하기
> 고차 함수에는 세 가지 종류가 있다.
> * 인자 중 하나로 함수를 요구하는 함수
> * 함수를 반환하는 함수. Callable 클래스는 이러한 경우의 전형적인 예다. 제네레이터 식을 만들어 내는 함수도 고차 함수라고 생각할 수 있다.
> * 함수를 인자로 받고, 함수를 반환하는 함수. functools.partial() 함수가 전형적인 예다. 데커레이터도 여기에 속한다.

> 고차 함수를 사용하는 몇가지 일반적인 변환은 다음과 같다.
> * 객체를 감싸 더 복잡한 객체 만들기
> * 복잡한 객체를 구성 요소별로 분해하기
> * 구조를 평면으로 펼치기
> * 평면 시퀀스를 구조화하기

## 교차 매핑과 필터 작성하기
> 파이썬의 내장 고차 함수인 map()과 filter()는 처리하길 원하는 대두분의 처리를 일반적으로 감당할 수 있다. 하지만 성능을 더 높이기 위해 이를 일반적으로 최적화하기는 어렵다.

> 매핑을 기술하는 방법에는 세 가지가 있다. 어떤 함수 f(x)와 어떤 컬렉션 객체 C가 있다고 가정해보자.

> * map() 함수
```py
map(f, C)
```

> * 제네레이터 식
```py
(f(x) for x in C)
```

> * 제네레이터 함수
```py
def mymap(f, C):
    for x in C:
        yield f(x)
mymap(f, C)
```

> 마찬가지로 filter() 함수를 컬렉션 C와 술어 함수 f에 적용하는 데에도 세 가지 방법이 있다.

> * filter() 함수
```py
filter(f, C)
```

> * 제네레이터 식
```py
(x for x in C if f(x))
```

> * 제네레이터 함수
```py
def myfilter(f, C):
    for x in C:
        if f(x):
            yield x
myfilter(f, C)
```

> 하지만 성능상 다름 점이 있다. map()과 filter() 함수가 가장 빠르다. 더 중요한 것은 각각의 매핑, 필터와 어울리는 확장이 서로 다르다는 것이다.

> 각 원소에 좀 더 복잡한 g(x)를 적용하도록 만들거나 컬렉션 C를 처리하기 전에 함수를 적용할 수 있다. 이는 가장 일반적인 방법이며, 앞에서 설명한 세 가지 방식에 모두 적용할 수 있다. 이 부분에 함수적 설계 역량을 집중해야 한다.

> for 루프를 약간 변경할 수 있다. 분명한 것은 제네레이터 식을 if 절로 확장하여 매핑과 걸러내기를 한 연산과 조합하가는 것이다. 이와 마찬가지로 mymap()과 myfilter()를 합쳐 매핑과 걸러내기를 동시에 수행하게 만들 수도 있다.

> 우리가 만들 수 있는 가장 심오한 변화는 루프가 다루는 데이터의 구조를 변경시키는 것이다.

> 너무 많은 변환을 한 함수로 조합하는 매핑을 설계하는 경우에는 많은 주의를 기울여야 한다. 가능한 한 둘 이상의 개념을 함께 포현하거나 간결하지 못한 함수를 만드는 일을 피해야 한다. 파이썬 컴파일러가 최적화해주지 못하기 때문에 함수를 직접 합쳐 느린 애플리케이션을 최적화해야만 한다. 이러한 종류의 최적화는 가능한 한 피해야 하며, 성능이 떨어지는 프로그램을 프로파일링(profiling)한 후 최적화 여부를 결정해야 한다.

## 매핑하면서 데이터 풀기
> (f(x) for x, y in C)와 같은 구성을 사용할 경우, for문에 여러 가지 대입을 사용해 값이 여럿 들어 있는 튜플을 풀어 함수를 호출하는 것이다. 전체 식은 매핑이다. 이러한 식은 구조를 바꾸고 함수를 적용하기 위한 일반적인 파이썬 최적화 방법 중 하나다.

> 다음은 매핑을 진행하는 과정에서 데이터를 푸는 것을 보여주는 구체적인 예다.
```py
def convert(conversion, trip):
    return (conversion(distance) for start, end, distance in trip)
```

> 이 고차 함수는 다음과 같은 변환 함수에 의해 지원될 수 있다.
```py
to_mile = lambda nm: nm*5280/6076.12
to_km = lambda nm: nm*1.852
to_nm = lambda nm: nm
```

> 이 함수들을 사용해 거리를 뽑아내 변환 함수를 적용할 수 있다.

```py
convert(to_miles, trip)
```

> 고차 convert() 함수에 대해 언급해야 할 중요한 것 하나는 우리가 함수를 인자로 받고, 다른 함수를 결과로 내놓는다는 점이다. convert() 함수는 제네레이터 함수가 아니다. 그 안에는 yield()가 전혀 없다. convert() 함수의 결과는 각각의 값을 누적시키기 위해 평가해야만 하는 제네레이터 식이다.

> 매핑과 거르기를 조합하여 더 복잡한 함수를 만들 수도 있다. 더 복잡한 함수를 만들어 처리량을 감소시키는 것이 좋은 생각처럼 보일 것이다. 하지만 항상 그런 것은 아니다. 복잡한 함수가 단순한 map()과 filter()의 조합보다 성능이 더 나쁠 수도 있다. 일반적으로는 어떤 한 가지 개념을 담고 있거나 소프트웨어를 더 이해하기 쉽게 해주는 경우에만 더 복잡한 함수를 만들어야 한다.

## 매핑하면서 추가 데이터를 감싸기
> ((f(x) , x) for x in C)와 같은 요소를 사용한다면 매핑을 적용하면서 여러 값이 들어 있는 튜플을 생성하기 위해 감싸고 있는 것이다. 이러한 방식은 복잡하게 상태가 바뀌는 객체에 의존하지 않고도 여러 번 재계산하는 것을 피하는 이점을 누리면서 새로운 요소에 필요한 결과를 저장하기 위해 사용하는 일반적인 기법이다.

```py
from ch02_ex3 import float_from_pair, lat_lon_kml, limits, haversion, legs
path = float_from_pair(lat_lon_kml())
trip = tuple((start, end, round(haversine(start, end), 4))
              for start, end in legs(iter(path)))
```

> 이 코드를 변경하여 감싸는 작업을 별도의 함수로 분리할 수 있다.

```py
def cons_distance(distance, legs_iter):
    return ((start, end, round(distance(start, end), 4))
             for start, end in legs_iter)
```

> 이 함수는 각 구간을 두 변수 start와 end로 분해한다. 각각을 주어진 distance() 함수에 사용하여 두 지점 사이의 거리를 구한다. 결과는 두 지점과 계산한 거리를 포함하는 더 복잡한 3-튜플이다.

```py
path = float_from_pair(lat_lon_kml())
trip2 = tuple(cons_distance(haversin, legs(iter(path))))
```

> 제네레이터 식을 고차 함수 cons_distance()로 바꿨다. 이 함수는 함수를 인자로 받을 뿐만 아니라 제네레이터 식을 반환한다.

```py
def cons_distance3(distance, legs_iter):
    return ( leg+(round(distance(*leg), 4), ) for leg in legs_iter)
```

> 이 버전은 원래의 객체로부터 새로운 객체를 만들어 내는 과정을 더 명확하게 보여준다. 여행 구간에 대해 루프를 돌고, 한 구간의 거리를 계한 한 후 주어진 구간에 거리를 이어붙인 새로운 구조를 만든다.

## 매핑하면서 데이터 펼치기