# 프로그래밍의 정석

## Chpter4. 관점 - 프로그래머가 보는 시각

## 직교성(Orthogonality)
> 코드 간에 독립성과 분리성을 갖도록 한다. 2개 이상의 코드 덩어리가 있으면서 한쪽을 변경해도 다른 쪽에 영향을 주지 않는다면 해당 코드는 직교하고 있다.

> 직교하고 있는 코드는 변경에 강한 코드다.

> 코드 간의 결합도를 최소화하기 위해 계층화
> * 모듈들을 계층별로 정리하고 계층별로 추상화
> * 각 계층에서는 바로 하위 계층이 제공하는 추상화된 기능만을 사용
> * 이렇게 하면 상위 계층의 코드에 영향을 미치지 않고 하위 계층의 구현을 변경할 수 있음
> * 계층화에 의해 모듈 간의 관계가 정리됨

> 직교성을 충족하기 위해 전역 데이터는 사용하지 않도록 한다.

> 계층화의 장점
> * 다른 계층을 잘 알지 못해도 하나의 계층을 전체로서 생각할 수 있다.
>   * 이더넷의 동작 방법을 모르더라도 TCP 상에 있는 FTP 서비스를 구축하는 방법을 이해할 수 있다.
> * 다른 계층에 영향을 미치지 않고 대체 구현으로 계층을 교체할 수 있다.
> * 계층 간의 종속을 최소한으로 할 수 있다.
> * 계층은 표준화에 적합하다.
> * 계층을 구축하면 다양한 고수준 서비스가 해당 계층을 사용할 수 있다.

> 계층화의 단점
> * 계층 간의 변경이 연쇄적인 경우가 있다.
> * 계층을 추가하면 성능이 나빠질 수 있다.
>   * 계층을 지날 때마다 데이터 형식을 변환할 필요가 있는데 데이터 변환이 오버헤드가 될 수 있다.

> 릴레이션의 직교성
> * 관계형 데이터베이스의 기초 이론. 코드의 직교성과는 의미가 다르다.
> * 정규화
>   * 하나의 릴레이션(테이블)의 내부에서 중복을 없에는 것
> * 릴레이션의 직교성
>   * 여러 릴레이션 간의 같은 값을 포함하지 않는다는 의미

> 릴레이션의 정의
> * 테이블 간의 관계라는 의미가 아니다.
> * 관계 데이터 모델에서 릴레이션은 제목과 본체의 쌍으로 구성
>   * 제목: 임의의 개수로 구성된 속성의 집합
>   * 속성: 이름과 데이터형의 쌍
>   * 본체: 속성값의 집합인 튜플(레코드)의 집합
> * 릴레이션: 테이블
> * 속성: 컬럼
> * 튜플: 행

## 4.4 가역성(Reversibility)
> 어떤 변화가 발생해도 특정 조건을 가하면 원래 상태로 돌아오는 성질

> 특정 기술에 종속되지 않는다.
> * 가역성을 고려해서 데이터베이스 접근 부분이 추상화되어 있다면 현실적인 공수로 변경할 수 있다.

> 구체적인 상세 코드를 작성하기 전, 아키텍처 설계 시점에 가역성을 고려
> * 배치하는 플랫폼이나 서드파티 컴포넌트 등 해당 소프트웨어 이외의 것과 경계며네 해당하는 곳의 유연성은 가역성을 적용했을 때 효과가 크다.

## 4.5 코드의 악취
> 리펙토링이란 외부에서 보는 코드의 동작을 바꾸지 않고 코드 내부의 구조를 개선하는 기법
> * 중복된 코드는 하나의 함수로
> * 함수가 너무 길면 분할
> * 모둘이 너무 크다는 것은 역할이 너무 많다는 것이다. 분할하게 작게

## 4.6 기술 부채
> 소프트웨어 개발에서 시간을 채용한다는 개념은 해야 할 일을 어떻게든 완수해 내면서 위험 요소가 있는 마일스톤을 달성하는 데 도움이 되는 전략

> 소프트웨어는 일시적으로 불완전한 상태가 되지만 불안 요소가 책임하에 관리된다면 타당한 선택

> 긴급 배포를 통해 재앙을 피했다면 즉시 변경 전 상황으로 되돌리고 거기서부터 본래 있어야 할 깨끗한 코드로 수정해야 한다.

> 지저분한 코드를 기억하고 있는 동안에, 담당자가 아직 있는 동안에 재빨리 변제하는 것이 가장 확실한 방법이다.

> 그리고 곧장 다음 배포에 해당 수정을 집어넣도록 한다.

## 5. 습관 - 프로그래머의 일상

## 5.3 성능 튜닝에 관한 금언
> 너무 이른 시점의 최적화는 모든 악의 근원이다.

> 아키텍처를 설계할 때는 성능을 고려하는 쪽이 좋은 경우도 있다.
> * 조기에 수행한 성능 테스트는 그 뒤로도 계속해서 수행한다.
> * 변경을 가했을 때 성능이 급감하는지 알 수 있다.

## 5.5 한 걸음씩 조금씩
> 필요한 테스트 코드를 전부 작성한 다음에 정식 코드를 전부 작성하는 방식으로 해서도 안 된다.

> 조금씩 테스트 코드를 작성하고 조금씩 정식 코드를 작성하는 과정을 반복해야 한다.

> 신규 함수를 작성할 때 아직 어디에서도 사용되지 않는다고 해도 일단 컴파일 함으로써 문법 오류가 없다는 점을 확인할 수 있다.

## 6. 기법 - 프로그래머의 도구 상자

## 6.1 예광탄
> 프로그래밍에서 예광탄이란 우선적으로 검증하고 싶은 부분을 선행적으로 프로그래밍하는 것이다. 간이 형태라도 상관없으니 싱제 환경에서 동작하고 확인할 수 있는 종단간(end-to-end) 소프트웨어를 작성한다.

> 소프트웨어 개발에서 예광탄과 똑같은 효과를 내려면, 소프트웨어의 최종 형태에 대한 결정을 신속하고 눈에 보이는 형태로 반복해서 제시할 수 있어야 한다. 그렇게 하려면 일부만이라도 실물 소프트웨어가 필요하다.

> 예광탄 프로그램의 장점
> * 사용자로부터 피드백
> * 프로그래머가 활약할 수 있는 무대를 조기에 정비
> * 디버깅과 테스트를 빠르고 정확하게
> * 항상 테모를 수행할 수 있는 환경 마련
> * 사례 단위로 개발에 착수할 수 있다 생선성의 보고나 사용자에 대한 진척 보고가 간단해진다.

> 프로토타입
> * 최종 사용자가 사용성을 확인할 수 있는 정도의 화면 레이아웃이나 유사 조작을 추가
> * 버튼을 눌렀을 때 실제적인 기능이 동작하지 않아도 상관없다.
> * 사용자 인터페이스에 대한 합의를 이룬 시점에서 폐기

> 예광탄
> * 프로그래머에게 앞으로 계속 사용할 아키텍처의 골격을 제공
> * 사용자에게 어떤 사용성이 있는지 제시

## 6.2 계약에 의한 설계
> 사전조건: 함수를 호출하는 쪽이 지켜야 할 계약

> 사후조건: 함수가 지켜야 할 계약

> 함수와 함수를 호출하는 쪽이 서로 계약을 맺고 있다고 간주하고 프로그래밍 하는 것을 가리켜 '계약에 의한 설계'라고 한다.

> 올바른 파라미터를 전달하는 것은 함수를 호출하는 쪽의 책임이다.

> 함수의 맨 마지막에서는 함수가 사후 조건을 충족해야 한다. 함수 호출 후에 보증되어야 할 조건을 갖추는 것은 함수 쪽의 책임이다.

> 계약의 장점
> * 코드가 올바르다는 것을 보증할 수 있다. 올바른 코드란 요구되는 것 이상도 이하도 수행하지 않는 코드를 뜻한다.
> * 코드를 단순하게 만들 수 있다. 사전 조건이 충족되어 있다고 가정해서 함수의 처리 코드를 작성할 수 있기 때문이다.
> * 문제를 조기에 발견하기 쉬워진다. 계약을 완수할 수 없는 뭔가가 발생했는데도 이를 놓치는 거은 장애의 시작이다. 문제 발생 시점에서 조기에 크래시를 발생시켜야 장애를 진단하기 쉬워진다.

> * 계약 내용을 미리 함수의 주석으로 알려두자.
> * 계약 이행의 확인을 위한 코드는 단정문으로 표현하자.
> * 사전 조건과 사후 조건의 확인에는 단정문을 사용해서 계약이 이행되지 않았다면 소프트웨어가 중지되도록 해둔다.

> * 호출받는 함수 쪽에서는 건네받은 파라미터를 조정해서는 안 된다.
> * 호출받는 함수 쪽에서 파라미터를 검사하고 사전 조건에 맞게끔 변환하는 처리를 해서는 안 된다.
> * 이런 처리는 함수를 호출하기 전에 호출하는 쪽에서 수행한다.
> * 호출받는 함수 쪽은 계약에 근거하여 안심하고 파라미터를 사용해야 한다.
> * 결과적으로 코드가 단순해진다.
> * 다만 호출받는 함수 쪽에서는 상정 외의 파라미터가 넘어왔을 때를 대비해 계약 이행을 단정문으로 확인해서 디버깅 효율성을 높인다.

> * 외부 입력값 중 대표적인 것이 화면에서의 사용자 입력값이다.
> * 다만 사전 조건은 어디까지나 '함수'와 '함수를 호출하는 쪽'의 계약이지, '함수'와 '사용자 입력'의 관계가 아니다.
> * 계약을 완수하지 못했다는 말은 사용자의 입력 실수와는 질적으로 다른 현상이다.
> * 사용자 입력 확인은 함수를 호출하기 전에 함수를 호출하는 쪽에서 수행한다.

> * 뭐든지 받아들이고 언제나 제대로 된 결과를 보증할 수 있게끔 하려면 대량의 코드를 작성해야 한다.
> * 그렇게 되지 않도록 처리를 시작하기 전에 받아들이는 사전 조건을 엄격하게, 결과를 반환할 때는 가능한 한 사후 조건을 적게 하자.

> 클래스 불변 표명
> * 클래스를 사용하는 쪽에 대해 항상 참이 된다는 것을 보증하는 것
> * 메서드의 내부 처리 중에는 보증되지 않지만 메서드가 종료되어 제어가 호출한 쪽으로 돌아감과 함께 클래스 불변 표명이 보증된다.
> * 보증하는 것은 클래스 쪽의 책임이다.

> 단정문
> * 코드에서 상정 외의 사항은 단정문을 통해 표현한다.
> * 단정문이 참이라는 말은 모든 것이 순조롭게 실행되고 있다는 것을 의미
> * 단정문이 거짓이면 소프트웨어는 실행을 중단하고 오류 메시지를 표시해서 알려준다.
> * 단정문에 넘겨주는 조건식에는 변수값을 바꾸는 등의 부작용이 없도록 한다.
> * 단정문은 배포본 소프트웨어에는 넣지 않는다.

## 6.3 방어적 프로그래밍
> '이렇게 될 것이다'라고 결정짓지 말고 프로그래밍한다.

> 함수에 잘못된 데이터가 넘어왔을 때 그것이 다른 함수 탓이었다고 해도 피해를 입지 않도록 방어적인 코드를 작성해 둔다.

> 외부 소스에서의 데이터 입력값을 확인한다.(상정 내의 오류를 검출)
> * 파일, 사용자 인터페이스, 네트워크, 그 밖에 외부 인터페이스로부터 데이터를 얻어 온다면 데이터가 허용 범위 내에 들어와 있다는 것을 확인한다.
> * 숫자가 유효 범위에 포함되어 있는지
> * 문자열의 길이가 규정 안에 있는지
> * 무효한 입력을 가으한 한 조기에 검출하고 즉시 적절한 오류 처리를 수행한다.

> 함수의 입력 파라미터값을 확인한다.(상정 외의 오류를 검출)
> * 다른 함수에서 전달된 함수의 입력 파라미터 값을 확인한다.
> * 외부에서 전달된 데이터를 확인하는 것과는 달리, 여기서 무효한 입력을 검출한다는 것은 버그를 의미한다.
> * 단정문을 사용해서 파라미터르 확인하고 잘못된 값을 때는 즉시 프로그램을 정지한다.

> 코드에 바리케이드를 구축한다.
> * 바리케이드를 구축하려면 특정 인터페이스를 '안전지대로의 경계'로 사용한다.
> * 안전지대로의 경계를 통과하는 데이터를 검증해서 잘못된 데이터에는 적절한 조치를 취한다.

> 상정 외의 오류는 '단정문'으로 대응하고, 상정 내의 오류는 각각 적절한 '오류 처리'로 대응한다.
> * 바리케이드 외부에서 데이터가 들어오면 바리케이드(검증 모듈)을 거친다.
> * 바리케이드에서 '오류 처리'를 적용한다.
> * 바리케이드 내부에서 데이터 오류가 발생했다면 '오류 처리'가 아닌 '단정문'을 적용한다.


