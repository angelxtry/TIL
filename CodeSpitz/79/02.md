# 02

## 객체지향 프로그래밍

1. 대체가능성
2. 내적일관성, 내적동질성

대체가능성

- 상위형은 하위형을 대체할 수 있다.

```js
const Parent = class{
  wrap(){
    this.action();
  };
  action(){console.log("Parent");}
};
const Child = class extends Parent{
  action(){console.log("Child");}
};
const a = new Child();
console.log(a instanceof Parent)
a.wrap(); // child가 실행
```

- 상속보다 확장이 맞는 말이다.
- 자식은 부모를 대체할 수 있다.

----

최대한 개별 알고리즘을 함수로 분리한다.
어떻게 if를 제거할 것인가?
코드에 case가 하드코딩되어 있으면 코드를 안건드릴 수 없다.

if문 내부의 로직을 함수로 만든다.

문제 1. 경우가 변경될 때
문제 2. 함수 간 공통 부분

절차(Procedure) 지향 프로그램의 공통 의존 데이터 문제
공통 부분의 의존성이 점점 커진다.
상태에 대한 의존성이 더 커져서 상황이 좋아진 것 같지만 점점 안좋아 진다.
변화를 수용할 수 없는 상황을 만든 개발자의 문제다 ㅋㅋㅋ
껍데기만 객체 지향적이다.

객체지향: 은닉과 캡슐화를 이용하여 데이터를 완전히 숨겨버리겠다.
메시지와 api등으로만 데이터를 주고 받겠다.
이런 방식을 사용하여 Procedure 지향 프로그램을 하지 말아야 한다.

알고리즘 분화 시 객체지향에서 선택할 수 있는 두 가지 방법

- 상속 위임
  - 내부 계약 관계로 추상층에서 공통 요소를 해결하고 상태를 공유할 수 있음
  - 확장된 쪽이 부모를 알고 있다.
- 소유 위임
  - 외부 계약 관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함
  - 객체끼리 통신하는 통신망을 확립해야 한다.
  - GdF의 디자인 패턴이 주로 소유 위임을 사용한다. 따라서 부가적인 형이 많이 생긴다.

정의시점과 실행시점
상속위임을 사용하면 정의시점에서 if를 제거하고 실행시점에서 if를 사용하게 된다.

상속된 객체가 너무 많다면 전략 패턴으로 바꿀 수 있다.

커맨드 패턴이 좀 더 유연하다.

코드로 굽지 않고 런타임에 정의하여 사용할 수 있는 방식을 원한다.
