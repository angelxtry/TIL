# numpy

## numpy가 빠른 이유
* numpy는 다차원 배열 객체인 ndarray를 기본 데이터 저장 포멧으로 사용한다.
* ndarray는 데이터와 메타 데이터(차원, 데이터 타입 등)로 이루어져 있다.
* ndarray는 데이터를 시스템상의 메모리에 빈틈없이 빽빽히 배치한다.
* 파이썬의 기본자료형인 리스트는 각 요소가 메모리에 흩어져 저장된다. id 함수로 확인할 수 있다.

## numpy의 데이터 타입
* 파이썬의 내장 데이터 타입을 사용할 때는 세부적인 타입을 지정할 수 없다.
* 이 점은 데이터가 어떤 포맷으로 저장되었는지 신경 쓸 필요 없는 프로그램에서는 장점이다.
* 코드 작성은 간단해지지만 메모리를 낭비할 가능성이 있다.
* numpy는 독자적인 데이터 타입을 사용하여 불필요한 메모리 사용을 피할 수 있다.

```py
a = np.uint16(32)  # 16비트 unsigned int
a = np.array([123.123, 234.234], dtype=np.single)
```

## 배열과 행렬
* numpy의 배열과 행렬은 모두 일반적인 의미의 배열이다.
* 차이점은 행렬곱 연산에 사용되는 연산자가 다르다는 것 뿐이다.
```py
A = np.array([[1, 2], [3, 4]])  # 배열(ndarray) 생성
B = np.matrix([[1, 2], [3, 4]])  # 행렬 생성
```

* numpy에서 배열은 ndarray라는 객체로 표현된다.

## ndarray 생성하기
```py
matB = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])  # 리스트로 ndarray 생성
matC = np.array(((1, 2, 3), (4, 5, 6), (7, 8, 9)))  # 튜플로 ndarray 생성
```
* 일반적인 파이썬의 중첩 리스트와 비교하여 ndarray는 다음과 같은 특징을 같는다.
    * 메모리 상의 연속적 공간에 데이터가 저장된다.
    * 기본적으로 모든 요소가 같은 데이터 타입이다.
    * 각 차원마다 요소 수가 같아야 한다.
    * 배열 안의 모든 요소, 또는 일부 요소에 대해 특정 연산을 고속으로 수행할 수 있다.
* 파이썬의 중첩 리스트를 사용하는 경우 링크가 각 셀을 결합하고 있는 형태로 메모리상에 저장되기 때문에 객체의 구성을 동적으로 변경할 수 있다.
* ndarray는 형상 변경을 하려면 전체 요소에 대한 삭제 및 재생성이 필요하다.
```py
np.zeros((2, 3))  # 모든 요소가 0, 퓨틀로 지정한 크기를 갖는 ndarray
np.arange(10, 20, 2)
```
* `arange([start,] stop[, step][, dtype])`
    * stop이 부동 소수 타입인 경우 stop값이 포함된다.

## ndarray의 속성
* T: 전치행렬 리턴(self.transpose())
* dtype: 배열의 데이터 타입
* flat: 1차원 배열처럼 동작하는 반복자 객체 리턴
* size: 모든 요소의 수
* nbytes: 전체 데이터 크기
* ndim: 배열의 차원
* shape: 배열의 형상을 나타내는 튜

## ndarray의 인덱싱
* 기본 인덱싱(basic indexing)과 응용 인덱싱(fancy indexing)이 있다.

### 기본 인덱싱(basic indexing)
* 인덱싱으로 뷰를 생성
* view: ndarray의 일부분에 접근하기 위해 만든 참조를 의미
* 사본을 만들지 않기 때문에 뷰를 아무리 많이 만들어도 메모리 사용량은 크게 늘어나지 않는다.
* 뷰의 요소를 변경하게 되면 원래 ndarray의 요소도 변경된다.
* 기본 인덱싱 방법
    * 인덱싱
    * 슬라이싱
    * ndarray 고유의 인덱싱 및 슬라이싱

```py
In [2]: import numpy as np

In [3]: x2d = np.arange(12).reshape(3, 4)

In [4]: x2d
Out[4]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [5]: a = x2d[1][1:]

In [6]: a
Out[6]: array([5, 6, 7])

In [7]: a[0] = 50

In [8]: x2d
Out[8]:
array([[ 0,  1,  2,  3],
       [ 4, 50,  6,  7],
       [ 8,  9, 10, 11]])
```
* 슬라이싱을 이용해 a를 만들고 a의 요소를 변경했다.
* x2d에도 변경한 내용은 그대로 적용된다.

```py
In [8]: x2d
Out[8]:
array([[ 0,  1,  2,  3],
       [ 4, 50,  6,  7],
       [ 8,  9, 10, 11]])

In [9]: b = x2d[1:, 1:]

In [10]: b
Out[10]:
array([[50,  6,  7],
       [ 9, 10, 11]])

In [11]: b[:, :] = 100

In [12]: b
Out[12]:
array([[100, 100, 100],
       [100, 100, 100]])

In [13]: x2d
Out[13]:
array([[  0,   1,   2,   3],
       [  4, 100, 100, 100],
       [  8, 100, 100, 100]])
```
* x2d[1:, 1:]과 같이 ndarray를 슬라이싱 할 수 있다.
* b[:, :]는 결국 2차원 배열의 모든 항목을 의미한다.
* ndarray의 슬라이싱도 뷰를 수정하면 원본에도 적용된다.

### 응용 인덱싱을 통한 참조
* 응용 인덱싱은 ndarray의 뷰를 만드는 것이 아니라 사본을 만든다.
* 응용 인덱싱 방법
    * 부울 값 인덱싱
    * 정수 배열 인덱싱
    * np.ix_ 함수를 사용한 인덱싱

```py
In [14]: dat = np.random.rand(2, 3)

In [15]: dat
Out[15]:
array([[4.88287890e-01, 2.43693535e-04, 4.43292513e-01],
       [8.80618994e-01, 6.80749181e-01, 9.50893860e-01]])

In [16]: bmask = dat > 0.5

In [17]: bmask
Out[17]:
array([[False, False, False],
       [ True,  True,  True]])

In [21]: highd = dat[bmask]

In [22]: highd
Out[22]: array([0.88061899, 0.68074918, 0.95089386])

In [23]: highd[0] = 100
In [25]: highd
Out[25]: array([100.        ,   0.68074918,   0.95089386])

In [26]: dat
Out[26]:
array([[4.88287890e-01, 2.43693535e-04, 4.43292513e-01],
       [8.80618994e-01, 6.80749181e-01, 9.50893860e-01]])
```
* `highd = dat[bmask]` 가 부울 값 인덱싱이다.
* 특정 조건으로 부울 값으로 된 ndarray를 만들고 이 ndarray를 이용하여 원본 ndarray에 대해 인덱싱을 수행한다.

```py
In [33]: nda = np.arange(10, 20, 1)

In [34]: nda
Out[34]: array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

In [35]: ndb = nda[1:4]

In [36]: ndb
Out[36]: array([11, 12, 13])

In [37]: ndc = nda[[1, 2, 3]]

In [38]: ndc
Out[38]: array([11, 12, 13])

In [39]: ndb == ndc
Out[39]: array([ True,  True,  True])

In [40]: ndb[0] = 100

In [41]: ndb
Out[41]: array([100,  12,  13])

In [42]: nda
Out[42]: array([ 10, 100,  12,  13,  14,  15,  16,  17,  18,  19])

In [43]: ndc[0] = 555

In [44]: ndc
Out[44]: array([555,  12,  13])

In [45]: nda
Out[45]: array([ 10, 100,  12,  13,  14,  15,  16,  17,  18,  19])
```
* ndb는 일반적인 슬라이싱이고 nda에 대한 뷰가 만들어진다.
* 그래서 ndb를 변경하면 nda도 함께 변경된다.
* ndc는 정수 배열을 통한 인덱싱이다.
* `ndc = nda[[2, 1, 3]]`과 같은 방식으로 ndc를 생성해도 문법적으로는 전혀 문제가 없다.
* 정소 배열을 통한 인덱싱은 뷰가 아니라 사본으로 만들어진다.

```py
In [48]: nda = np.arange(12).reshape((3, 4))

In [49]: nda
Out[49]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [50]: ndb = nda[[0, 2, 1], [3, 3, 3]]

In [51]: ndb
Out[51]: array([ 3, 11,  7])
```
* (0, 3), (2, 3), (1, 3)의 값으로 ndb를 생성했다.
* ndb도 뷰가 아닌 사본이다.

```py
In [53]: nda[np.ix_([0, 1, 2], [1, 3])]
Out[53]:
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11]])
```
* np.ix_ 함수를 사용할 수도 있다.
* np.ix_의 첫 번째 인자는 axis 0을 의미하고 두 번째 인자는 axis 1을 의미한다.

## 뷰와 사본
* ndarray의 복사가 얕은지 깊은지를 생각할 필요가 있는 경우는 ndarray가 객체 타입 배열일 때 뿐이다.
* 객체 타입이란 예를 들어 정수 타입과 딕셔너리 타입을 하나로 합친 특수한 객체 등을 말한다.
* numpy 스칼라 타입을 요소로 갖는 ndarray에는 배열의 차원과 상관없이 얕은 복사와 깊은 복사의 차이가 없다.
* 복사의 원본과 사본이 완전히 독립되어 값을 변경할 수 있는 상태가 된다.

### numpy에서 뷰라고 하는 참조가 생성되는 경우는 다음과 같다.
```py
b = a  # a는 ndarray
b = a[:]  # b = a와 동일
b = a[1:]  # a 의 부분배열
b = a.reshape((3, 2))  # reshpae 메소드
b = np.reshape(a, (3, 2))  # reshape 함수
b = np.array(a, copy=false)  # copy=false 이므로 뷰가 생성됨
```

```py
In [77]: a = np.arange(10)

In [78]: b = a[:]

In [79]: a is b
Out[79]: False

In [80]: b[1] = 100

In [81]: b
Out[81]: array([  0, 100,   2,   3,   4,   5,   6,   7,   8,   9])

In [82]: a
Out[82]: array([  0, 100,   2,   3,   4,   5,   6,   7,   8,   9])
```

```py
In [85]: a = list(range(10))

In [86]: a
Out[86]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [87]: b = a[:]

In [88]: a is b
Out[88]: False

In [89]: b[1] = 100

In [90]: a
Out[90]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [91]: b
Out[91]: [0, 100, 2, 3, 4, 5, 6, 7, 8, 9]
```
* 위의 두 예제를 비교해보자.
* 첫 번째 예제는 ndarray를 슬라이싱하여 할당
* 두 번째 예제는 list를 슬라이싱하여 할당
* ndarray를 슬라이싱하여 할당할 경우 a와 b의 주소값은 달라지지만, 한 쪽의 값을 변경할 경우 둘 다 동일하게 수정된다.
* list를 슬라이싱하여 할당할 경우 b의 값의 변경이 a에 영향을 주지 않는다.

```py
In [70]: a = np.arange(10).reshape(2, 5)

In [71]: a
Out[71]:
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

In [72]: b = a[:]

In [73]: a is b
Out[73]: False

In [74]: b[0][1] = 100

In [75]: b
Out[75]:
array([[  0, 100,   2,   3,   4],
       [  5,   6,   7,   8,   9]])

In [76]: a
Out[76]:
array([[  0, 100,   2,   3,   4],
       [  5,   6,   7,   8,   9]])
```
* ndarray의 경우 당연히 2차원 배열이라도 동일한 결과.

### 얕은 복사가 만들어지는 경우
```py
b = a[a > 10]  # 부울 값에 의한 응용 인덱싱
b = a[[1, 2, 3]]  # 정수 배열에 의한 응용 인덱싱
b = a[np.ix_([0, 1], [1, 2])]  # ix_ 함수에 의한 응용 인덱싱
b = a.copy()  # 복사 메서드
b = np.copy(a)  # 복사 함수
b = np.clip(a, -0.1, 0.1) # clip 함수
b = a.flatten()  # faltten 메서드
```
* numpy의 스칼라 타입을 요소로 갖는 ndarray에서는 깊은 복사와 동일하다.

### 깊은 복사는 copy.deepcopy() 함수를 사용한다.

## 메모리의 방향
* C와 같은 행방향을 우선하는 배치 방법과 Fortran과 같이 열방향을 우선하는 방식이 있다.
* default는 행 방향 우선이다.
* order 키워드 인자를 사용하여 지정한다.
```py
np.arange(12).reshape(3, 4, order='C')  # 행방향 우선
np.np.zeros((3, 4), order='F')  # 열방향 우선
```

## 유니버셜 함수 ufunc
* ufunc란 ndarray의 모든 요소를 ufunc에 넣어 처리한 후 결과를 리턴하는 함수
* map과 유사한듯?
```py
In [98]: a = np.arange(12).reshape(2, 6)

In [99]: np.square(a)
Out[99]:
array([[  0,   1,   4,   9,  16,  25],
       [ 36,  49,  64,  81, 100, 121]], dtype=int32)
```

## 파이썬 함수를 ufunc로 만들기
```py
In [102]: a
Out[102]:
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])

In [103]: myfunc = lambda x, y: 2*x + y

In [105]: myfunc_array = np.frompyfunc(myfunc, 2, 1)

In [107]: myfunc_array(a, 3)
Out[107]:
array([[3, 5, 7, 9, 11, 13],
       [15, 17, 19, 21, 23, 25]], dtype=object)
```
* frompyfunc를 테스트해보기 위해 lambda 함수를 만들었다.
* frompyfunc는 인자로 함수, 입력 parma의 갯수, return 값의 갯수를 받는다.
* 위의 예는 입력 param이 2개인 함수다.
* return 값이 1개 이상인 경우는 어떻게 사용하는지 감이 안온다.
* 표준 함수가 아닌 사용자 정의 함수도 ufunc로 사용하는 것이 이득이 있는지는 모르겠다.
