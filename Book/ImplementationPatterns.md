# 켄트 벡의 구현 패턴

## 01. 소개

> 프로그래머 여러분들이 이 책을 읽고 자신의 의도를 코드로 표현해 다른 이들과 커뮤니케이션하게 되길 바란다. ... 결국 이 책 전체는 커뮤니케이션을 돕는 프로그래밍 기법에 초점을 두고 있다.

> 코드를 통한 커뮤니케이션에는 몇 가지 단계가 있다. 첫 단계는 생각을 하며 프로그래밍하는 것이다. ... 특정 메소드의 이름을 왜 그렇게 지었는지, 어떤 기능이 왜 특정 객체에 있어야 하는지 내가 확신하는 이유를 설명할 수 없었다. 커뮤니케이션을 위한 코드를 작성하기 위한 첫 단계는, 본능에 의해 코딩하는 것을 멈추고 내가 어떤 생각을 하고 있는지 살펴볼 수 있는 여유를 갖는 것이다.

> 다음 단계는 다른 사람들의 중요성을 인정하는 것이다. ... 프로그래밍은 한 사람과 기계 사이의 외로운 교류, 그 이상의 것이 될 수 있다. 다른 사람들을 배려하는 프로그래밍을 하기 위해서는 먼저 그렇게 하겠다는 본인의 의사가 있어야 하고, 이를 효과적으로 달성하기 위한 연습이 필요하다.

> 마지막으로 3단계. 다른 사람의 존재도 내 존재만큼 중요하다는 생각을 한 후, 그러한 생각을 실천으로 옮기게 되었다. 나는 이 책에 소개된 구현 패턴을 사용해 의식적으로 나 자신만을 위한 코드가 아닌 다른 사람을 위한 프로그램을 작성하기 시작했다.

## 02. 패턴

> 대부분의 프로그램에는 다음과 같은 법칙이 적용된다.
> * 프로그램을 새로 짜는 경우보다는 기존 프로그램을 읽는 경우가 많다.
> * 프로그램에 있어 완성은 없다. 최초에 프로그램을 개발하는 데 드는 노력보다는 이후 프로그램을 수정하는 데 들어가는 노력이 더 크다.
> * 프로그램 구조는 몇 가지 상태와 제어 흐름 개념으로 결정된다.
> * 프로그램을 읽는 사람은 개념과 더불어 세부 사항까지도 이해해야 한다. 세부 사항을 이해해야 전체 개념에 대한 그림을 그릴 수 있고, 한편 전체 개념을 이해해야 세부적인 구현 내용을 이해할 수 있기 때문이다.

> 패턴은 반복적으로 일어나는 문제에 대한 합리적인 해결책을 제공해서 프로그래머가 남는 시간과 에너지, 창의력을 진정 독창적인 문제 해결에 사용할 수 있게 해준다.

## 03. 프로그래밍 이론
> 각 패턴의 배경에는 어느 정도 이론이 깔려 있다. 하지만 실제 프로그래밍에서는 각 패턴에서 설명하는 이론 외에도 결정 사항에 영향을 미치는 동력(force)이 존재한다. force는 가치(value)와 원칙(principle)의 두 가지로 나눈다.

> 가치는 모든 프로그래밍에 적용되는 주제다. 프로그램을 잘 짜는 사람은 타인과의 커뮤니케이션을 중시하고, 코드의 과도한 복잡성을 피하면서도 유연성 있는 코드를 작성한다. 커뮤니케이션, 단순성, 유연성의 가치는 프로그래밍 할 때 내리는 모든 의사 결정에 영향을 미친다.

> 원칙은 가치처럼 언제나 적용되는 것은 아니지만 많은 패턴에서 사용된다. 항상 중요하지만 때로는 직접 적용하기 어려운 가치와, 적용법은 명확하지만 조금은 지엽적인 패턴 사이의 가교 역할을 하는 것이 바로 원칙이다.

### 가치
* 커뮤니케이션
> 개발자가 코드를 쉽게 이해하거, 수정하고, 사용할 수 있다면 그 코드는 개발자와 커뮤니케이션을 하고 있다고 이야기할 수 있다. ... 타인을 고려해서 프로그램을 짜면 여러가지 좋은 점이 있다. 내 코드는 좀 더 이해하기 쉽고 깔끔해지며, 더 효율적이 되고 생각은 명확해진다. 새로운 관점에서 코드를 바라보게 되고, 스트레스가 줄어들며, 다른 사람도 볼 만한 코드가 만들어진다.

> 크누쓰는 프로그램을 책처럼 읽을 수 있어야 한다고 주장했다. 프로그램도 책처럼 줄거리가 있어야하며 리듬감을 가지고 상큼한 표현 등을 지녀야 한다는 것이다.

> 커뮤니케이션에 초점을 맞춰서 프로그래밍을 하면 경제적으로도 효과가 높다. 소프트웨어 비용의 대부분은 소프트웨어가 개발된 후에 발생한다. 내 경험에 비춰봐도 기존 코드를 읽고 수정하는 데 걸린 시간이 코드를 새로 짜느라 걸린 시간을 압도한다. 따라서 내가 짜는 코드의 개발 비용을 줄이기 위해서는 이해하기 쉬운 코드를 작성해야 한다.

> 커뮤니케이션에 관심을 기울이다 보면 좀더 현실적인 관점에서 코드를 짜게 된다. 우선 더 많은 생각을 하며 코드를 짜기 때문에 코드가 좋아진다. '다른 사람이 이걸 보면 어떤 생각을 할까?' 라는 생각을 하면 내 자신과 컴퓨터만 생각하며 코드를 짤 때와는 다른 신경세포가 내 머릿속에서 동작한다. 때로는 나만의 관점에서 벗어나 새로운 시각에서 문제를 바라보고 신선한 해결책을 찾게 되기도 한다. 이 밖에도 내가 제대로 된 관점에서 제대로 된 일을 하고 있다는 안도감 때문에 스트레스가 줄어들어 코드의 질이 좋아진다. 결국 우리는 사회적 존재이므로 실제 사회적 문제들을 무시하기보다는 고려하는 편이 더 현실적이다.

* 단순성
> 프로그램을 최대한 단순화하라. 의미 없는 코드는 모두 제거하라. 설계 시에도 과도한 요소는 모두 빼고, 요구 사항을 분석해서 꼭 필요한 사항만을 뽑아내라. 과도한 복잡도를 제거하면 코드를 새로운 관점에서 바라볼 수 있다.

* 유연성
> 유연성은 비효율적인 코딩이나 설계를 정당화해주는 가치이다.

> 유연성이 있으면서도 당장 이득을 얻을 수 있는 패턴을 사용하라. 당장 비용이 들어가지만, 앞으로 이득을 얻을 수 있을지 불확실한 패턴의 경우에는 일단 사용을 자제하는 편이 좋다. 이러한 패턴은 일단 사용을 보류했다가, 정말 필요한 때가 오면 그때 적용하라.

### 원칙
* 지역적 변화
> 코드를 수정할 때 함께 바꿔야 하는 부분을 최소화하라. 프로그램의 어떤 부분을 수정한 것이 다른 부분에서 문제를 일으킨다면, 프로그램 수정에 대한 비용이 커진다. 지역적 변화만을 일으키는 코드는 커뮤니케이션이 쉽다. 프로그램 전체를 알 필요 없이 그 부분만 보고 이해가 가능하기 때문이다.

> 구현 패턴을 사용하는 중요한 이유는 프로그램 수정 비용을 낮추기 위함이므로, 지역적 변화(Local Consequences)의 원칙은 여러 패턴의 근간이 된다.

* 최소 중복
> 지역적 변화를 돕는 다른 원칙은 최소 중복(Minimize Repetition)의 원칙이다. 같은 코드가 여러 곳에서 반복된다면, 그 중 하나를 바꿀 때 다른 중복된 코드들도 모두 바꿔야 할지 여부를 결정해야 한다. 중복된 코드가 많으면 많을수록 코드 수정은 어려워진다.

> 병렬 클래스 계층(parallel class hierarchy)도 중복의 일종이다. 프로그램상의 어떤 개념을 수정했을 때 2개 이상의 클래스 계층을 수정해야 한다면, 이러한 수정은 지역적 변화의 원칙을 위배하는 것이다. 이런 경우 변화가 지역적으로 제한되도록 코드를 재구성해서 코드 품질을 향상시킬 수 있다.

> 중복은 실제 코드에 나타나기 전까지는 예측하기 어렵고, 발생 후에도 그 존재가 분명치 않다. 어떤 경우에는 중복을 제거하기 어려울 수도 있다. 따라서 중복을 절대로 피해야 할 요소로 보기보다는 코드 수정 비용을 높이는 위험 요소로 보는 것이 좋다.

> 중복을 없애는 한 가지 방법은 프로그램을 여러 작은 부분-짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지-으로 나누는 것이다.

* 로직과 데이터의 결합
> 지역적 변화의 원칙에 근거한 다른 원칙은 로직과 데이터를 함께 유지하는 것이다.데이터와 그 데이터를 처리하는 로직을 밀접하게-가급적 같은 메소드 혹은 같은 객체 내에, 최소한 같은 패키지 내부에-배치하라. 프로그램을 수정하는 경우, 로직과 데이터를 모두 고쳐야 할 경우가 많다. 따라서 로직과 데이터가 함께 있다면 프로그램을 수정하더라도 그 영향이 일정 영역에 머물게 된다.

* 대칭성
> 내가 항상 사용하는 또 다른 원칙으로는 대칭성(Symmetry)이 있다. 프로그램에서 대칭성은 여러 곳에 존재한다. add() 메소드가 있는 곳에는 remove() 메소드가 있다. 같은 파리미터를 사용하는 여러 개의 메소드가 있는 경우도 많다. 같은 객체 안에 있는 모든 필드는 함께 생성되어 함께 소멸된다. 프로그램에서 대칭성을 찾아내서 명확히 표현해주면, 코드를 읽기가 수월해진다. 프로그램의 절반만 이해하면 나머지 절반은 자연스럽게 이해되기 때문이다.

> 다음은 대칭성이 결여된 코드다.
```java
void process() {
    input();
    count++;
    ouput();
}
```

대칭성에 맞게 코드를 변경하면 다음과 같다.
```java
void process() {
    input();
    tally();
    output();
}
```

* 선언적 표현
...

* 변화율
> 마지막 원칙은 함께 변하는 로직과 데이터를 함께 관리하고, 변화율이 다른 로직과 데이터는 분리하는 것이다.

> 변화율은 데이터에도 적용된다. 하나의 객체에 있는 모든 필드는 가급적 함께 변해야 한다. 예를 들어 특정 메소드가 수행될 때만 사용되는 필드는 그 메소드의 지역 변수로 선언되어야 한다. 어떤 객체에 다른 필드와는 독립적이지만 서로 의존적인 2개의 필드가 있다면, 그 두 개의 필드는 별도의 도우미 객체에 넣는 편이 낫다.

> 예를 들어 금융 상품을 표현하는 어떤 객체에 함께 변화하는 2개의 필드인 value와 currency가 있다면 다음과 같이 Money 도우미 객체를 사용하는 편이 낫다.
```java
setAmount(int value, String currency) {
    this.value = value;
    this.currency = currency;
}
```

이 코드는 다음과 같이 바꿀 수 있다.

```java
setAmount(int value, String currency) {
    this.value = new Money(value, currency);
}
```

더 개선하면 다음과 같다.

```java
setAmount(Money value) {
    this.value = value;
}
```

> 변화율은 대칭성의 일종으로 시간적 대칭이다. value 필드와 currency 필드는 대칭적으로 함께 변화하지만, 객체 내의 다른 필드와는 대칭적이지 않을 수도 있다. 대칭적인 필드를 별도의 객체에 묶어서 대칭성을 표현하면, 코드를 읽는 다름 사람에게 프로그래머의 의도를 잘 전달할 수 있고 중복을 줄일 수 있으며 코드 수정에 대한 영향을 제어하기 쉬워진다.

## 04. 동기유발
> 소프트웨어 설계의 원동력은 경제성이다. 소프트웨어는 전체 비용을 줄이는 방향으로 설계되어야 한다. 소프트웨어 비용은 최초 개발 비용과 유지 비용으로 구분할 수 있다.

> 전체 비용 = 개발 비용 + 유지 비용

> 소프트웨어 개발보다 유지 보수에 비용이 더 들어 간다. 유지보수가 비싼 이유는 기존에 있는 코드를 이해하는 작업이 시간이 많이 걸리는 어려운 일이기 때문이다. 코드의 어떤 부분을 수정해야 할지 알고 있다면, 소프트웨어 수정은 그다지 어렵지 않다. 문제는 기존 코드를 이해하는 것이다. 코드를 수정한 후에는, 테스트를 한 후 현장에 설치(deploy)하게 된다. 따라서 유지 비용은 다음과 같다.

> 유지 비용 = 이해 비용 + 수정 비용 + 테스트 비용 + 설치 비용

> 전체 비용을 줄이는 한 가지 전략은 유지 비용을 줄일 수 있을 거라 기대하고 초기 개발 비용에 좀더 많은 투자를 하는 것이다. 하지만 이러한 보통 전체 비용을 절감하지 못한다. 미래에 코드를 어떻게 수정해야 할지 알수 없기 때문에, 아무리 고민을 많이 하더라도 나중에 수정할 사항가지 대비해 완벽한 코드를 짜는 것은 불가능하다. 오히려 예기치 못한 수정이 필요할때, 기존에 섣부르게 일반화시킨 부분이 방해가 되기도 한다.

> 초기 코드 개발에 대한 투자를 크게 확대하는 것은 두 가지 중요한 경제적 측면-시간에 따른 화폐 가치 변화와 미래에 대한 불확실성-에 부합하지 않는다. 소프트웨어를 구현할 때는 비용 발생 시점을 뒤로 미루는 것이 좋다. 또한 불확실성 측면에서 볼 때, 이후에 이득을 가져올지도 모르는 구현과 당장 이득을 얻을 수 있는 구현이 있다면 당장 이득을 얻을 수 있는 쪽을 선택하는 편이 낫다. 그렇다고 미래에 대비하지 않고 엉망으로 코드를 짜도 된다는 이야기는 아니다. 구현 패턴은 미래 코드 확장이나 수정이 쉬운 깔끔한 코드를 추구하면서도, 당장 얻을 수 있는 이득에도 초점을 맞춘다.

> 내가 사용하는 비용 절감 전략은 모든 프로그래머가 커뮤니케이션하기 쉬운 코드를 짬으로써, 유지 비용을 줄이는 것이다. 이 경우 깔끔한 코드를 통해 코드의 결함이 줄어들고 코드 공유가 쉬워져서 좀더 원활한 개발이 가능하다.

## 05. 클래스
> 이 데이터들은 함께 사용되는데, 그에 관련된 로직이 이것이다. 라는 이야기를 하고 싶을 때 클래스를 사용한다.

> 클래스를 사용하는 기본 이유는 데이터가 로직에 비해 빈번하게 변화하기 때문이다. 각 클래스 선언은 '클래스의 로직과 데이터는 함께 사용되며, 로직은 데이터에 비해 변화율이 낮다. 클래스 내부의 데이터는 관련 로직에 의해 변화하며, 클래스 내부에서 사용하는 데이터의 변화율은 비슷하다.' 는 내용을 전달한다.

> 클래스 계층을 구성하는 것은 일종의 압축 기법을 사용하는 것이다. 클래스 계층의 사용은 상위클래스의 코드를 모두 하위클래스에 붙여 넣는 것과 같은 효과를 가져온다. 다른 압축기법과 마찬가지로, 클래스 계층을 사용하면 코드를 읽기 어려워진다. 하위클래스를 이해하기 위해서는 상위클래스도 이해해야 하기 때문이다.

> 효과적인 객체 지향 프로그래밍을 하기 위한 다른 요건은 선별적으로 상속을 사용하는 것이다. 하위클래스를 생성하는 것은, '이 클래스는 상위클래스와 비슷하지만, 약간 다르다.'라고 이야기하는 것이다.

* 단순한 상위클래스 이름
> 이름 중에서도 가장 중요한 것이 클래스 이름이다 클래스는 프로그램 설계의 핵심이기 때문이다. 클래스 이름이 너무 이상해서 수정해야 하는 경우를 제외하면 클래스 이름을 먼저 지은 후, 각 메소드에 이름 붙이는 것이 보통이다.

* 한정적 하위클래스 이름
> 하위클래스 이름은 상위클래스와의 유사점과 차지머을 나타내야 한다. 이 경우에도 결국 간결성과 풍부한 표현성 사이의 고민이다. ... 보통은 상위클래스 이름에 한 두 개의 수식어를 붙여서 하위클래스 이름을 정하는 경우가 많다.

> 하지만 하위 클래스가 상위클래스의 메커니즘을 빌려서 사용할 뿐, 그 자체로 프로그램의 중요한 개념을 의미하는 경우라면 ... 하위클래스에도 단순한 이름을 사용해야 한다.

* 추상 인터페이스
> 소프트웨어 개발에 관한 오랜 격언 중 하나로, 구현이 아니라 인터페이스에 맞춰 코딩하라는 말이 있다. 이는 설계상의 결정을 필요 이상으로 노출하지 말라는 뜻이다. 예들 들어 대부분의 코드가 컬렉션 인터페이스를 사용한다면, 구상 클래스(concrete class)를 나중에 얼마든지 바꿀 수 있다. 구상 클래스는 컴퓨터가 실제 연산을 하기 전에만 결정되면 된다.

> 여기서 인터페이스란 구현이 빠진 여러 연산의 집합을 의미한다. 자바에서는 자바 인터페이스나 상위클래스를 사용해서 이러한 목적을 달성할 수 있다.

> 인터페이스 추가에는 비용이 발생한다. 인터페이스를 사용하게 되면 우리는 인터페이스를 배우고 이해하며 문서화하고 디버깅하고 정리하고 조회해서 적당한 이름을 지어야 한다. 인터페이스 수를 최대한 늘린다고 해서 소프트웨어 비용이 최소화되는 것은 아니다. 따라서 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야 한다. 때로는 인터페이스가 제공하는 유연성이 필요한지 여부를 판단하기 어려우므로, 비용 최소화를 위해 어던 부분에서 유연성이 필요할지 예측해서 인터페이스를 사용해야 한다.

> 인터페이스를 사용하게 된 경제적 이유로는 소프트웨어는 예측하기 어렵다는 점을 들 수 있다. 컴퓨터 업계에서는 소프트웨어를 제대로 설계하면 이후에 시스템을 바꿀 필요가 없을 것이라고 믿는 사람들이 많다.

* 인터페이스
> 자바 인터페이스를 사용하는 것은 '여기깢가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다.'라고 이야기하는 것과 같다.

> 인터페이스는 다중 상속의 유연성을 제공하면서도 복잡성과 모호성을 갖고 있지 않은 적절하게 균형이 잡힌 메커니즘이다. 하나의 클래스는 여러 인터페이스를 구현한다고 선언할 수 있다. 인터페이스는 필드를 배제하고 연산만을 나타내므로 사용자는 구현이 변경되더라도 신경 쓸 필요가 없다.

> 인터페이스를 사용하면 구현을 바꾸는 것은 쉽지만, 인터페이스 자체를 바꾸기는 쉽지 않다. 인터페이스를 조금이라도 바꾸거나 추가하면, 그 인터페이스를 구현하는 모든 클래스를 수정해야 하기 때문이다.

