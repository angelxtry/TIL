# react-nodebird 6

제로초님의 인프런 강의를 보고 따라한 것임을 미리 밝힌다.

## 해시태그 링크 만들기

프론트에서 해시태그를 링크로 변환하여 클릭할 수 있게 만들자.

`components/PostCard.js`

```js
import React, { useState, useCallback } from 'react';
import { Card, Icon, Button, Avatar } from 'antd';

import PostCardContent from './PostCardContent';
import CommentForm from './CommentForm';
import CommentList from './CommentList';

const PostCard = ({ post }) => {
  const [commentFormOpened, setCommentFormOpened] = useState(false);
  const onToggleComment = useCallback(() => {
    setCommentFormOpened((prev) => !prev);
  }, []);

  return (
    <div>
      <Card
        corver={post.img && <img alt="example" src={post.img} />}
        actions={[
          <Icon type="retweet" key="retweet" />,
          <Icon type="heart" key="heart" />,
          <Icon type="message" key="message" onClick={onToggleComment} />,
          <Icon type="ellipsis" key="ellipsis" />
        ]}
        extra={<Button>팔로우</Button>}
      >
        <Card.Meta
          avatar={<Avatar>{post.User.nickname[0]}</Avatar>}
          title={post.User.nickname}
          description={<PostCardContent postContent={post.content} />}
        />
      </Card>
      {commentFormOpened && (
        <>
          <CommentForm post={post} />
          <CommentList post={post} />
        </>
      )}
    </div>
  );
};

export default PostCard;

```

`components/PostCardContent.js`

```js
import React from 'react';
import Link from 'next/link';

const PostCardContent = ({ postContent }) => {
  return (
    <div>
      {postContent.split(/(#[^\s]+)/g).map((v) => {
        if (v.match(/#[^\s]+/)) {
          return (
            <Link
              href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }}
              as={`/hashtag/${v.slice(1)}`}
              key={v}
            >
              <a>{v}</a>
            </Link>
          );
        }
        return v;
      })}
    </div>
  );
};

export default PostCardContent;

```

코드가 너무 길어 분리했다.

`PostCardContent`를 보면 데이터를 정규표현식과 split을 이용하여 분리하여 배열로 만든다.

배열을 map으로 순회하면서 해시태그이면 링크로 만들고, 아니면 그대로 출력한다.

링크는 동적으로 path가 변경될 수 있도록 href를 작성했다.

`as`는 실제로 브라우저의 주소창에 표시되는 url을 변경한다.

`as`가 없다면 url은 `http://localhost:3000/hashtag?tag=해시태그` 이렇게 표시될 것이다.

`as`에 의해 url은 `http://localhost:3000/hashtag/해시태그`로 변경된다.

## next에 express 연동

프론트에 다음의 package를 설치한다.

```js
> npm i express morgan cookie-parser express-session dotenv

> npm i -D nodemon
```

root 경로에 `server.js` 파일을 생성한다.

```js
const express = require('express');
const next = require('next');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const expressSession = require('express-session');
const dotenv = require('dotenv');

const dev = process.env.NODE_ENV !== 'production';
const prod = process.env.NODE_ENV === 'production';

const app = next({ dev });
const handle = app.getRequestHandler();
dotenv.config();

app.prepare().then(() => {
  const server = express();

  server.use(morgan('dev'));
  server.use(express.json());
  server.use(express.urlencoded({ extended: true }));
  server.use(cookieParser(process.env.COOKIE_SECRET));
  server.use(
    expressSession({
      resave: false,
      saveUninitialized: false,
      secret: process.env.COOKIE_SECRET,
      cookie: {
        httpOnly: true,
        secure: false
      }
    })
  );

  server.get('*', (req, res) => {
    return handle(req, res);
  });

  server.listen(9090, () => {
    console.log(`http://localhost:9090`);
  });
});

```

일단 여기까지 작성하면 next와 express가 연동될 준비가 되었다.

`COOKIE_SECRET`은 서버와 동일하게 사용한다.

`package.json`에서 `scrpit`를 변경하여 `next`가 아닌 `nodemon`이 프론트를 실행하도록 변경하자.

```json
"scripts": {
  "dev": "nodemon"
},
```

`nodemon.json` 파일도 생성한다.

```json
{
  "watch": [
    "server.js",
    "nodemon.json"
  ],
  "exec": "node server.js",
  "ext": "js json jsx"
}

```

`npm run dev`로 실행해보면 next가 실행되는 것을 확인할 수 있다.

## hashtag 동적 라우팅

`server.js`에 라우팅 관련 코드를 추가한다.

```js
const express = require('express');
const next = require('next');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const expressSession = require('express-session');
const dotenv = require('dotenv');

const dev = process.env.NODE_ENV !== 'production';
const prod = process.env.NODE_ENV === 'production';

const app = next({ dev });
const handle = app.getRequestHandler();
dotenv.config();

app.prepare().then(() => {
  const server = express();

  server.use(morgan('dev'));
  server.use(express.json());
  server.use(express.urlencoded({ extended: true }));
  server.use(cookieParser(process.env.COOKIE_SECRET));
  server.use(
    expressSession({
      resave: false,
      saveUninitialized: false,
      secret: process.env.COOKIE_SECRET,
      cookie: {
        httpOnly: true,
        secure: false
      }
    })
  );

  server.get('/hashtag/:tag', (req, res) => {
    return app.render(req, res, '/hashtag', { tag: req.params.tag });
  });

  server.get('*', (req, res) => {
    return handle(req, res);
  });

  server.listen(9090, () => {
    console.log(`http://localhost:9090`);
  });
});

```

express와 다른 점은 `res.json` 같은 함수를 사용한 것이 아니라 `app.render`를 사용한다는 것이다.

이렇게 라우팅을 설정하면 `hashtag` 페이지에 tag를 동적으로 전달할 수 있다.

`pages/hashtag.js` 파일을 생성한다.

```js
import React from 'react';

const hashtag = () => {
  return <div>hashtag</div>;
};

hashtag.getInitialProps = async (context) => {
  console.log('hashtag getInitialProsp: ', context.query.tag);
};

export default hashtag;

```

여기서 집중해야 할 것인 `getInitialProps`이다.

`getInitialProps`는 비동기로 동작하고 context라는 인자를 받는다.

이 context에 라우팅 처리 때 전달한 `{ tag: req.params.tag }`가 들어있다.

context를 `getInitialProps`에 넣고 `getInitialProps`를 호출하기 위해 `pages/_app.js`파일의 코드를 수정한다.

```js
import React from 'react';
import Head from 'next/head';
import PropTypes from 'prop-types';
import { applyMiddleware, compose, createStore } from 'redux';
import { Provider } from 'react-redux';
import withRedux from 'next-redux-wrapper';
import createSagaMiddleware from 'redux-saga';

import Layout from '../components/Layout';
import rootReducer from '../reducers';
import rootSaga from '../sagas';

const CandC = ({ Component, store, pageProps }) => {
  return (
    <Provider store={store}>
      <Head>
        <title>C And C</title>
        <link
          rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/antd/3.23.6/antd.min.css"
        />
      </Head>
      <Layout>
        <Component {...pageProps} />
      </Layout>
    </Provider>
  );
};

CandC.propTypes = {
  Component: PropTypes.elementType
};

CandC.getInitialProps = async (context) => {
  // console.log(context);
  const { ctx, Component } = context;
  let pageProps = {};
  if (Component.getInitialProps) {
    pageProps = await Component.getInitialProps(ctx);
  }
  return { pageProps };
};

const configureStore = (initialState, options) => {
  const sagaMiddleware = createSagaMiddleware();
  const middlewares = [sagaMiddleware];
  const enhancer =
    process.env.NODE_ENV === 'production'
      ? compose(applyMiddleware(...middlewares))
      : compose(
          applyMiddleware(...middlewares),
          !options.isServer &&
            typeof window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined'
            ? window.__REDUX_DEVTOOLS_EXTENSION__()
            : (f) => f
        );
  const store = createStore(rootReducer, initialState, enhancer);
  sagaMiddleware.run(rootSaga);
  return store;
};

export default withRedux(configureStore)(CandC);

```

부분만 잘라서 확인하자.

```js
CandC.getInitialProps = async (context) => {
  // console.log(context);
  const { ctx, Component } = context;
  let pageProps = {};
  if (Component.getInitialProps) {
    pageProps = await Component.getInitialProps(ctx);
  }
  return { pageProps };
};

```

context는 next에서 전달한 인자다.

여기서 Component는 `pages` 폴더 하위의 페이지들이다.

여기서 각 페이지의 `getInitialProps` 함수를 실행한다.

`getInitialProps`는 일종의 life cycle이라고 간주할 수 있다.

이 함수는 가장 먼저 실행된다.

이 함수는 프론트에서도 실행되고, 서버에서도 실행된다.

next의 특징인 ssr을 할 때도 이 함수를 사용한다.

각 컴포넌트의 `getInitialProps`에서 return 한 값은 `_app.js`의 `pageProps`로 전달되고, `CandC`에서 해당 인자를 받는다.

그리고 그 인자는 다시 `Component`로 전달되어 해당 컴포넌트에서 사용할 수 있게 된다.

## 해시태그 클릭 시 검색 처리

이번엔 `reducers/post.js` 부터 시작하자.

```js
case LOAD_MAIN_POSTS_REQUEST:
case LOAD_HASHTAG_POSTS_REQUEST: {
  return {
    ...state,
    mainPosts: [],
    loadMainPostsError: ''
  };
}
case LOAD_MAIN_POSTS_SUCCESS:
case LOAD_HASHTAG_POSTS_SUCCESS: {
  return {
    ...state,
    mainPosts: action.payload.data
  };
}
case LOAD_MAIN_POSTS_FAILURE:
case LOAD_HASHTAG_POSTS_FAILURE: {
  return {
    ...state,
    loadMainPostsError: action.error
  };
}

```

기존과 동일한 행동을 한다.

`sagas/post.js`

```js
function loadHashtagPostsAPI({ tag }) {
  return axios.get(`/hashtag/${tag}`);
}

function* loadHashtagPosts(action) {
  try {
    const result = yield call(loadHashtagPostsAPI, action.payload);
    yield put({
      type: LOAD_HASHTAG_POSTS_SUCCESS,
      payload: result.data
    });
  } catch (error) {
    console.error(error);
    yield put({ type: LOAD_HASHTAG_POSTS_FAILURE, error });
  }
}

function* watchLoadHashtagPosts() {
  yield takeLatest(LOAD_HASHTAG_POSTS_REQUEST, loadHashtagPosts);
}

```

axios에 전달할 때 url로 tag를 전달한다.

`routes/hashtag.js`

```js
const express = require('express');
const { User, Post, Hashtag } = require('../models');

const router = express.Router();

router.get('/:tag', async (req, res, next) => {
  try {
    const posts = await Post.findAll({
      include: [
        {
          model: Hashtag,
          where: { name: decodeURIComponent(req.params.tag) }
        },
        { model: User, attributes: ['id', 'nickname'] }
      ]
    });
    res
      .status(200)
      .json({ code: 200, message: 'Hashtage search success.', data: posts });
  } catch (error) {
    console.error(error);
    next(error);
  }
});

module.exports = router;

```

마지막으로 프론트를 보자.

`pages/hashtag.js`

```js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';

import PostCard from '../components/PostCard';
import { LOAD_HASHTAG_POSTS_REQUEST } from '../reducers/post';

const hashtag = ({ tag }) => {
  const { mainPosts } = useSelector((state) => state.post);
  const dispatch = useDispatch();
  useEffect(() => {
    dispatch({
      type: LOAD_HASHTAG_POSTS_REQUEST,
      payload: { tag }
    });
  }, [tag]);
  return (
    <div>
      {mainPosts.map((c, i) => (
        <PostCard key={i} post={c} />
      ))}
    </div>
  );
};

hashtag.getInitialProps = async (context) => {
  return { tag: context.query.tag };
};

export default hashtag;

```
