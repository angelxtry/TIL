# 02. Design pattern

* Design Pattern Category
* 디자인 패턴을 깨달았을 때 사용하다가 잊어먹다가...
* 원리를 이해해야 계속 사용할 수 있다.
* 디자인 패턴을 다 이해하면 패턴의 입구다.

* GOF의 디자인패턴 분류
  * 생성패턴 - 객체를 만들때 이런 식으로 만들면 좋아
  * 구조패턴 - 관계를 이런 식으로
  * 행동패턴 - 알고리즘을 객체의 행동망으로

* 디자인패턴은 역할모델과 객체지향을 이해해야한다. 이게 선수과제다.

* 객체지향설계를 학습할 수 있는 분류
  * 캡슐화
  * 다형성
  * 변화율
  * 객체관계
  * 역할모델 - 이걸 중심으로

* 알고리즘이 변화하는 이유
  * 비지니스 변화
  * 연관 라이브러리 변화
  * 호스트측 변화
* 대부분 통제불가요소
* 이 변화는 PM이 막아줘야 하는데 -> 막을 수 없다.

* math.sin 이런 것은 확정이다.

* 기존 제어문 기반으로 프로그램을 짜면 수정하면 전체가 컴파일 된다.
* 변화에 대응하는 프로그램 - 적응형, 반응형 프로그램
* 알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다.
* 최대한 개별 알고리즘을 함수로 분리한다.

```js
if (case == 1){
  ...
} else if (case == 2) {
  ...
} else if (case == 3) {
  ...
}
```

```js
if (case == 1){
  case1();
} else if (case == 2) {
  case2();
} else if (case == 3) {
  case3();
}
```

* case2()만 수정하면 된다.

* 문제1. 경우의 수가 늘어난다.

```js
if (case == 1){
  case1();
} else if (case == 2) {
  case2();
} else if (case == 3) {
  case3();
} else if (case == 4) {
  case4();
}
```

* 이러면 전체 다시 컴파일

* 문제2. 함수간의 공통 부분. 이런 공통부분의 변화.

```js
if (case == 1){
  common();
  case1();
} else if (case == 2) {
  common();
  case2();
} else if (case == 3) {
  case3();
}
```

* 이렇게 되도 전체 다시 컴파일
* 그래서 최대한 개별 알고리즘을 함수로 분리해야 한다.

* 알고리즘 분화 시 객체지향에서 선택할 수 있는 두 가지 방법
* 예를 들어 if, case
* 상속위임으로 해결한다.
  * 내부 계약 관계로 추상층에서 공통 요소를 해결하고 상태를 공유한다.
  * 즉, 경우의 수만큼 자식 클래스를 만든다.
  * 지난 번 수업의 Data와 Data의 자식 클래스, Renderer와 자식 클래스
* 소유위임
  * 외부계약관계롤 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결한다.
  * 즉, 경우의 수에 맞는 수 만큼 소유한다.

* GOF DP는 주로 소유 위임이 많다.
  * 부가적인 형이 많이 생긴다.
  * 간단한 문제는 그냥 만들자.
  * 얼마나 역할을 나눌지는 도메인에 익숙한 사람, 짬밥에 따라 이 감각을 익힐 수 있다.

* 상속위임
* github은 rest api는 크로스 도메인 문제가 있어서 jsonp도 지원한다.
* load의 부분은 공통부분
* 호출하는 함수는 자식 클래스에 위임
* 이것을 템플릿 메서드 패턴이다.
* 자식 클래스에서는 hook만 구현하면 된다.
* 구현, 구상 => concrete

## 정의시점과 실행시점

* 정의시점과 실행시점을 나누었다.
* if 분기는 정의시점이 아니라 실행시점에만 생긴다.
* if 분기가 변화해도 실행시점의 코드만 변경하면 된다.

## 소유위임

* Github 클래스에 set_parse라는 함수를 갖는다.
* 이 값이 설정되지 않으면 load 함수는 실행조차 되지 않는다.
* 이런 구조는 전략 패턴이라고 한다.
* 템플릿 메서드 패턴에서는 이 부분을 hook이라고 불렀다.
* 전략 패턴에서는 이 부분을 starategy object라고 부른다.
* 객체 또는 함수가 와도 된다.

## 장단점

* 전략 패턴은 템플릿 메소드 패턴보다 간단하게 구현할 수 있다.
* 함수를 만들어 전달하는 것은 클래스를 상속받는 것 보다 간단할 수 있다.
* 하지만 함수의 구현과 성능을 보장해야만 한다.
* 그리고 함수가 전달되기 때문에 타입을 판별할 수가 없다.
* 위임하는 일의 중요도에 따라 함수를 쓸지 타입을 쓸지 판단해야 한다.
* 매우 중요도가 높은 일이라면 템플릿 메소드 패턴을 이용해 강타입을 쓰는 것이 좋다.
* 전략 패턴은 호스트를 하나 만들고 SO만 변경하면 되기 때문에 전략을 위한 클래스를 미리 만들어두지 않아도 된다.
* 예를 들어 RPG에서 무기 스왑을 한다고 했을 때 전략 패턴이 유용하다.

* 템플릿 메소드 패턴이나 전략패턴 모두 Github은 세부 표현에 대한 코드가 없다.
* 세부 구현은 모두 위임했다.
* 그래서 img spec변경이나 md 버전 변경 같은 이유로 Github 코드가 변경될 이유가 없다.

* 자유변수를 이용해서 함수에 상태를 저장할 수 있다.
* 함수에 상태를 저장하면 굳이 클래스를 사용하지 않아도 된다.

## 실행시점 선택 위임

* 케이스 별로 완전히 독립된 코드를 작성했으나 그 케이스 자체를 분기하는 법은 아직.
* 이럴 때 라우터를 이용한다.
* 라우터는 거대한 케이스 처리기.
* if는 제거될 수 없다.
* 그러므로 if를 제거하려고 노력하는 것이 아니라 if를 값으로 바꾼다.
* 라우팅 테이블이 있으면 if를 사용하지 않고 자동으로 분기할 수 있다.
* 발생 가능한 경우의 수를 값으로 처리할 수 있다.

* 상태에 대한 분기는 사라지지않는다.
* 그 분기는 필요해서 생겼기 때문에.
* 단지 정의 시점에 if를 제거하고 싶다.
* 분기 수 만큼 객체를 만들고 실행시점에 경우의 수를 공급한다.

## 실생시점으로 분기를 옮길 때의 장단점

* 장점
  * 정의 시점에 모든 경우를 몰라도 된다.
  * 정의 시점에 그 경우를 처리하는 방법을 몰라도 된다.
  * 일정한 통제 범위 내에서 확장 가능한 알로기즘 설계 가능
  * 실제로 유명한 상용 프로그램들은 부분 패치가 가능하다.

* 단점
  * 실행 시점에 모든 경우를 반드시 기술해야 한다.
  * 실행 시점마다 알고리즘의 안정성을 담보해야 한다.
  * 그래서 단위 테스트 양이 늘어난다.
  * 미숙한 개발자가 업무를 처리해야 한다면 실행시점에 책임이 부과되는 것이 부담스러울 수 있다.
  * 매 호스트 코드마다 안정성을 따로 담보해야 한다.

* 실행 시점으로 분기를 옮긴 패턴
  * factory 패턴
  * builder 패턴

* 라우팅 테이블을 2단 이상으로 확장할 수도, N단으로 확장할 수도 있다.
