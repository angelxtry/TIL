# Functional Thinking

* 어렵다. 한글을 읽고 있는데 이해가 안된다.

* 수학책 보는 것 느낌.

* 재밌다.

* 얉게 읽었다. 통독하는 느낌으로.

* 소개되는 여러 언어들을 몰라도 된다고 했지만... 모르니 잘 이해 안되더라.

* 함수형 프로그램의 전반적인 개론같으면서도 각 언어의 세부사항이 등장하여 어렵게 느껴진다.

* 스칼라, 클로저, 하스켈 모두 배워보고 싶은 언어.

## 요약

### chapter1. 왜
* chapter1의 소제목들이 '왜'의 좋은 설명이 될 듯하다.
    * 1.1 패러다임 전환
    * 1.2 언어 트렌드에 발맞추기
    * 1.3 언어/런타임에 제어를 양도하기
    * 1.4 간결함

> 잠시 당신이 나무꾼이라고 가정해보자. 당신은 숲에서 가장 좋은 도끼를 가지고 있고, 그래서 가장 일 잘하는 나무꾼이다. 그런데 어느 날 누가 나타나서 나무를 자르는 새로운 패러다임인 전기톱을 알리고 다닌다. 이 사람이 무척 설득력이 있어서 당신은 사용하는 방법도 모르면서 전기톱을 사게 된다. 당신은 여태껏 했던 방식대로 시동을 걸지도 않고 전기톱으로 나무를 마구 두들겨댄다. 곧 당신은 이 새로운 전기톱은 일시적인 유행일 뿐이라고 단정하고 다시 도끼를 쓰기 시작한다. 그때, 누군가 나타나서 전기톱의 시동 거는 법을 가르쳐준다.

> 전혀 새로운 프로그래밍 패러다임의 문제점은 새로운 언어를 배우는 것이 아니다. 어려운 점은 바로 다른 방식으로 사고하는 법을 배우는 것이다.

> 컴플렉트(complect). 이 단어는 서로 꼬아서 연결하다, 또는 섞어 짜다 정도의 의미이다. 명령형 프로그래밍을 하다 보면 효율을 높이기 위해 여러 작업을 한 루프에 넣음으로써, 작업들을 복잡하게 하는 경우가 종종 있다. 함수형 프로그래밍에서는 map()이나 filter() 같은  고계함수를 통해 추상화의 단계를 높여서 문제를 더욱 명료하게 볼 수 있다.

공감된다. 이런 경우 정말 많았는데... 루프를 한번만 돌리고 그 안에서 최대한 여러가지 연산을 처리하는 것이 루프를 반복해서 돌리는 것보다 효율적이라고 생각했다.

> 마침내 자바8에 람다 블록이 도입되었듯, 자바조차도 함수형 기능이 추가되기 시작했다. 그리고 가장 보편화된 언어라고 할 수 있는 자바스크립트에는 이미 많은 함수형 기능이 들어 있다. 오래된 언어인 C++조차도 2011년 표준에서 람다 블록을 더했고, Boost.Phoenix 같은 흥미로운 라이브러리를 추가하면서 함수형 프로그램밍에 관심을 보이고 있다.

람다. 한 줄짜리 함수. 아직 람다의 장점이나 효율을 설명하라고 하면 막연하다. 내가 충분히 이해하지 못했다는 증거다. 람다를 어떻게 잘 설명할 수 있을까?

> 시간이 갈수록 개발자는 지루한 일들을 언어나 런타임에 점점 더 맡기게 된다. 애플리케이션을 만들면서 직접 메모리를 제어하지 않는다는 것을 조금도 후회하지 않는다. 그런 일에 무관심해졌기 때문에 좀 더 중요한 문제들에 집중할 수 있다. 자바가 메모리 관리 작업을 쉽게 해줬다면, 함수형 프로그래밍 언어는 다른 빌딩블록들을 고수준 추상적 개념으로 대체해준다.

한 때 가비지 컬렉션이 없는 언어에서 메모리를 직접 관리한다는 것이 자부심이었던 때도 있었는데... 참 많이 변했다.

> 객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다. - 마이클 페더스(레거시 코드 활용 전략의 저자)

> 객체지향 프로그래밍(OOP) 구조에 대해 생각해보라. 캡슐화, 스코핑, 가시성 등의 메커니즘은 상태(state) 변화를 누가 볼 수 있는지에 대한 세밀한 제어를 위해 존재한다. ... 함수형 언어는 이런 가변(mutable) 상태를 제어하는 메커니즘을 구축하기보다, 그런 움직이는 부분을 아예 제거하는 데 주력한다.

> 객체지향 명령형 프로그래밍 언어에서, 재사용의 단위는 클래스와 그 클래스들이 주고받는 통신 메시지이고, 이는 클래스 다이어그램으로 포착할 수 있다. ... OOP의 세계에섯는 고유한 자료구조를 작성하는 것을 권장한다. 그 자료구조에 특정 동작을 메서드의 형태로 부착해서 말이다. 함수형 프로그래밍 언어는 같은 방식으로 재사용을 달성하려 하지 않고, 최적화된 동작으로 몇몇 자료구조(list, set, map)를 이용하는 방식의 재사용을 선호한다.

## chapter2. 전환
> 주어진 조건에 맞는 컬렉션의 부분집합을 구하려면 filter를 사용하라.

> 컬렉션을 그 자리에서 변형하려면 map 함수를 사용하라.

> 컬렉션의 요소를 하나씩 다른 함수로 처리할 때는 reduce나 fold를 사용하라.

## chapter3. 양도하라
> 가비지 컬렉션 같은 저수준 세부사항의 조작을 런타임에 양도함으로써 찾아야 할 수많은 오류를 방지해주는 능력이야말로 함수형 사고의 가치라고 하겠다. 대다수의 개발자들은 메모리와 같은 기본 추상적 개념을 문제없이 무시하는 데 익숙하겠지만, 더 높은 단계에서 나타나는 추상화는 낯설어한다. 하지만 이런 고수준 추상 개념들도 기계장치의 지루한 일들을 처리해줌으로써 개발자가 자신의 문제에 고유한 측면을 연구할 시간을 제공한다는 측면에서 똑같은 역할을 수행한다.

> 함수형 언어를 사용하는 개발자가 언어나 런타임에 제어를 양도하는 다섯 가지 방식
1. 반복 처리에서 고계함수로
2. 클로저(closure)
3. 커링과 부분 적용
4. 재귀
5. 스트림과 작업 재정렬

1. 반복 처리에서 고계함수로
> 반복처리 대신에 map과 같은 함수를 사용하여 제어를 포기할 수 있다. ... 고계함수 내에서 어떤 연산을 할 것인지를 표현하기만 하면, 언어가 그것을 능률적으로 처리할 것이다. 게다가 modifier를 덧붙이기만 하면 분산처리까지 해준다.

> 개발자가 저수준 추상 단계에서 코드가 어떻게 동작하는지 이해하는 것까지 전부 떠넘겨도 된다는 것은 아니다. 많은 경우에 개발자는 Stream 같은 추상 개념을 사용할 때 거기에 함축된 의미를 반드시 알아야 한다. 일례로 많은 개발자들은 자바 8의 Stream API를 사용할 때조차. 그 안에서 작동하는 포크/조인 라이브러리의 세부사항을 이해해야 좋은 성능을 낼 수 있다. 하지만 일단 이해만 하면 간단하게 사용할 수 있다.

내가 아는 언어의 간단한 분산처리 라이브러리는 python의 multiprocessing인데 이것 또한 그 의미를 이해하지 못한 채 사용하고 있다. 좀 더 공부해보자.

2. 클로저
> 모든 함수형 언어는 클로저를 포함한다. ... 클로저(closure)란 그 내부에서 참조되는 모든 인수에 대한 묵시적 바인딩을 지닌 함수를 칭한다. 다시 말하면 이 함수(또는 메서드)는 자신이 참조하는 것들의 문맥(context)을 포함한다.

> 클로저(closure)란 단어의 어원이 문맥을 포괄함(enclosing context) ... 이 지역 인수는 함수 내부에서 정의되었지만, 코드 블록이 이 인수에 바인딩되어 있고, 따라서 코드 블록이 존재하는 동안에 이 인수 값은 유지되어야 한다.

> 구현 과점에서 보면, 클로저 인스턴스는 생성될 때 스코프 내에 있던 모든 것을 캡슐화하여 유지한다. 클로저 인스턴스가 가비지 컬렉션으로 사자리면 참조되었던 것들 모두가 같이 없어진다.

> 클로저 바인딩의 내부 원리를 설명하기 위해서 그 내부 상태를 외부에서 조작했지만, 단지 그러기 위해서 클로저를 만드는 것은 좋은 생각이 아니다. 상수와 같이 변하지 않는 값을 바인딩하는 것이 보편적이다.

> 클로저를 사용하지 않아도 비슷하게 구현이 가능하지만, 어떤 경우에나 개발자가 직접 내부 상태를 관리해야 한다. 왜 클로저의 사용이 함수적 사고를 예시하는지가 여기에서 분명해진다. 런타임에 내부 상태의 관리를 맡겨버리는 것이다. 직접 필드를 생성하고 그 상태를 관리하기보다는(멀티스레드 환경에서는 훨씬 더 끔직할 것이다) 언어나 프레임워크가 보이지 않게 그 상태를 관리할 수 있도록 놔두라.

> 클로저는 지연 실행(deferred execution)의 좋은 예이다. 클로저 블록에 코드를 바인딩함으로써 그 블록의 실행을 나중으로 연길할 수 있다. 예를 들어 클로저 블록을 정의할 때는 필요한 값이나 함수가 스코프에 없지만, 나중에 실행 시에는 있을 수가 있다. 실행 문맥을 클로저 내에 포장하면 적절한 때까지 기다렸다가 실행할 수 있게 된다.

> 명령형 언어는 상태로 프로그래밍 모델을 만든다. 그 좋은 예가 매개변수를 주고받는 것이다. 클로저는 코드와 문맥을 한 구조로 캡슐화해서 행위의 모델을 만들 수 있게 해준다. 이렇게 만들어진 클로저는 마치 전통적인 자료구조처럼 주고받을 수도 있고, 적잘한 시간과 장소에서 실행할 수도 있다.

3. 커링과 부분 적용
> 커링(currying)은 다인수(multiargument) 함수를 일인수(single-argument) 함수들의 체인으로 바꿔주는 방법이다. 이것은 그 변형 과정이지 변형된 함수를 실행하는 것을 지칭하는 것은 아니다. 함수의 호출자가 몇 개의 인수를 고정할지를 결정하며 적은 수의 인수를 가지는 함수를 유도해낸다.

> 부분 적용(partial application)은 주어진 다인수 함수를 생략될 인수의 값을 미리 정해서 더 적은 수의 인수를 받는 하나의 함수로 변형하는 방법이다. 이 방법은 이름이 의미하듯이 몇몇 인수에 값을 미리 적용하고 나머지 인수만 받는 함수를 리턴한다.

> 커링이나 부분 적용 모두 몇몇 인수의 값만 주면 인수가 몇 개 빠져도 호출할 수 있는 함수를 리턴해준다. 다만 커링은 체인의 다음 함수를 리턴하는 반면에, 부분 적용은 주어진 값을 인수에 바인딩시켜서 인수가 더 적은 하나의 함수를 만들어준다.

> process(x, y, z)의 완전히 커링된 버전은 process(x)(y)(z)이다. 여기에서 process(x)와 process(x)(y)는 인수가 하나인 함수이다. 첫 인수만 커링을 하면 process(x)의 리턴 값은 인수가 하나인 또 하나의 함수이다. 이 함수의 리턴 값은 또 하나의 일인수 함수인다. 반면에 부분 적용을 사용하여 변환하면 인수 숫자가 적음 함수가 남는다. process(x, y, z)의 인수 하나를 부분 적용하면 인수 두 개짜리의 process(y, z)가 된다. 이 두 가지 방법은 종종 같은 결과를 낳는다.