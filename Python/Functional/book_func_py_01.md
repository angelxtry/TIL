# 1. 함수형 프로그래밍 소개

> 함수형 프로그래밍은 식(expression)과 평가(evalution)를 사용하고 주로 이들을 함수에 캡슐화하여 계산을 정의하는 것이다. 그것은 변경 가능한(mutable) 객체나 상태 변경의 복잡성을 피하거나 그 중요성을 감소시킨다. 이를 통해 더욱 간결하고 이해하기 쉬운 프로그램이 만들어지는 경향이 있다.

> 파이썬은 명령 중심의 프로그래밍 언어(imperative programming language)가 제공하는 모든 최적화 능력을 그대로 유지한다.

이게 무슨 의미일까? 명령 중심의 프로그래밍 언어가 제공하는 모든 최적화 능력을 그대로 유지한다?

* 함수형 프로그래밍과 명령 중심 프로그래밍
    * 이 둘을 구분하는 중요한 특징 하나는 상태에 대한 개념이다.

> 이러한 언어가 명령적인 이유는 각 문장(statement)의 상태를 어떤 식으로든 변경하는 명령(command)이기 때문이다.

> 한 가지 접근 방법으로는 최종 상태를 정의하고, 그 최종 상태에 대해 성립해야 하는 명제를 알아낸 후, 그 명제를 달성하기 위한 여러 전제 조건을 거꾸로 연역해 나가는 것이다. 이러한 설계 과정은 납득할 만한 초기 상태가 만들어질 때까지 반복할 수 있다.

내가 개발하는 방식이다. 나만이 아니라 명령형 프로그램을 작성하는 대부분의 방식인가?

> 함수형 언어에서는 상태(변수를 변경한다는 의미)를 함수를 평가한다는 좀 더 단순한 표현 방식으로 대치한다. 함수를 평가하면 새로운 객체가 생기거나 기존 객체에서 다른 객체가 만들어진다. 함수형 프로그램은 함수의 합성이기 때문에 쉽게 이해할 수 있는 저수준 함수를 작성할 수 있고, 복잡한 문장을 순서대로 나열한 것보다 쉽게 머릿속에 그릴 수 있는 고수준 함수의 합성을 정의할 수 있다.

* 절차형(procedual) 패러다임과 객체지향 패러다임
    * 객체지향 프로그래밍은 명령형 프로그래밍의 하위 집합이다.

## 절차형 프로그램
```py
s = 0
for n in range(1, 10):
    if n % 3 == 0 or n % 5 == 0:
        s += n
print(s)

```

## 객체지향 프로그램

* 상태가 있는 컬렉션 객체인 m에 중간 값을 누적시킨다.
```py
m = list()
for n in range(1, 10):
    if n % 3 == 0 or n % 5 == 0:
        m.append(n)
print(sum(m))

```

> 객체 모델을 더 극단적으로 적용하여 list의 하위 클래스를 만들고 sum을 추가할 수도 있다.

```py
class SummableList(list):
    def sum(self):
        s = 0
        for v in self.__iter__():
            s += v
        return s

m = SummableList()
for n in range(1, 10):
    if n % 3 == 0 or n % 5 == 0:
        m.append(n)
print(m.sum())

```

* SummableList는 list를 상속받음
    * sum 메소드를 정의

> 변수 m을 list() 메서드가 아니라 SummableList() 클래스로 초기화한다면, sum(m) 메서드 대신 m.sum()을 사용할 수 있을 것이다. 이러한 변경은 파이썬이 진정으로 완전한 객체지향 언어임을 더욱 명확히 보여준다. 전위표기법은 단지 구문상 편의를 제공하는 것일 뿐이다.

전위표기법이 있으면 후위표기법도 있을까? 전위표기법의 의미가 무엇일까?

> 방금 본 세 가지 예제는 모두 프로그램의 상태를 명시적으로 보여주기 위해 변수에 의존한다. 이들은 대입문을 사용해 변수의 값을 변경하고, 계산을 완료시키기 위한 다음 단계로 이행시킨다. assert문을 각 예제에 추가하면 원하는 상태 변경이 제대로 구현됐는지 확인할 수 있다.

## 함수형 프로그램

* 함수적인 의미에서 문제를 두 가지 부분으로 나누어 정의
    * 수의 시퀀스 합을 계산
    * 간단한 검사 조건을 통과한 값의 시퀀스를 생성

* 시퀀스의 합
```py
def sum(seq):
    if len(seq) == 0:
        return 0
    return seq[0] + sum(seq[1:])
```

> 시퀀스의 합은 간단한 재귀적 정의로 만들 수 있다. 시퀀스의 합을 두 가지 경우로 정의했다. 기본적인 경우(base case)는 시퀀스의 길이가 0인 경우 전체 합이 0이라고 말한다. 반면, 재귀적인 경우(recursive case)는 시퀀스의 합이 첫 번째 원소의 값과 나머지 시퀀스의 합계를 더한 것이라고 말한다. 재귀적 정의는 더 짧은 시퀀스의 결과를 사용하기 때문에 재귀가 (언젠가는) 기본적인 경우로 넘어갈 것임을 확신할 수 있다.

```py
def until(n, filter_func, v):
    if v == n:
        return []
    if filter_func(v):
        return [v] + until(n, filter_func, v+1)
    else:
        return until(n, filter_func, v+1)
```

> 이 함수에서 우리는 주어진 값 v를 최대값 n과 비교했다. v가 최대값에 도달한 경우에는 빈 리스트를 결과로 돌려준다. 이 부분이 이 재귀의 기본적인 경우다.

> 원소가 하나만 들어가는 매우 작은 리스트를 만들고, 그 리스트 뒤에 until() 함수를 재귀호출해 만들어지는 나머지 리스트를 덧붙인다.

```py
[1, 2] + [3, 4] = [1, 2, 3, 4]
```

```py
mult_3_5 = lambda x: x%3==0 or x%5==0
```

* 이 람다식은 True나 False를 반환한다.

```py
until(10, lambda x: x%3==0 or x%5==0, 0)
```

> 여러 함수형 프로그래밍 언어 컴파일러가 이러한 종류의 단순한 재귀함수를 최적화할 수 있다는 사실을 알아두는 것이 중요하다. 파이썬을 그런 최적화를 수행해주지 않는다.

## hybrid

```py
print( sum( n for n in range(1, 10) if n%3==0 or n%5==0) )
```

* 내포된 제네레이터 식(nested generator expression)

> range(1, 10) 메서드는 반복 가능 iterable 객체다. 따라서, 이 식은 제네레이터 식의 일종이기도 하다. 이 식은 {n | 1 <= n < 10}인 값의 시퀀스를 만들어 낸다.

> 여기서 변수 n은 각 값과 결합되며, 계산의 상태를 표현하는 것이라기보다는 집합의 내용을 표현하는 방법이라 할 수 있다.

> 일단 결합되고 나면, 그 결합 변수의 값은 결코 바뀌지 않는다. 루프 안에 있는 n이라는 변수는 근본적으로 range() 함수가 돌려주는 값을 짧게 부르는 것에 불과하다.

> 제네레이터 식을 가지고 작업하면서, 결합 변수가 게산의 상태를 정의하는 희미한 경계선상에 있다는 것을 알게 될 것이다.

## 객체 생성 살펴보기

> 함수의 교환 법칙이나 결합 법칙이 성립하는 경우, 평가 순서가 바뀌면 만들어지는 객체도 달라질 것이다. 이를 활용하면 결과의 정확성에는 영향을 끼치지 않으면서 성능을 향상시킬 수 있다.

> list의 뒤에 추가하는 등의 작업을 수행한다면 결합 규칙을 변경하여 성능의 향상을 얻을 수도 있다.

```py
import timeit
timeit.timeit("((([] + [1]) + [2]) + [3]) + [4]")
timeit.timeif("[] + ([1] + ([2] + ([3] + [4])))")
```

> 이 경우, 왼쪽에서 오른쪽으로 포개나가는 방식은 상당한 성능상의 이점을 가진다.

## 거북의 스택
> 모든 프로그래밍 언어는 추상화, 라이브러리, 가상 기계 위에 존재한다. 이러한 추상화는 또 다시 다른 추상화, 라이브러리, 가상 기계 위에 존재할 것이다. 가장 적절한 은유는 다음과 같다. 

> 셰계가 큰 거북의 등껍질 위에 존재한다. 그 거북은 다른 큰 거북의 등껍질 위에 서 있다. 그리고 또 다시 그 거북은 또 다른 거북 위에 서 있다. 그 아래로는 계속 거북이다.

> 우리가 작성하는 함수형 파이썬 프로그램은 다음 세 가지 추상화 스택에 의존한다.

> 1. 우리가 만드는 애플리케이션들은 맨 아래 있는 객체를 마주칠 때까지 모두 함수로 이뤄져 있을 것이다.
> 2. 우리의 함수형 프로그래밍을 지원하는 기반인 파이썬 실행 환경은 맨 아래의 무한한 거북을 제외하고는 모두 객체로 이뤄진다.
> 3. 파이썬을 지원하는 라이브러리들은 파이썬이 의존하고 있는 여러 거북이다.

## 함수형 프로그래밍의 고전적인 예제

* 함수의 근을 찾기 위한 뉴튼-랩슨(Newton-Raphson) 알고리즘

> 이 추정 방법의 근간을 이루는 것은 현재의 추정값으로부터 다음 추정값을 계산하는 과정이다. next_() 함수는 sqrt(n)에 대한 현재 추정값 x를 받아 적절한 근을 포착할 수 있는 다음 값을 돌려준다.

```py
def next_(n, x):
    return (x+n/x)/2
```

```py
n = 2
f = lambda x: next_(n, x)
a0 = 1.0
[ round(x, 4) for x in (a0, f(a0), f(f(a0)), f(f(f(a0))), ) ]

[1.0, 1.5, 1.4167, 1.4142]
```

> f() 메서드를 루트 2로 수렴하는 람다로 정의했다. 

> 제대로 된 제곱근으로 수렴하는 무한 수열을 생성할 수 있는 함수는 다음과 같이 작성할 수도 있다.

```py
def repeat(f, a)
    yield a
    for v in repeat(f, f(a)):
        yield v
```

yield a 가 이해되지 않는다. 이건 어떤 역할을 하는걸까?

repeat 함수를 실행하면서 a와 v를 모두 출력해보자. 좀 더 명확해질 것 같다.

> 이 함수는 함수 f()와 초깃값 a를 사용해 추정값들을 생성해낸다.

> repeat() 함수는 f() 함수가 인자를 하나만 받아들일 것이라 생각한다. 하지만 우리가 정의한 next_() 함수는 인자를 둘 받는다. 람다 객체인 lambda x: next_(n, x)를 사용하면 두 변수 중 한 변수를 지정한 next_()의 부분 적용 버전을 만들 수 있다. 파이썬의 제네레이터 함수는 단순한 재귀를 사용할 수 없다. 그 대신, 재귀적인 결과에 대해 명시적으로 반복을 수행하면서 각 재귀 결과값을 개별적으로 yield로 만들어 내야 한다. 단순히 return repeat(f, f(a))를 사용하면, 반복을 끝내면서 값의 시퀀스가 아닌 제네레이터 식을 반환한다.

> 제네레이터 식을 반환하는 대신 모든 값을 반환하는 데에는 다음과 같은 두 가지 방법이 있다.

> 명시적으로 for 루프를 작성할 수 있다.
```py
for x in 반복자: yield x
```

> yield를 사용할 수도 있다.
```py
yield from 반복자
```

> 재귀적 제네레이터 함수값을 만들어 내는 데 있어서는 두 가지 방법이 모두 동일하다. 우리는 yield 형식을 더 강조할 것이다. 하지만 경우에 따라 yield에서 복잡한 식을 만들어 내는 것이 그와 동등한 매핑이나 제네레이터 식을 사용하는 것 보다 명확할 수도 있다.

> 전체 무한 수열이 필요한 것은 아니다. 이 수열에서 어느 두 값의 차이가 충분히 작아서, 두 값을 모두 제곱근이라 불러도 문제가 없다면 수의 생성을 중단할 수 있다. 얼마나 가까운지를 나타내는 데 사용하는 기호는 그리스 문자인 입실론이다. 이를 우리가 잠내할 수 있는 가장 큰 오차 범위라고 생각할 수 있다.

```py
def within(e, iterable):
    def head_tail(e, a, iterable):
        b = next(iterable)
        if abs(a - b) <= e:
            return b
        return head_tail(e, b, iterable)
    return head_tail(e, next(iterable), iterable)
```

> next_(), repeat(), within() 함수를 사용하면 제곱근 함수를 다음과 같이 만들 수 있다.

```py
def sqrt(a0, e, n):
    return within(e, repeat(lambda x: next_(n, x), a0))
```

> sqrt(1.0, 0.0001, 3)과 같은 식은 1.0부터 추정하여 루트 3의 값을 0.0001 오차 범위 안까지 계산할 것이다.
