# 3장. Underscore.js를 직접 만들며 함수형 자바스크립트의 뼈대 익히기

## 3.1 Underscore.js 소개

### 3.1.1 Underscore.js 간단히 써보기

```js
_.each([1, 2, 3], function(val, idx, list) { console.log(val, idx, list); });
```

* `_.each`는 `[1, 2, 3].forEach`와 비슷하게 동작한다.
* `_.ecah`와 `Array.prototype.forEach`는 비슷하지만 사실을 꽤 많이 다르다.

```js
const each1 = _.each(
  [1, 2, 3], function(val, idx, list) { console.log(val, idx, list); }
);
console.log(each1);

const forEach1 = [1, 2, 3].forEach(
  function(val, idx, list) { console.log(val, idx, list); }
);
console.log(forEach1);
```

* 첫 번째로 리턴값이 다르다.
* 함수의 리턴값이 다르다는 것은 큰 차이다.
* `_each`는 자신이 받았던 첫 번째 인자를 그대로 리턴한다.
* Array.prototype.forEach는 undefined를 리턴한다.

```js
_.each({ a: 1, b: 2 }, function(val, key, obj) { console.log(val, key, obj); });
```

* 두 번째 차이는 사용 가능한 값의 종류가 `_each`가 더 많다는 것이다.
* `_each`는 key/value 쌍으로 구성된 객체를 인자로 받을 수 있고
* `$('li')`도 받을 수 있다.
* `$('li')`의 결과는 배열과 비슷한 모습을 지난 jQuery 객체다.
* `_each`는 배열 같은 객체들도 지원한다. (Array Like)

```js
const list = [1, 2, 3, 4, 5, 6];
const result = _.reject(list, function(num) { return num % 2 == 0; });
console.log(result);
console.log(list);

console.log(_.contains([1, 2, 3], 3));

console.log(_.isArray([1, 2, 3]));
```

* `_.reject`는 list를 받아 predicate를 실행하여 true로 평가된 값들을 제외한다. 그리고 남아 있는 값들만 담긴 새로운 list를 리턴한다. (새로운 리스트라는 것이 중요한다.)
* `_contains`는 첫 번째 인자인 배열에 두 번째 인자와 동일한 값이 포함되어 있는지를 true/false로 리턴
* `_isArray`는 객체의 type이 Array가 맞는지를 검사

```js
const users = [
  { id: 1, name: 'ID', age: 32},
  { id: 2, name: 'HA', age: 25},
  { id: 3, name: 'BJ', age: 32},
  { id: 4, name: 'PJ', age: 28},
  { id: 5, name: 'JE', age: 27},
  { id: 6, name: 'JM', age: 32},
  { id: 7, name: 'HI', age: 24},
];
console.log(_.pluck(users, 'name'));

console.log(_.first([5, 4, 3, 2, 1]));
console.log(_.first([5, 4, 3, 2, 1], 1));
console.log(_.first([5, 4, 3, 2, 1], 2));

console.log(_.last([5, 4, 3, 2, 1]));
console.log(_.last([5, 4, 3, 2, 1], 1));
console.log(_.last([5, 4, 3, 2, 1], 2));

console.log(_.rest([5, 4, 3, 2, 1]));
console.log(_.rest([5, 4, 3, 2, 1], 2));

console.log(_.initial([5, 4, 3, 2, 1]));
console.log(_.initial([5, 4, 3, 2, 1], 2));

console.log(_.lastIndexOf([1, 2, 3, 1, 2, 3], 2));
console.log(_.lastIndexOf([1, 2, 3, 1, 2, 3], 3));
console.log(_.lastIndexOf([1, 2, 3, 1, 2], 2));

console.log(_.flatten([[1, 2, 3], [4, 5], 6]));
```

* `_.plunk`는 users처럼 배열 내부의 값들이 key/value 쌍으로 구성된 객체일 때 사용한다. 두 번째 인자로 넘긴 key에 해당하는 value를 모아서 리턴한다.
* `_.first(list)`는 list[0], `_.last(list)`는 list[list.length-1]과 같다.
* `_first`, `_.last`의 두 번째 인자는 앞이나 뒤에서부터 몇 개를 남길 것인지에 대한 옵션이다.
* `_.rest`는 앞쪽의 값을 제외한 새로운 리스트를 리턴한다. 두 번째 인자는 몇 개의 값을 제외할 것인지에 대한 옵션이다.
* `_.lastIndexOf`는 뒤에서부터 동일한 값을 찾아 index를 리턴한다. 뒤에서부터 세는 것이 아니라 뒤에서부터 찾는 것이다.

```js
const eq5 = function(a) { return a === 5; };
console.log(eq5(5));

const neq5 = _.negate(eq5);
console.log(neq5(5));
```

* `_.negate`에게 함수를 전달하면 원래 함수의 결과를 반대로 바꾸는 함수를 리턴한다.
* 받아 둔 함수를 실행하여 나온 결과를 반대로 바꾸는 함수를 리턴하는 함수다.

```js
_.negate = function(func) {
  return function() {
    return !func.apply(this, arguments);
  }
}
```

* negate는 위와 같이 구현되어 있다.

```js
const result = _.filter(
  _.map([1, 2, 3], function(n) { return n * 2; }),
  function(n) { return n <= 4; });
console.log(result);

const result1 = _.chain([1, 2, 3])
  .map(function(n) { return n * 2; })
  .filter(function(n) { return n <= 4; })
  .value();
console.log(result1);
```

* `_.chain`을 이용하면 값을 바꿔 나갈 객체가 생성되고 Underscore.js의 함수들을 체인 방식으로 계속 실행할 수 있다.
* 메서드가 실행될 때마다 내부의 값을 바꿔 놓는다.
* 체인 방식으로 코드를 작성하면 위에서 아래로 코드를 읽어 나갈 수 있다는 장점이 생긴다.
* 마지막에 `.value()`를 실행하기 전까지는 메서드를 계속 실행할 수 있고 `.value()`를 통해 최종값을 얻어낸다.

* 체인 방식을 지원하긴 하지만 기본적으로 Underscore.js의 함수들은 메서드가 아닌 함수다.
* 객체를 만들고 메서드를 실행하는 식으로 사용하지 않는다.
* 이를테면 [1, 2, 3].forEac(...) 처럼 사용하지 않는다.
* 함수는 이미 모두 선언되어 있고 실행하고 싶을 때 실행하면 된다.
* initialize 등이 필요하지 않다.
* 주로 첫 번째 인자가 주요 재료가 되며 두 번재 인자나 세 번째 인자와 함께 사용하여 결과를 만든다.

### 3.1.2

### 3.1.3 지연 평가1 (take)

* Lodash의 성능 개선 상황은 크게 3가지가 있다.
* take를 통한 지연 평가
* map -> map -> map과 같은 상황에서의 지연 평가(lazy evaluation)
* 지연 실행(defered execution)
* 이것들은 모두 체인 방식에서만 동작한다.

* take를 통한 지연 평가에 대한 예제를 보자.

```js
const list = _.range(50);

let _i = 0;
const result1 =
  _.chain(list)
    .filter( num => {
      _i++;
      return num % 2 == 0;
    })
    .take(5)
    .value();
console.log(result1, _i);

let lodash_i = 0;
const result2 =
  lodash.chain(list)
    .filter( num => {
      lodash_i++;
      return num % 2 == 0;
    })
    .take(5)
    .value();
console.log(result2);
```

* lodash의 take를 이용한 filter 성능 개선 로직은 list.length가 200 이상일때부터만 동작한다.
* 200개 이하의 값을 다룰 경우가 더 많다고 가정하면 무조건 지연 평가를 하는 것은 오히려 성능상 불리하다.
* 지연 평가를 하려면 선행 로직이 필요하고, 이후 실행되었을 때에도 take의 값으로 루프를 중간에 나가기 위해 반복문 내부에서 limit == list.length를 체크하는 등 없어도 되는 로직이 추가되어야 하기 때문이다.

* Underscore.js는 모두 즉시 샐행하기 때문에 어떤 것도 남겨 둘 필요가 없다.