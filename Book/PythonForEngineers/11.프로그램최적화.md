# 11. 프로그램 최적화

## 최적화를 위한 4가지 접근법
1. 벙목해소
    * 코딩 방법에 따른 최적화
    * 메모리의 효율적인 사용
    * 프로파일러 활용
2. 병렬처리
    * SIMD 사용
    * 멀티스레드 적용
    * 멀티프로세스 적용
3. 고속 라이브러리(타 언어 구현) 활용
    * Cython 사용
    * C/C++ 라이브러리 활용(ctypes)
4. JIT 컴파일러 활용
    * Numba
    * Numexpr

## 병목해소
* 프로그램의 전체 실행 속도는 가장 처리가 오래 걸리는 부분에 의해 제한 받는다.
* 단순히 계산이 오래 걸리는 부분을 찾아 개선하는 것뿐만 아니라 CPU, 메모리, 하드디스크 간에 데이터를 주고받을 때 발생하는 지연 시간을 고려하는 것이 중요하다.

### 1. 코딩 방법에 따른 최적화
* 선입견 없이 여러가지 방식을 시도해본다.
* 파이썬의 내장 함수 및 표준 라이브러리를 최대한 활용한다.
* 반복문(for, while) 사용을 최대한 피한다.

1. 선입견 없이 여러가지 방식을 시도해본다.
```py
In [13]: %timeit x = 1213; x = x * 2
10000000 loops, best of 3: 50 ns per loop

In [14]: %timeit x = 1213; x = x << 1
10000000 loops, best of 3: 57.7 ns per loop

In [16]: %timeit x = 1213; x = x + x
10000000 loops, best of 3: 48.1 ns per loop
```
* 비트연산보다 덧셈이 더 빠르다.
* 여러가지 방식으로 시도해보자.

### 2. 파이썬의 내장 함수 및 표준 라이브러리를 최대한 활용한다.
* 직접 작성한 함수를 실행할 때의 오버헤드는 내장 함수보다 크다.

### 3. 반복문(for, while) 사용을 최대한 피한다.
* 같은 함수를 for문에서 여러 번 호출하는 것보다 데이터를 한꺼번에 함수에 넘기고 함수 안에서 반복 처리를 하는 쪽이 속도가 더 빠르다.
* Numpy는 이런 메커니즘을 ufunc에서 제공한다.
* 직접 작성한 함수를 for문에서 반복 호출하기 전에 ndarray와 ufunc의 조합으로 for문 사용을 피할 수 있는지 고려하자.

* 