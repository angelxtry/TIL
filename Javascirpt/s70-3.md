# s70 세번째 강의

s70 2번째 강의 결과물의 문제점은 tasks 배열과 STATE_P, STATE_C가 외부로 노출되어 있다는 것이다.

외부에서 노출시킨 addTask, changeState 등을 사용하지 않고도 tasks 등을 직접 제어할 수 있다.

우리가 원하는 것은 addTask, removeTask, changeState만 외부로 노출하고 나머지는 노출하고 싶지 않다.

그러기 위해서 전체를 즉시실행함수로 감싼다.

즉시실행함수로 감싸기만 하면 외부에서 함수 또한 호출할 수 없다.

그래서 즉시실행함수에서 object를 return 한다.

```js
return {
    addTask: addTask,
    removeTask: removeTask,
    changeState: changeState
};
```

캡슐화, 은닉

비슷한 단어 처럼보이지만 의미가 다른다.

은닉은 함수바깥에서 내부의 값을 직접 접근할 수 없도록 숨기는 것이다.

캡슐화는 불필요한 부분을 숨기고 추상화하여 필요한 인터페이스만 노출하는 것을 의미한다.

task나 STATE_P 등을 함수로 감싸서 숨긴 것은 은닉이다.

하지만 은닉을 했다고해서 캡슐화를 한 것은 아니다.

최종적으로 필요한 인터페이스만을 외부로 노출해야 캡슐화가 된 것이다.

어떻게 캡슐화를 하느냐, 어떤 인터페이스를 노출하느냐에 따라 프로그램의 편의성이 달라진다.

addTask는 객체는 생성하고, id를 증가시키는 등 여러가지 일을한다.

하지만 외부에 노출된 인터페이스에서는 파라미터 하나만 받는다.

이것은 우리가 선택한 것이어야 한다.

함수는 파라미터와 출력값(리턴값)으로 외부와 통신을 한다.

함수를 만들때는 이 함수를 사용하게 될 사용자가 어떻게하면 이 함수를 편하고 안전하게 사용할 수 있을지 고민해야한다.

그 고민의 결과물이 파라미터와 출력값이 되어야 한다.

함수는 시그니처와 정의라는 용어를 사용한다.

시그니처는 그 함수에 고유성을 부여하는 특성을 말한다.

함수의 고유성은 함수의 이름과 파라미터로 결정된다. 리턴값은 시그니처를 결정하지 못한다.

함수의 정의는 그 함수의 모든 것을 의미한다.

----

전체 즉시실행함수는 object를 리턴한다. 그래서 변수에 할당해야한다.

```js
var todo = (function(){})();
```

실제로 todo를 사용한다면 todo.addTask('할일'); 처럼 사용할 것이다.

여기서 todo.addTask는 의미 중복이다.

그러므로 캡슐화할 때 노출하는 이름을 변경해준다.

```js
return {
    add: addTask,
    remove: addTask,
    changeState: changeState
};
```

모든 이름은 이 함수를 쓸 사람을 위해 만들어야 한다.

----

changeState에 집중해보자.

changeState가 가질 수 있는 값은 STATE_P, STATE_C 밖에 없다.

하지만 노출된 인터페이스에서는 훨씬 더 많은 종류의 값을 받을 수 있다.

이럴 경우 toggle이라는 메소드로 변경하는 것이 낫다.

toggle로 인터페이스를 수정해보자.

```js
return {
    add: addTask,
    remove: removeTask,
    toggle: function(id){
        for(var i = 0; i < tasks.length; i++){
            if(tasks[i].id === id){
                if(tasks[i].state === STATE_P){
                    changeState(id, STATE_C);
                } else {
                    changeState(id, STATE_P);
                }
                break;
            }
        }
    }
};
```

toggle로 변경하면 changeState의 상태값을 직접 파라미터로 입력받을 필요가 없다.

실제로 todo.toggle(0) 이런식으로 처리하면 0번 인덱스의 작업 상태가 변경될 것이다.

이때도 0이라고 직접 입력하는 것보다 add 함수가 id를 리턴한다면 이 id를 활용할 수 있다.

```js
var addTask = (function(){
    var id = 0;

    return function(title){
                tasks.push({
                    id: id++,
                    title: title,
                    state: STATE_P
                });

                render();
                
                return id - 1;
            };
})();
```

이제 id를 리턴할 수 있게 되었지만 id++ -> id - 1은 혼란스럽다.

```js
var addTask = (function(){
    var id = 0;

    return function(title){
                var result = id;

                tasks.push({
                    id: id++,
                    title: title,
                    state: STATE_P
                });

                render();

                return result;
            };
})();
```

이렇게 변경하면 result는 리턴을 위해 사용되는 코드이고 id는 push에서 1씩 증가한다라는 것을 조금 전 코드보다 더 명확하게 알 수 있다.

작성한 코드를 사용해보자.

```js
var taskId = todo.add('할일');
todo.toggle(taskId);
```

이렇게 사용할 수 있다.

이제 toggle은 state를 파라미터로 받지않기 때문에 state의 입력 파리미터를 검증할 필요가 없어졌다.

(파라미터가 없는 함수가 가장 좋은 함수, 1개인 함수가 2번째로 좋은 함수, 2개인 함수가 3번째로 좋은 함수다. 4번째로 좋은 함수는 없다. 어쩔 수 없어서 사용하는 것이다.

좋은 프로그램을 만들려면 1. 기능을 구현하고 2. 사용자가 이 기능을 어떻게 사용할 지를 고민해야한다.)

toggle을 구현했으니 toggle이 호출하는 changeState를 다시 보자.

```js
var changeState = function(id, state){
    var ID = false;
    var STATE;
    for(var i = 0; i < tasks.length; i++){
        if(tasks[i].id === id){
            ID = id;
            break;
        }
    }
    if(ID === false){
        warning('changeState: invalid id - ' + id);
        return;
    }

    if(state !== STATE_P && state !== STATE_C){
        warning('changeState: invalid state - ' + state);
        return;
    } else {
        STATE = state;
    }

    for(var i = 0; i < tasks.length; i++){
        if(tasks[i].id === ID){
            tasks[i].state = STATE;
            break;
        }
    }

    render();
};
```

changeState는 이제 외부에서 직접 호출할 수 없다. toggle을 통해서만 호출이 가능하다.

외부에서 입력받은 값은 무조건 validation을 해야한다.

하지만 changeState와 toggle은 같은 즉시실행함수 안에 포함되어 있다.

이 경우 changeState와 toggle은 같은 내부라고 판단한다.

changeState의 두번째 파라미터인 state는 사용자에게 입력받는 값이 아니라 toggle 에서 설정된 값만 입력받을 수 있다.

그러므로 changeState에서 state의 validation code는 불필요하다.

```js
var changeState = function(id, state){
    var ID = false;
    var STATE;
    for(var i = 0; i < tasks.length; i++){
        if(tasks[i].id === id){
            ID = id;
            break;
        }
    }
    if(ID === false){
        warning('changeState: invalid id - ' + id);
        return;
    }

   for(var i = 0; i < tasks.length; i++){
        if(tasks[i].id === ID){
            tasks[i].state = STATE;
            break;
        }
    }

    render();
};
```
changeState 함수에서 state의 validaion code를 그대로 남겨두어도 전혀 오류가 발생하지 않는다.

하지만 이 코드는 절대로 남겨두어서는 안된다.

첫번째 파라미터인 id에 대한 validation은 존재한다. 하지만 state에 대한 validation은 없다.

이것으로 state가 어디선가 validation 과정을 거쳤고 changeState는 내부함수에서 이 값을 넘겨받았기 때문에 changeState에서 validation을 생략했다고 유추할 수 있게 코드를 작성해야 한다.

(개발은 조각과 비슷한다. 대리석을 만족할때까지 깍아가는 과정이다.

언제 만족할 것인가가 개발자의 수준이다.

좋은 코드와 나쁜 코드를 구별하는 기준은 객관적이다.

대리석을 망치로 몇 번 깨본 경험은 조각가를 만들지 못한다.

얼마나 디테일하게 조각을 해보았는가가 조각가를 만든다.)

----

이 프로그램에서 console.log만 native code다.

내가 만들어서 메모리에 올라가는 코드만 non-native code다. console.log는 내가 작성한 것이 아니다.

native code의 호출이 필요한 부분은 모두 render()에 위임했다.

이제 render()를 console과 html 중 선택하여 출력할 수 있도록 수정해보자.

일단 모드를 선택할 수 있도록 변수를 하나 추가한다.

```js
var mode = 'console';
```

그리고 현재 render()를 renderConsole()로 변경한다.

새롭게 render()를 만들어 mode에 따라 renderConsole()과 renderHtml()을 호출할 수 있도록 처리한다.

이렇게 만들면 render(), renderConsole(), renderHtml()은 모두 별개의 함수다.

하지만 renderConsole()과 renderHtml()은 render()만 알고 있으면 된다.

그래서 renderConsole()과 renderHtml()을 익명함수로 만들고 render()를 즉시실행함수로 변경한다.

48분 22초