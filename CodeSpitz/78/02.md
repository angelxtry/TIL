# 20180906 02

## SPREAD REF

- 참조는 전파된다.

- A와 B가 서로 참조하고 있다면 언젠가는 A와 B를 건드릴 수 없게 된다.
- 참조를 끊어야 한다.

## sub routine chain

- 함수를 호출했을 때 만들어지는 메모리 - excution context
- excution context에는 인자와 지역변수가 있다.

- ec가 만들어질 이유가 없다면 call stack이 만들어질 이유도 없다.
- 함수의 리턴 포인트를 최초 호출 함수로 변경해주어야 하는데 이것은 언어 수준에서 제공해주어야 한다.
- 이것을 꼬리 물기 최적화 tail recursion optimazation이라고 한다.

- 제어문은 스택 클리어라는 기능을 가지고 있다.
- ex: for, while
- for문이 반복되는 동안 불필요한 스텍 메모리가 누적되지 않는다.

- 사파리에서는 tail recursive하게 재귀를 작성했다면 stack overflow로 죽지 않는다.

- 모든 연산자는 스텍 메모리를 요구한다. 그래서 tail recursion이 되지 않는다.

- 함수 내부에서 메모리에 담고 있어야할 것들을 인자로 추가하여 전달하면 tail recursive하게 만들 수 있다.

- 재귀적인 로직이 있다면 무조건 꼬리 물기 최적화가 되도록 작성해야 한다.

```js
const sum = (v, prev = 0) => {
  prev += v;
  return (v > 1 ? sum(v-1, prev) : prev);
}
```

- prev는 외재화된 메모리다.

```js
const sum = (v) => {
  let prev = 0;
  while(v > 1) {
    prev += v;
    v--;
  }
  return prev;
}
```

- 꼬리 물기 최적화는 자동으로 루프로 변경할 수 있다.
- 외재화된 변수를 루프의 변수로 바꾸면 된다.
- 꼬리 물기 최적화를 루프로 기계적으로 변경할 줄 알아야 한다.
- 꼬리 물기를 지원하지 않는 언어는 루프로 변경해야만 한다.

## closure

- 루틴을 문으로 처리하는 언어가 있고 값으로 처리하는 언어가 있다.
- closure는 런타임 중에 루틴을 만들 수 있는 언어에서만 사용할 수 있다.

- 런타임에 루틴을 만들 수 있는 언어는 처음부터 함수가 존재하는 것이 아니라 main flow가 진행되는 도중에 생겨날 수 있다.
- 런타임에 루틴이 만들어지면 그 루틴은 만들어진 환경을 기억한다.
- 이런 환경은 scope라고 한다.
- 이 scope에 속해 있는 변수가 있다.
- 해당 루틴이 만들어지는 순간 알 수 있는 변수를 자유 변수라고 한다.
- 서브루틴이 루틴의 변수를 사용한다면 루틴의 변수는 자유 변수가 되고 서브루틴은 클로저가 된다.
- 외부에서 서브루틴을 참조한다면 루틴이 사라져도 서브루틴과 자유변수는 존재한다.

## nested closure

- 함수가 아니라 블록만 만들어도 클로저가 생길 수 있다.

## shadowing

- 중첩된 클로져에서 동일한 이름이 존재하면 shadowing이 발생한다.
- 네임스페이스를 정의할 때 사용한다.
- 즉, 바깥쪽에 있는 자유변수를 보호하기 위해 사용한다.
- 서브루틴이 바깥쪽의 자유변수를 건들 수 없게 만드는 유일한 방법이다.
- 고의적으로 블럭을 만들어 shodowing을 사용하여 자유변수를 보호한다.

## co routine

- 여러번 호출하고 여러번 응답할 수 있는 routine
- single routine은 한번 호출하면 무조건 끝까지 실행된다.

- 공유해야 할 상태가 많아지면 인자로 주고 받기 힘들어진다.
- co routine을 이용하면 상태가 지역변수로 공유될 수 있다.

- generator는 co routine을 만들어낸다.
