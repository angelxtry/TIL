# 프로그래밍의 정석

## Chpter4. 관점 - 프로그래머가 보는 시각

## 직교성(Orthogonality)
> 코드 간에 독립성과 분리성을 갖도록 한다. 2개 이상의 코드 덩어리가 있으면서 한쪽을 변경해도 다른 쪽에 영향을 주지 않는다면 해당 코드는 직교하고 있다.

> 직교하고 있는 코드는 변경에 강한 코드다.

> 코드 간의 결합도를 최소화하기 위해 계층화
> * 모듈들을 계층별로 정리하고 계층별로 추상화
> * 각 계층에서는 바로 하위 계층이 제공하는 추상화된 기능만을 사용
> * 이렇게 하면 상위 계층의 코드에 영향을 미치지 않고 하위 계층의 구현을 변경할 수 있음
> * 계층화에 의해 모듈 간의 관계가 정리됨

> 직교성을 충족하기 위해 전역 데이터는 사용하지 않도록 한다.

> 계층화의 장점
> * 다른 계층을 잘 알지 못해도 하나의 계층을 전체로서 생각할 수 있다.
>   * 이더넷의 동작 방법을 모르더라도 TCP 상에 있는 FTP 서비스를 구축하는 방법을 이해할 수 있다.
> * 다른 계층에 영향을 미치지 않고 대체 구현으로 계층을 교체할 수 있다.
> * 계층 간의 종속을 최소한으로 할 수 있다.
> * 계층은 표준화에 적합하다.
> * 계층을 구축하면 다양한 고수준 서비스가 해당 계층을 사용할 수 있다.

> 계층화의 단점
> * 계층 간의 변경이 연쇄적인 경우가 있다.
> * 계층을 추가하면 성능이 나빠질 수 있다.
>   * 계층을 지날 때마다 데이터 형식을 변환할 필요가 있는데 데이터 변환이 오버헤드가 될 수 있다.

> 릴레이션의 직교성
> * 관계형 데이터베이스의 기초 이론. 코드의 직교성과는 의미가 다르다.
> * 정규화
>   * 하나의 릴레이션(테이블)의 내부에서 중복을 없에는 것
> * 릴레이션의 직교성
>   * 여러 릴레이션 간의 같은 값을 포함하지 않는다는 의미

> 릴레이션의 정의
> * 테이블 간의 관계라는 의미가 아니다.
> * 관계 데이터 모델에서 릴레이션은 제목과 본체의 쌍으로 구성
>   * 제목: 임의의 개수로 구성된 속성의 집합
>   * 속성: 이름과 데이터형의 쌍
>   * 본체: 속성값의 집합인 튜플(레코드)의 집합
> * 릴레이션: 테이블
> * 속성: 컬럼
> * 튜플: 행

## 4.4 가역성(Reversibility)
> 어떤 변화가 발생해도 특정 조건을 가하면 원래 상태로 돌아오는 성질

> 특정 기술에 종속되지 않는다.
> * 가역성을 고려해서 데이터베이스 접근 부분이 추상화되어 있다면 현실적인 공수로 변경할 수 있다.

> 구체적인 상세 코드를 작성하기 전, 아키텍처 설계 시점에 가역성을 고려
> * 배치하는 플랫폼이나 서드파티 컴포넌트 등 해당 소프트웨어 이외의 것과 경계며네 해당하는 곳의 유연성은 가역성을 적용했을 때 효과가 크다.

## 4.5 코드의 악취
> 리펙토링이란 외부에서 보는 코드의 동작을 바꾸지 않고 코드 내부의 구조를 개선하는 기법
> * 중복된 코드는 하나의 함수로
> * 함수가 너무 길면 분할
> * 모둘이 너무 크다는 것은 역할이 너무 많다는 것이다. 분할하게 작게

## 4.6 기술 부채
> 소프트웨어 개발에서 시간을 채용한다는 개념은 해야 할 일을 어떻게든 완수해 내면서 위험 요소가 있는 마일스톤을 달성하는 데 도움이 되는 전략

> 소프트웨어는 일시적으로 불완전한 상태가 되지만 불안 요소가 책임하에 관리된다면 타당한 선택

> 긴급 배포를 통해 재앙을 피했다면 즉시 변경 전 상황으로 되돌리고 거기서부터 본래 있어야 할 깨끗한 코드로 수정해야 한다.

> 지저분한 코드를 기억하고 있는 동안에, 담당자가 아직 있는 동안에 재빨리 변제하는 것이 가장 확실한 방법이다.

> 그리고 곧장 다음 배포에 해당 수정을 집어넣도록 한다.

## 5. 습관 - 프로그래머의 일상

## 5.3 성능 튜닝에 관한 금언
> 너무 이른 시점의 최적화는 모든 악의 근원이다.

> 아키텍처를 설계할 때는 성능을 고려하는 쪽이 좋은 경우도 있다.
> * 조기에 수행한 성능 테스트는 그 뒤로도 계속해서 수행한다.
> * 변경을 가했을 때 성능이 급감하는지 알 수 있다.

## 5.5 한 걸음씩 조금씩
> 필요한 테스트 코드를 전부 작성한 다음에 정식 코드를 전부 작성하는 방식으로 해서도 안 된다.

> 조금씩 테스트 코드를 작성하고 조금씩 정식 코드를 작성하는 과정을 반복해야 한다.

> 신규 함수를 작성할 때 아직 어디에서도 사용되지 않는다고 해도 일단 컴파일 함으로써 문법 오류가 없다는 점을 확인할 수 있다.

## 6. 기법 - 프로그래머의 도구 상자

## 6.1 예광탄
> 프로그래밍에서 예광탄이란 우선적으로 검증하고 싶은 부분을 선행적으로 프로그래밍하는 것이다. 간이 형태라도 상관없으니 싱제 환경에서 동작하고 확인할 수 있는 종단간(end-to-end) 소프트웨어를 작성한다.

> 소프트웨어 개발에서 예광탄과 똑같은 효과를 내려면, 소프트웨어의 최종 형태에 대한 결정을 신속하고 눈에 보이는 형태로 반복해서 제시할 수 있어야 한다. 그렇게 하려면 일부만이라도 실물 소프트웨어가 필요하다.

> 예광탄 프로그램의 장점
> * 사용자로부터 피드백
> * 프로그래머가 활약할 수 있는 무대를 조기에 정비
> * 디버깅과 테스트를 빠르고 정확하게
> * 항상 테모를 수행할 수 있는 환경 마련
> * 사례 단위로 개발에 착수할 수 있다 생선성의 보고나 사용자에 대한 진척 보고가 간단해진다.

> 프로토타입
> * 최종 사용자가 사용성을 확인할 수 있는 정도의 화면 레이아웃이나 유사 조작을 추가
> * 버튼을 눌렀을 때 실제적인 기능이 동작하지 않아도 상관없다.
> * 사용자 인터페이스에 대한 합의를 이룬 시점에서 폐기

> 예광탄
> * 프로그래머에게 앞으로 계속 사용할 아키텍처의 골격을 제공
> * 사용자에게 어떤 사용성이 있는지 제시

## 6.2 계약에 의한 설계
> 사전조건: 함수를 호출하는 쪽이 지켜야 할 계약

> 사후조건: 함수가 지켜야 할 계약

> 함수와 함수를 호출하는 쪽이 서로 계약을 맺고 있다고 간주하고 프로그래밍 하는 것을 가리켜 '계약에 의한 설계'라고 한다.

> 올바른 파라미터를 전달하는 것은 함수를 호출하는 쪽의 책임이다.

> 함수의 맨 마지막에서는 함수가 사후 조건을 충족해야 한다. 함수 호출 후에 보증되어야 할 조건을 갖추는 것은 함수 쪽의 책임이다.

> 계약의 장점
> * 코드가 올바르다는 것을 보증할 수 있다. 올바른 코드란 요구되는 것 이상도 이하도 수행하지 않는 코드를 뜻한다.
> * 코드를 단순하게 만들 수 있다. 사전 조건이 충족되어 있다고 가정해서 함수의 처리 코드를 작성할 수 있기 때문이다.
> * 문제를 조기에 발견하기 쉬워진다. 계약을 완수할 수 없는 뭔가가 발생했는데도 이를 놓치는 거은 장애의 시작이다. 문제 발생 시점에서 조기에 크래시를 발생시켜야 장애를 진단하기 쉬워진다.

> * 계약 내용을 미리 함수의 주석으로 알려두자.
> * 계약 이행의 확인을 위한 코드는 단정문으로 표현하자.
> * 사전 조건과 사후 조건의 확인에는 단정문을 사용해서 계약이 이행되지 않았다면 소프트웨어가 중지되도록 해둔다.

> * 호출받는 함수 쪽에서는 건네받은 파라미터를 조정해서는 안 된다.
> * 호출받는 함수 쪽에서 파라미터를 검사하고 사전 조건에 맞게끔 변환하는 처리를 해서는 안 된다.
> * 이런 처리는 함수를 호출하기 전에 호출하는 쪽에서 수행한다.
> * 호출받는 함수 쪽은 계약에 근거하여 안심하고 파라미터를 사용해야 한다.
> * 결과적으로 코드가 단순해진다.
> * 다만 호출받는 함수 쪽에서는 상정 외의 파라미터가 넘어왔을 때를 대비해 계약 이행을 단정문으로 확인해서 디버깅 효율성을 높인다.

> * 외부 입력값 중 대표적인 것이 화면에서의 사용자 입력값이다.
> * 다만 사전 조건은 어디까지나 '함수'와 '함수를 호출하는 쪽'의 계약이지, '함수'와 '사용자 입력'의 관계가 아니다.
> * 계약을 완수하지 못했다는 말은 사용자의 입력 실수와는 질적으로 다른 현상이다.
> * 사용자 입력 확인은 함수를 호출하기 전에 함수를 호출하는 쪽에서 수행한다.

> * 뭐든지 받아들이고 언제나 제대로 된 결과를 보증할 수 있게끔 하려면 대량의 코드를 작성해야 한다.
> * 그렇게 되지 않도록 처리를 시작하기 전에 받아들이는 사전 조건을 엄격하게, 결과를 반환할 때는 가능한 한 사후 조건을 적게 하자.

> 클래스 불변 표명
> * 클래스를 사용하는 쪽에 대해 항상 참이 된다는 것을 보증하는 것
> * 메서드의 내부 처리 중에는 보증되지 않지만 메서드가 종료되어 제어가 호출한 쪽으로 돌아감과 함께 클래스 불변 표명이 보증된다.
> * 보증하는 것은 클래스 쪽의 책임이다.

> 단정문
> * 코드에서 상정 외의 사항은 단정문을 통해 표현한다.
> * 단정문이 참이라는 말은 모든 것이 순조롭게 실행되고 있다는 것을 의미
> * 단정문이 거짓이면 소프트웨어는 실행을 중단하고 오류 메시지를 표시해서 알려준다.
> * 단정문에 넘겨주는 조건식에는 변수값을 바꾸는 등의 부작용이 없도록 한다.
> * 단정문은 배포본 소프트웨어에는 넣지 않는다.

## 6.3 방어적 프로그래밍
> '이렇게 될 것이다'라고 결정짓지 말고 프로그래밍한다.

> 함수에 잘못된 데이터가 넘어왔을 때 그것이 다른 함수 탓이었다고 해도 피해를 입지 않도록 방어적인 코드를 작성해 둔다.

> 외부 소스에서의 데이터 입력값을 확인한다.(상정 내의 오류를 검출)
> * 파일, 사용자 인터페이스, 네트워크, 그 밖에 외부 인터페이스로부터 데이터를 얻어 온다면 데이터가 허용 범위 내에 들어와 있다는 것을 확인한다.
> * 숫자가 유효 범위에 포함되어 있는지
> * 문자열의 길이가 규정 안에 있는지
> * 무효한 입력을 가으한 한 조기에 검출하고 즉시 적절한 오류 처리를 수행한다.

> 함수의 입력 파라미터값을 확인한다.(상정 외의 오류를 검출)
> * 다른 함수에서 전달된 함수의 입력 파라미터 값을 확인한다.
> * 외부에서 전달된 데이터를 확인하는 것과는 달리, 여기서 무효한 입력을 검출한다는 것은 버그를 의미한다.
> * 단정문을 사용해서 파라미터르 확인하고 잘못된 값을 때는 즉시 프로그램을 정지한다.

> 코드에 바리케이드를 구축한다.
> * 바리케이드를 구축하려면 특정 인터페이스를 '안전지대로의 경계'로 사용한다.
> * 안전지대로의 경계를 통과하는 데이터를 검증해서 잘못된 데이터에는 적절한 조치를 취한다.

> 상정 외의 오류는 '단정문'으로 대응하고, 상정 내의 오류는 각각 적절한 '오류 처리'로 대응한다.
> * 바리케이드 외부에서 데이터가 들어오면 바리케이드(검증 모듈)을 거친다.
> * 바리케이드에서 '오류 처리'를 적용한다.
> * 바리케이드 내부에서 데이터 오류가 발생했다면 '오류 처리'가 아닌 '단정문'을 적용한다.

## 6.4 개밥 먹기

## 6.5 고무 오리
> 남에게 문제를 설명하려면 우선 코드를 통독하고 그중에 존재하는 암묵적인 가정을 명확히 해야 한다. 이런 가정을 언어로 표현함으로써 문제에 대한 새로운 식견이 생겨나고 해결의 실마리를 찾을 수 있다.

## 6.6 컨텍스트
> 코드의 읽고 쓰기에 사용
> * 코드의 읽고 쓰기는 코드를 작성하는 사람과 코드를 읽는 사람과의 의사소통이다.
> * 코드를 작성할 때는 코드를 읽는 사람에게 컨텍스트를 양성해 줄 필요가 있다.
> * 따라서 코드를 적성할 때는 내용을 하향식으로 전하도록 한다.
> * 구체적으로는 모듈명처럼 큰 묶음의 이름을 통해 여기서는 무엇에 관한 책임을 가졌는지를 명확히 제시한다.
> * 모듈 안에 포함되는 함수 역시 모듈명을 컨텍스트로 삼으면서, 함수 안에서 무엇을 처리하고 있는지를 이름으로 나타낸다.
> * 그렇게 하면 코드를 읽는 사람 입장에서는 마치 책 페이지 하단부에 있는 장이나 절의 이름을 보는 것처럼 모둘이나 함수의 이름을 통해 현재 위치를 상기할 수 있다.

> 생각의 도구로 사용

> 어떤 것을 설명할 때 컨텍스트를 덧붙여 제시하면 뿔뿔이 흩어졌던 정보가 이어진다.

> 프로그래밍의 달인이라고 불리는 사람이 다양한 패턴을 자유자재로 사용하는 것은 패턴을 많이 알고 있기 때문이 아니다.

> 패턴을 어떤 상황에서 어떤 목적으로 사용해야 좋은지를 알고 있기 때문이다. 이것이 바로 컨텍스트다.

> 뇌는 처음에 '이제부터 이런 정보가 들어온다'는 힌트를 전달받기만 해도 처리 능력이 극적으로 높아진다. 이것이 바로 컨텍스트의 전달 능력이다.

> 책을 읽을 때 단어와 단어를 이어서 문장으로 하고, 문장과 문장을 이어 문단으로 하는 상향식 읽기로 하면 뇌에 매우 큰 부하가 걸린다.

> 책의 표제를 의식적으로 제대로 읽기만 해도 다음 단락이나 문장에 대한 이해가 원활해진다.

> 팀은 하이 컨텍스트 지향으로
> * '하이 컨텍스트'란 어떤 공동체에서 배경이나 가치관 등에 많은 공통 인식이 깔린 상태를 가리킨다.

## 7. 법칙 - 프로그래밍의 안티패턴

## 7.1 브룩스의 법칙
> 일정이 늦어지고 있는 소프트웨어 개발 프로젝트에서 지연을 만회하기 위해 후반에 사람을 추가하면 오히려 더 지연된다.

> man과 month는 교환법칙이 성립하지 않는다.

> 생산성은 출관과 유사하다. 10명의 임신부를 모아놨다고 해서 1개월만에 아기를 출산할 수 없다.

## 7.2 콘웨이의 법칙
> 소프트웨어의 구조, 즉 '아키텍처'는 그것을 만든 '조직'을 반영한다.

> 자연에 맡기면 아키텍처는 조직을 따라가지만 오히려 정답은 앞뒤가 반대다. 즉, 좋은 아키텍처를 설계한 다음, 그렇게 만든 아키텍처에 조직이 맞춰져야 한다.

> 조직을 그대로 둔 채 아키텍처 쪽만 최적으로 변경하면 의사소통 경로에 불일치가 생긴다. 조직의 구성 요소가 소프트웨어의 구성 요소를 반영하지 못하는, 혹은 조직 간의 관계가 소프트웨어의 구성 요소 간의 관계를 반영하지 못하는 상태가 되기 때문이다.

> 다만 조기에 작성된 아키텍처는 근사해에 불과하다. 아키텍처는 불안정하다. 너무 이른 시기에 아키텍처에 따른 조직을 만들면 아키텍처의 변화에 조직이 따라갈 수 없다. 따라서 아키텍처가 충분히 검증된 다음에 조직을 구성하는 방식이 효율적이다.


