# Node properties: type, tag and contents

## Question

## 내용

DOM node에 대해 좀 더 알아보겠습니다.

### DOM node classes

DOM node 마다 다른 property를 가지고 있습니다.

예를 들어 <a> tag element node는 link와 관련된 property를 가지고 있습니다. text node와 element node를 비교해도 서로 다른 property를 가지고 있다는 것을 알 수 있습니다. 하지만 모든 node는 DOM node 이기 때문에 공통 method와 property도 가지고 있습니다.

```js
EventTarget
|- Node
    |- Text
    |- Element
    |   |- SVGElement
    |   |- HTMLElement
    |       |- HTMLInputElement
    |       |- HTMLBodyElement
    |       |- HTMLAnchorElement
    |- Comment
```

계층 구조의 root에 EventTarget이 있습니다. 이것을 Node가 상속받고 다른 DOM node들은 Node를 상속받습니다.

EventTarget

- root abstract class 입니다. 이 object는 실제로 생성되지 않습니다. DOM node의 event를 지원하기 위한 base 역할을 합니다.

Node

- DOM node의 기반 역할을 하는 abstract class 입니다. tree의 핵심 기능인 parentNode, nextSibling, childNodes 등을 제공합니다. Node도 실제로 생성되지는 않지만, text node, elememt node, comment node 등이 Node를 상속합니다.

Element

 - DOM element의 base class 입니다. nextElementSibling, children 과 같은 element-level navigation을 제공합니다. getElementsByTagName, querySelect 같은 searching method도 제공합니다. 브라우저는 HTML 뿐만 아니라 XML이나 SVG도 지원합니다. Element class는 HTMLElement, XMLElement, SVGElement 등의 기반 class가 됩니다.

HTMLElement

- HTML element들을 위한 기본 class 입니다. 구체적인 HTML element 들이 이 class를 상속합니다.
- 예를 들어 HTMLInputElement는 <input> element를 위한 class 입니다.
- 각 tag는 tag에 맞는 property와 method를 지원하는 class에 속해 있습니다.

DOM node의 class name을 보기 위해 constructor property를 사용할 수 있습니다.

```html
<body>
  <script>
    console.log(document.body.constructor.name);  // HTMLBodyElement
    console.log(document.body.toString());  // [object HTMLBodyElement]
  </script>
</body>
```

또는 toString으로도 가능합니다.

instanceof로 상속을 확인해볼 수 있습니다.

```html
<body>
  <input type="text">
  <script>
    const input = document.querySelector('input');
    console.log(input instanceof HTMLInputElement);
    console.log(input instanceof HTMLElement);
    console.log(input instanceof Element);
    console.log(input instanceof Node);
    console.log(input instanceof EventTarget);
  </script>
</body>
```

위 결과는 모두 true 입니다.

DOM node는 자바스크립트 object 이기도 합니다. `console.dir(input)`으로 prototype을 확인해봐도 위와 동일한 결과를 확인할 수 있습니다.

### console.log vs console.dir

인자가 object라면 비슷한 결과를 출력합니다. 하지만 인자가 DOM element라면 다른 결과를 출력합니다.

console.log는 DOM tree를 출력합니다.

console.dir은 DOM object를 출력합니다. 해당 element의 property를 확인하기 편리합니다.

### The “nodeType” property

nodeType을 사용하면 DOM node의 type을 알 수 있습니다. 하지만 요즘은 잘 사용하지 않는 방법입니다. nodeType은 각 node의 Type에 맞는 정수를 반환합니다.

요즘은 instanceof를 더 많이 사용합니다.

### Tag: nodeName and tagName

nodeName, tagName을 사용하면 DOM node의 tag name을 확인할 수 있습니다.

```html
<body>
  <input type="text">
  <script>
    const input = document.querySelector('input');
    console.log(input.tagName);  // INPUT
    console.log(input.nodeName);  // INPUT
  </script>
</body>
```

tagName은 오직 element node에만 사용할 수 있습니다.

nodeName은 모든 Node에 사용할 수 있습니다. element node는 tag name을 반환하고, text, comment node는 string을 반환합니다.

```html
<body>
  <ul><!-- comment -->
    <li>one</li>
    <li>two</li>
  </ul>
  <script>
    const ul = document.querySelector('ul');
    console.log(ul.tagName);  // UL
    console.log(ul.nodeName);  // UL

    console.log(ul.firstChild);  // <!-- comment -->
    console.log(ul.firstChild.tagName);  // undefined
    console.log(ul.firstChild.nodeName);  // #comment

    console.log(document.tagName);  // undefined
    console.log(document.nodeName);  // #document
  </script>
</body>
```

ul은 element node 입니다. ul의 tagName, nodeName 모두 UL을 반환합니다.

ul의 firstChild는 comment node 입니다.

comment node의 tagName을 출력하면 undefined가 됩니다.

nodeName을 출력하면 #comment 문자열이 출력됩니다.

document도 동일합니다. document는 document node 입니다.

document의 type이 XML이 아니라 HTML 모드인 경우 element node의 tagName, nodeName은 모두 대문자만을 반환합니다.

### innerHTML: the contents

innerHTML property를 사용하면 element 내부의 HTML을 문자열로 얻을 수 있습니다. 이것을 수정할 수 도 있습니다. 

```html
<body>
  <ul>
    <li>one</li>
    <li>two</li>
  </ul>
  <script>
    console.log(document.body.innerHTML);
    document.body.innerHTML = 'The new BODY!';
  </script>
</body>
```

body의 innerHTML을 확인하면 script까지 포함하여 모든 HTML이 text로 표현됩니다.

따라서 body.innerHTML을 다른 값으로 변경하면 script를 포함하여 모든 HTML이 대체됩니다.

innerHTML에 `<script>` tag를 삽입하면 추가되기는 하지만 실행되지는 않습니다.

### Beware: “innerHTML+=” does a full overwrite

`innerHTML +=` 처럼 코드를 작성해도 추가되는 것이 아니라 기존 데이터를 모두 삭제하고 데이터가 저장됩니다.

innerHTML은 단계적으로 `+=`를 사용했더라도 각 시점에서 데이터를 reload 합니다.

### outerHTML: full HTML of the element

outerHTML은 element 자신까지 포함하여 전체 HTML을 포함합니다. innerHTML에 자신의 element를 추가한 것과 동일합니다.

```html
<body>
  <ul>
    <li>one</li>
    <li>two</li>
  </ul>
  <script>
    const ul = document.querySelector('ul');
    console.log(ul.innerHTML);
    console.log(ul.outerHTML);
  </script>
</body>
```

위의 예제에서 ul.innerHTML은 li 2개를 출력하고, ul.outerHTML은 ul까지 포함한 전체를 출력합니다.

outerHTML은 innerHTML 처럼 element를 변경하는 것이 아니라 DOM을 교체하는 방식으로 동작합니다.

```html
<body>
  <ul>
    <li class="first">one</li>
    <li class="second">two</li>
  </ul>
  <script>
    const firstLi = document.querySelector('.first');

    console.log(firstLi.outerHTML);

    firstLi.outerHTML = '<li class="first">new first</li>';
    console.log(firstLi.outerHTML);
  </script>
</body>
```

console.log는 모두 `<li class="first">one</li>`를 출력합니다. 즉, outerHTML에 값을 입력해도 동작하지 않습니다.

하지만 DOM에는 new first가 출력됩니다.

outerHTML에 값을 대입하면 기존 element node는 삭제되고, 대입된 값이 DOM에 추가됩니다. 하지만 처음에 firstLi에 저장했던 값은 그대로 남아있습니다.

innerHTML은 기존 값을 수정하지만 outerHTML은 기존 값을 수정하지 않는다는 것을 꼭 기억해야 합니다.

### nodeValue/data: text node content

innerHTML은 element node에만 사용할 수 있습니다. text node 같은 다른 node type은 nodeValue, data 같은 property를 사용하여 값을 변경합니다. nodeValue와 data는 거의 동일하게 동작합니다.

```html
<body>
  <ul><!-- comment -->
    <li class="first">one</li>
    <li class="second">two</li>
  </ul>
  <script>
    const ul = document.querySelector('ul');
    const comment = ul.firstChild;

    console.log(comment);  // <!-- comment -->
    console.log(comment.data);  // comment
  </script>
</body>
```

### textContent: pure text

textContent를 사용하면 tag 내에 text만을 얻을 수 있습니다.

