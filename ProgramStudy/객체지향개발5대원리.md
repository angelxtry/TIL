# 객체지향 개발 5대 원리: SOLID

요새 한참 고민중인 내용이었는데 좋은 글이 보여서 간단히 요약해본다.

[객체지향 개발 5대 원리: SOLID](http://www.nextree.co.kr/p6960/)

## 5가지 원리

1. SRP 단일책임의 원칙:Single Responsibility Principle

2. OCP 개방 폐쇄의 원칙: Open Close Principle

3. LSP 리스코브 치환의 원칙: The Liskov Substitution Principle

4. ISP 인터페이스 분리의 원칙: Interface Segregation Principle

5. DIP 의존성역전의 원칙: Dependency Inversion Principle

### 1. SRP 단일책임의 원친

* 클래스는 하나의 기능만 가진다.

* 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는데 집중해야한다.

* 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

* SRP원리를 적용하면 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있다.

    * (어떤 의미인지 알 것 같기도 한데 모호하다.결론은 확실히 모른다는 거겠지 ㅠ_ㅠ)

* 책임을 적절히 분배하면 코드의 가독성 향상, 유지보수 용이 등의 이점이 있다.

* 클래스는 자신의 이름이 표현하는 일을 해야 한다.

* 올바른 클래스 이름은 해당 클래스의 책임을 나타낼 수 있는 가장 좋은 방법이다. 

### 2. OCP 개방 폐쇠의 원칙

* 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 단혀있어야 한다.

* 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.

* OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케하는 중요 메커니즘은 추상화와 다형성이다.

* 변경(확장)될 것과 변하지 않을 것을 엄격히 구분한다.

* 이 두 모듈이 만나는 지점에 인터페이스를 정의한다.

* 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다.

* 인터페이스는 가능하면 변경되지 않도록 한다.

### 3. LSP 리스코브 치환의 원칙

* 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.

* 즉, 서브 타입은 기반 타입이 약속한 규약(public 인터페이스, 메소드의 예외 처리 등)을 지켜야 한다.

* 상속은 구현상속(extends 관계)이든 인터페이스 상속(implements 관계)이든 궁극적으로는 다형성을 통한 확장성 획득을 목표로 한다.

* LSP원리도 서브 클래스가 확장에 대한 이니터페이스를 준수해야 함을 의미한다.

* 다형성과 확장성을 극대화 하려면 하위 클래스를 사용하는 것보다는 상위의 클래스(인터페이스)를 사용하는 것이 더 좋다.

* 만약 두 개체가 똑같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 만든다.

* 똑같은 연산을 제공하지만, 약간씩 다르게 한다면 공통의 인터페이스를 만들고 각각 이를 구현한다.(인터페이스 상속)

* 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만든다.

* 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용한다.

### 4. ISP 인터페이스 분리의 원칙

* 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리

* 하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다.

### 5. DIP 의존성 역전의 원칙

* 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 관계를 끊는 것.

* 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 것.

----

처음에는 잘 이해가 되는 듯 하다가 진지하게 읽어볼 수록 내용이 쉽지 않다.

좀 더 깊이있는 공부가 필요한 것 같다.
